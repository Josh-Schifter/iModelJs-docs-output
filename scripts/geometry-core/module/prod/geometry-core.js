!function(t,e){"object"===typeof exports&&"object"===typeof module?module.exports=e(require("bentleyjs_core")):"function"===typeof define&&define.amd?define("geometry_core",["bentleyjs_core"],e):"object"===typeof exports?exports.geometry_core=e(require("bentleyjs_core")):t.geometry_core=e(t.bentleyjs_core)}(this,function(t){return(this.webpackJsonp=this.webpackJsonp||[]).push([[0],{"./lib/Constant.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class Constant{}e.Constant=Constant,Constant.oneMillimeter=.001,Constant.oneCentimeter=.01,Constant.oneMeter=1,Constant.oneKilometer=1e3,Constant.diameterOfEarth=12742*Constant.oneKilometer,Constant.circumferenceOfEarth=40075*Constant.oneKilometer},"./lib/Geometry.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js");var s;!function(t){t[t.XYZ=0]="XYZ",t[t.YZX=1]="YZX",t[t.ZXY=2]="ZXY",t[t.XZY=4]="XZY",t[t.YXZ=5]="YXZ",t[t.ZYX=6]="ZYX"}(s=e.AxisOrder||(e.AxisOrder={})),function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.Z=2]="Z"}(e.AxisIndex||(e.AxisIndex={})),function(t){t[t.Top=1]="Top",t[t.Bottom=2]="Bottom",t[t.Left=3]="Left",t[t.Right=4]="Right",t[t.Front=5]="Front",t[t.Back=6]="Back",t[t.Iso=7]="Iso",t[t.RightIso=8]="RightIso"}(e.StandardViewIndex||(e.StandardViewIndex={})),function(t){t[t.Unit=0]="Unit",t[t.LongestRangeDirection=1]="LongestRangeDirection",t[t.NonUniformRangeContainment=2]="NonUniformRangeContainment"}(e.AxisScaleSelect||(e.AxisScaleSelect={}));class Geometry{static isHugeCoordinate(t){return t>this.hugeCoordinate||t<-this.hugeCoordinate}static isOdd(t){return 1===(1&t)}static correctSmallMetricDistance(t,e=0){return Math.abs(t)<Geometry.smallMetricDistance?e:t}static inverseMetricDistance(t){return Math.abs(t)<=Geometry.smallMetricDistance?void 0:1/t}static inverseMetricDistanceSquared(t){return Math.abs(t)<=Geometry.smallMetricDistanceSquared?void 0:1/t}static isSameCoordinate(t,e,r){return r?Math.abs(t-e)<Math.abs(r):Math.abs(t-e)<Geometry.smallMetricDistance}static isSameCoordinateWithToleranceFactor(t,e,r){return Geometry.isSameCoordinate(t,e,r*Geometry.smallMetricDistance)}static isSameCoordinateXY(t,e,r,i,n=Geometry.smallMetricDistance){let s=r-t;return s<0&&(s=-s),!(s>n)&&((s=i-e)<0&&(s=-s),s<n)}static isSameCoordinateSquared(t,e){return Math.abs(Math.sqrt(t)-Math.sqrt(e))<Geometry.smallMetricDistance}static isSamePoint3d(t,e){return t.distance(e)<Geometry.smallMetricDistance}static isSameXYZ(t,e){return t.distance(e)<Geometry.smallMetricDistance}static isSamePoint3dXY(t,e){return t.distanceXY(e)<Geometry.smallMetricDistance}static isSameVector3d(t,e){return t.distance(e)<Geometry.smallMetricDistance}static isSamePoint2d(t,e){return t.distance(e)<Geometry.smallMetricDistance}static isSameVector2d(t,e){return t.distance(e)<Geometry.smallMetricDistance}static lexicalXYLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}static lexicalYXLessThan(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static lexicalXYZLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:t.z<e.z?-1:t.z>e.z?1:0}static isSmallRelative(t){return Math.abs(t)<Geometry.smallAngleRadians}static isSmallAngleRadians(t){return Math.abs(t)<Geometry.smallAngleRadians}static isAlmostEqualNumber(t,e){const r=1+Math.abs(t)+Math.abs(e);return Math.abs(t-e)<=Geometry.smallAngleRadians*r}static isDistanceWithinTol(t,e){return Math.abs(t)<=Math.abs(e)}static isSmallMetricDistance(t){return Math.abs(t)<=Geometry.smallMetricDistance}static isSmallMetricDistanceSquared(t){return Math.abs(t)<=Geometry.smallMetricDistanceSquared}static cyclic3dAxis(t){if(t>=0)return t<3?t:t<6?t-3:t%3;const e=t+3;return e>=0?e:2-(-t-1)%3}static axisIndexToRightHandedAxisOrder(t){return 0===t?s.XYZ:1===t?s.YZX:2===t?s.ZXY:Geometry.axisIndexToRightHandedAxisOrder(Geometry.cyclic3dAxis(t))}static maxAbsDiff(t,e,r){return Math.max(Math.abs(t-e),Math.abs(t-r))}static maxAbsXYZ(t,e,r){return Geometry.maxXYZ(Math.abs(t),Math.abs(e),Math.abs(r))}static maxAbsXY(t,e){return Geometry.maxXY(Math.abs(t),Math.abs(e))}static maxXYZ(t,e,r){let i=t;return e>i&&(i=e),r>i&&(i=r),i}static split3WaySign(t,e,r,i){return t<0?e:t>0?i:r}static maxXY(t,e){let r=t;return e>r&&(r=e),r}static minXY(t,e){let r=t;return e<r&&(r=e),r}static hypotenuseXY(t,e){return Math.sqrt(t*t+e*e)}static hypotenuseSquaredXY(t,e){return t*t+e*e}static square(t){return t*t}static hypotenuseXYZ(t,e,r){return Math.sqrt(t*t+e*e+r*r)}static hypotenuseSquaredXYZ(t,e,r){return t*t+e*e+r*r}static hypotenuseXYZW(t,e,r,i){return Math.sqrt(t*t+e*e+r*r+i*i)}static hypotenuseSquaredXYZW(t,e,r,i){return t*t+e*e+r*r+i*i}static distanceXYXY(t,e,r,i){return Geometry.hypotenuseXY(r-t,i-e)}static distanceXYZXYZ(t,e,r,i,n,s){return Geometry.hypotenuseXYZ(i-t,n-e,s-r)}static tripleProduct(t,e,r,i,n,s,o,a,c){return t*(n*c-s*a)+e*(s*o-i*c)+r*(i*a-n*o)}static determinant4x4(t,e,r,i,n,s,o,a,c,l,d,h,u,f,g,p){return t*this.tripleProduct(s,o,a,l,d,h,f,g,p)-n*this.tripleProduct(e,r,i,l,d,h,f,g,p)+c*this.tripleProduct(e,r,i,s,o,a,f,g,p)-u*this.tripleProduct(e,r,i,s,o,a,l,d,h)}static curvatureMagnitude(t,e,r,i,n,s){let o=e*s-r*n,a=o*o;a+=(o=r*i-t*s)*o,a+=(o=t*n-e*i)*o;const c=Math.sqrt(t*t+e*e+r*r),l=Math.sqrt(a),d=c*c*c;return d>Geometry.smallAngleRadians*l?l/d:0}static tripleProductXYW(t,e,r,i,n,s){return Geometry.tripleProduct(t.x,r.x,n.x,t.y,r.y,n.y,e,i,s)}static tripleProductPoint4dXYW(t,e,r){return Geometry.tripleProduct(t.x,e.x,r.x,t.y,e.y,r.y,t.w,e.w,r.w)}static crossProductXYXY(t,e,r,i){return t*i-e*r}static crossProductXYZXYZ(t,e,r,i,s,o,a){return n.Vector3d.create(e*o-r*s,r*i-t*o,t*s-e*i,a)}static crossProductMagnitude(t,e,r,i,n,s){return Geometry.hypotenuseXYZ(e*s-r*n,r*i-t*s,t*n-e*i)}static dotProductXYZXYZ(t,e,r,i,n,s){return t*i+e*n+r*s}static dotProductXYXY(t,e,r,i){return t*r+e*i}static clampToStartEnd(t,e,r){return e>r?Geometry.clampToStartEnd(t,r,e):t<e?e:r<t?r:t}static clamp(t,e,r){return Math.max(e,Math.min(r,t))}static resolveNumber(t,e=0){return void 0!==t?t:e}static interpolate(t,e,r){return e<=.5?t+e*(r-t):r-(1-e)*(r-t)}static axisOrderToAxis(t,e){const r=t<=s.ZXY?t+e:t-s.XZY-e;return Geometry.cyclic3dAxis(r)}static modulo(t,e){if(e<=0)return 0===e?t:-Geometry.modulo(-t,-e);if(t>=0){if(t<e)return t;if(t<2*e)return t-e}else if((t+=e)>0)return t;return t-Math.floor(t/e)*e}static defined01(t){return void 0===t?0:1}static conditionalDivideFraction(t,e){if(Math.abs(e)*Geometry.largeFractionResult>Math.abs(t))return t/e}static conditionalDivideCoordinate(t,e,r=Geometry.largeCoordinateResult){if(Math.abs(e*r)>Math.abs(t))return t/e}static solveTrigForm(t,e,r){{const n=e*e+r*r;let s;if(n>0){const o=-t/n,a=1-t*t/n;if(a>=0){const t=Math.sqrt(a/n),c=o*e,l=o*r;s=[i.Vector2d.create(c-t*r,l+t*e),i.Vector2d.create(c+t*r,l-t*e)]}}return s}}static safeDivideFraction(t,e,r){const i=Geometry.conditionalDivideFraction(t,e);return void 0!==i?i:r}static inverseInterpolate(t,e,r,i,n=0,s){const o=Geometry.conditionalDivideFraction(n-e,i-e);return o?Geometry.interpolate(t,o,r):s}static inverseInterpolate01(t,e,r=0){return Geometry.conditionalDivideFraction(r-t,e-t)}static isNumberArray(t,e=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!Number.isFinite(e))return!1;return!0}return!1}static isArrayOfNumberArray(t,e,r=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!Geometry.isNumberArray(e,r))return!1;return!0}return!1}static stepCount(t,e,r=1,i=101){if(t<=0)return r;if(t>=e)return r;const n=Math.floor((e+.999999*t)/t);return n<r?r:n>i?i:n}static isIn01(t,e=!0){return!e||t>=0&&t<=1}static isIn01WithTolerance(t,e){return t+e>=0&&t-e<=1}static restrictToInterval(t,e,r){return e<=r?t<e?e:t>r?r:t:t<r?r:t>e?e:t}}e.Geometry=Geometry,Geometry.smallMetricDistance=1e-6,Geometry.smallMetricDistanceSquared=1e-12,Geometry.smallAngleRadians=1e-12,Geometry.smallAngleRadiansSquared=1e-24,Geometry.largeFractionResult=1e10,Geometry.largeCoordinateResult=1e13,Geometry.hugeCoordinate=1e12,Geometry.fullCircleRadiansMinusSmallAngle=2*Math.PI-1e-12},"./lib/bspline/BSpline1dNd.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/bspline/KnotVector.js"),s=r("./lib/Geometry.js");class BSpline1dNd{constructor(t,e,r,i){this.knots=i,this.packedData=new Float64Array(t*e),this.poleLength=e,this.basisBuffer=new Float64Array(r),this.poleBuffer=new Float64Array(e),this.basisBuffer1=new Float64Array(r),this.basisBuffer2=new Float64Array(r),this.poleBuffer1=new Float64Array(e),this.poleBuffer2=new Float64Array(e)}get degree(){return this.knots.degree}get order(){return this.knots.degree+1}get numSpan(){return this.numPoles-this.knots.degree}get numPoles(){return this.packedData.length/this.poleLength}getPoint3dPole(t,e){return i.Point3d.createFromPacked(this.packedData,t,e)}static create(t,e,r,i){return new BSpline1dNd(t,e,r,i)}spanFractionToKnot(t,e){return this.knots.spanFractionToKnot(t,e)}evaluateBasisFunctionsInSpan(t,e,r,i,n){t<0&&(t=0),t>=this.numSpan&&(t=this.numSpan-1);const s=t+this.degree-1,o=this.knots.baseKnotFractionToKnot(s,e);return i?this.knots.evaluateBasisFunctions1(s,o,r,i,n):this.knots.evaluateBasisFunctions(s,o,r)}evaluateBuffersInSpan(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer),this.sumPoleBufferForSpan(t)}evaluateBuffersInSpan1(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(t),this.sumPoleBuffer1ForSpan(t)}sumPoleBufferForSpan(t){this.poleBuffer.fill(0);let e=t*this.poleLength;for(const r of this.basisBuffer)for(let t=0;t<this.poleLength;t++)this.poleBuffer[t]+=r*this.packedData[e++]}sumPoleBuffer1ForSpan(t){this.poleBuffer1.fill(0);let e=t*this.poleLength;for(const r of this.basisBuffer1)for(let t=0;t<this.poleLength;t++)this.poleBuffer1[t]+=r*this.packedData[e++]}sumPoleBuffer2ForSpan(t){this.poleBuffer2.fill(0);let e=t*this.poleLength;for(const r of this.basisBuffer2)for(let t=0;t<this.poleLength;t++)this.poleBuffer2[t]+=r*this.packedData[e++]}evaluateBuffersAtKnot(t,e=0){const r=this.knots.knotToLeftKnotIndex(t);e<1?(this.knots.evaluateBasisFunctions(r,t,this.basisBuffer),this.sumPoleBufferForSpan(r-this.degree+1)):1===e?(this.knots.evaluateBasisFunctions1(r,t,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(r-this.degree+1),this.sumPoleBuffer1ForSpan(r-this.degree+1)):(this.knots.evaluateBasisFunctions1(r,t,this.basisBuffer,this.basisBuffer1,this.basisBuffer2),this.sumPoleBufferForSpan(r-this.degree+1),this.sumPoleBuffer1ForSpan(r-this.degree+1),this.sumPoleBuffer2ForSpan(r-this.degree+1))}reverseInPlace(){const t=this.poleLength,e=this.packedData;for(let r=0,i=t*(this.numPoles-1);r<i;r+=t,i-=t){let n=0;for(let s=0;s<t;s++)n=e[r+s],e[r+s]=e[i+s],e[i+s]=n}this.knots.reflectKnots()}testCloseablePolygon(t){void 0===t&&(t=this.knots.wrappable);const e=this.degree,r=this.poleLength,i=(this.numPoles-this.degree)*r,o=this.packedData;if(t===n.BSplineWrapMode.OpenByAddingControlPoints){const t=e*r;for(let e=0;e<t;e++)if(!s.Geometry.isSameCoordinate(o[e],o[e+i]))return!1;return!0}return t===n.BSplineWrapMode.OpenByRemovingKnots}}e.BSpline1dNd=BSpline1dNd},"./lib/bspline/BSplineCurve.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Range.js"),s=r("./lib/geometry3d/Ray3d.js"),o=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),a=r("./lib/curve/CurvePrimitive.js"),c=r("./lib/curve/Query/StrokeCountMap.js"),l=r("./lib/curve/CurveLocationDetail.js"),d=r("./lib/Geometry.js"),h=r("./lib/bspline/KnotVector.js"),u=r("./lib/geometry3d/PointHelpers.js"),f=r("./lib/bspline/BezierCurve3dH.js"),g=r("./lib/bspline/BezierCurve3d.js"),p=r("./lib/bspline/BSpline1dNd.js"),m=r("./lib/numerics/BezierPolynomials.js"),y=r("./lib/bspline/Bezier1dNd.js"),P=r("./lib/geometry4d/Point4d.js"),x=r("./lib/geometry3d/GrowableXYZArray.js");class BSplineCurve3dBase extends a.CurvePrimitive{constructor(t,e,r,i){super(),this.curvePrimitiveType="bsplineCurve",this._bcurve=p.BSpline1dNd.create(e,t,r,i)}get degree(){return this._bcurve.degree}get order(){return this._bcurve.order}get numSpan(){return this._bcurve.numSpan}get numPoles(){return this._bcurve.numPoles}copyKnots(t){return this._bcurve.knots.copyKnots(t)}setWrappable(t){this._bcurve.knots.wrappable=t}fractionToPoint(t,e){return this.knotToPoint(this._bcurve.knots.fractionToKnot(t),e)}fractionToPointAndDerivative(t,e){const r=this._bcurve.knots.fractionToKnot(t);return(e=this.knotToPointAndDerivative(r,e)).direction.scaleInPlace(this._bcurve.knots.knotLength01),e}fractionToPointAnd2Derivatives(t,e){const r=this._bcurve.knots.fractionToKnot(t);e=this.knotToPointAnd2Derivatives(r,e);const i=this._bcurve.knots.knotLength01;return e.vectorU.scaleInPlace(i),e.vectorV.scaleInPlace(i*i),e}startPoint(){return this.evaluatePointInSpan(0,0)}endPoint(){return this.evaluatePointInSpan(this.numSpan-1,1)}reverseInPlace(){this._bcurve.reverseInPlace()}collectBezierSpans(t){const e=[],r=this.numSpan;for(let i=0;i<r;i++)if(this._bcurve.knots.isIndexOfRealSpan(i)){const r=this.getSaturatedBezierSpan3dOr3dH(i,t);r&&e.push(r)}return e}poleIndexToDataIndex(t){if(t>=0&&t<this.numPoles)return t*this._bcurve.poleLength}closestPoint(t,e){const r=this.fractionToPoint(0),i=l.CurveLocationDetail.createCurveFractionPointDistance(this,0,r,r.distance(t));let n;this.fractionToPoint(1,r),i.updateIfCloserCurveFractionPointDistance(this,1,r,t.distance(r));const s=this.numSpan;for(let o=0;o<s;o++)this._bcurve.knots.isIndexOfRealSpan(o)&&(n=this.getSaturatedBezierSpan3dOr3dH(o,!0,n))&&n.updateClosestPointByTruePerpendicular(t,i)&&(i.curve=this,i.fraction=n.fractionToParentFraction(i.fraction));return i}appendPlaneIntersectionPoints(t,e){const r=this.numPoles,i=this.order,s=new Float64Array(r),o=this.numSpan,a=P.Point4d.create(),c=n.Range1d.createNull();for(let n=0;n<r;n++)s[n]=t.weightedAltitude(this.getPolePoint4d(n,a)),c.extendX(s[n]);let h,u=0,f=-1e3;if(c.containsX(0))for(let n=0;n<o;n++)if(this._bcurve.knots.isIndexOfRealSpan(n)&&(c.setNull(),c.extendArraySubset(s,n,i),c.containsX(0))){h=m.UnivariateBezier.createArraySubset(s,n,i,h),y.Bezier1dNd.saturate1dInPlace(h.coffs,this._bcurve.knots,n);const t=h.roots(0,!0);if(t)for(const r of t){u++;const t=this._bcurve.knots.spanFractionToFraction(n,r);if(!d.Geometry.isAlmostEqualNumber(t,f)){const r=l.CurveLocationDetail.createCurveEvaluatedFraction(this,t);r.intervalRole=l.CurveIntervalRole.isolated,e.push(r),f=t}}}return u}}e.BSplineCurve3dBase=BSplineCurve3dBase;class BSplineCurve3d extends BSplineCurve3dBase{constructor(t,e,r){super(3,t,e,r)}initializeWorkBezier(){return void 0===this._workBezier&&(this._workBezier=f.BezierCurve3dH.createOrder(this.order)),this._workBezier}isSameGeometryClass(t){return t instanceof BSplineCurve3d}tryTransformInPlace(t){return u.Point3dArray.multiplyInPlace(t,this._bcurve.packedData),!0}getPolePoint3d(t,e){const r=this.poleIndexToDataIndex(t);if(void 0!==r){const t=this._bcurve.packedData;return i.Point3d.create(t[r],t[r+1],t[r+2],e)}}getPolePoint4d(t,e){const r=this.poleIndexToDataIndex(t);if(void 0!==r){const t=this._bcurve.packedData;return P.Point4d.create(t[r],t[r+1],t[r+2],1,e)}}spanFractionToKnot(t,e){return this._bcurve.spanFractionToKnot(t,e)}copyPoints(){return u.Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData,3)}copyPointsFloat64Array(){return this._bcurve.packedData.slice()}copyKnots(t){return this._bcurve.knots.copyKnots(t)}static createUniformKnots(t,e){const r=t instanceof Float64Array?t.length/3:t.length;if(e<1||r<e)return;const i=h.KnotVector.createUniformClamped(r,e-1,0,1),n=new BSplineCurve3d(r,e,i);if(t instanceof Float64Array)for(let s=0;s<3*r;s++)n._bcurve.packedData[s]=t[s];else if(t instanceof x.GrowableXYZArray)n._bcurve.packedData=t.float64Data().slice(0,3*r);else{let e=0;for(const r of t)n._bcurve.packedData[e++]=r.x,n._bcurve.packedData[e++]=r.y,n._bcurve.packedData[e++]=r.z}return n}static create(t,e,r){let i=t.length;t instanceof Float64Array&&(i/=3);const n=i+r===e.length;if(r<1||i<r)return;const s=h.KnotVector.create(e,r-1,n),o=new BSplineCurve3d(i,r,s);if(t instanceof Float64Array){let e=0;for(const r of t)o._bcurve.packedData[e++]=r}else{let e=0;for(const r of t)o._bcurve.packedData[e++]=r.x,o._bcurve.packedData[e++]=r.y,o._bcurve.packedData[e++]=r.z}return o}clone(){const t=this._bcurve.knots.clone(),e=new BSplineCurve3d(this.numPoles,this.order,t);return e._bcurve.packedData=this._bcurve.packedData.slice(),e}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}evaluatePointInSpan(t,e){return this._bcurve.evaluateBuffersInSpan(t,e),i.Point3d.createFrom(this._bcurve.poleBuffer)}evaluatePointAndDerivativeInSpan(t,e){return this._bcurve.evaluateBuffersInSpan1(t,e),s.Ray3d.createCapture(i.Point3d.createFrom(this._bcurve.poleBuffer),i.Vector3d.createFrom(this._bcurve.poleBuffer1))}knotToPoint(t,e){return this._bcurve.evaluateBuffersAtKnot(t),i.Point3d.createFrom(this._bcurve.poleBuffer,e)}knotToPointAndDerivative(t,e){return this._bcurve.evaluateBuffersAtKnot(t,1),e?(e.origin.setFrom(this._bcurve.poleBuffer),e.direction.setFrom(this._bcurve.poleBuffer1),e):s.Ray3d.createCapture(i.Point3d.createFrom(this._bcurve.poleBuffer),i.Vector3d.createFrom(this._bcurve.poleBuffer1))}knotToPointAnd2Derivatives(t,e){return this._bcurve.evaluateBuffersAtKnot(t,2),o.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0],this._bcurve.poleBuffer[1],this._bcurve.poleBuffer[2],this._bcurve.poleBuffer1[0],this._bcurve.poleBuffer1[1],this._bcurve.poleBuffer1[2],this._bcurve.poleBuffer2[0],this._bcurve.poleBuffer2[1],this._bcurve.poleBuffer2[2],e)}fractionToPoint(t,e){return this.knotToPoint(this._bcurve.knots.fractionToKnot(t),e)}fractionToPointAndDerivative(t,e){const r=this._bcurve.knots.fractionToKnot(t);return(e=this.knotToPointAndDerivative(r,e)).direction.scaleInPlace(this._bcurve.knots.knotLength01),e}fractionToPointAnd2Derivatives(t,e){const r=this._bcurve.knots.fractionToKnot(t);e=this.knotToPointAnd2Derivatives(r,e);const i=this._bcurve.knots.knotLength01;return e.vectorU.scaleInPlace(i),e.vectorV.scaleInPlace(i*i),e}isAlmostEqual(t){return t instanceof BSplineCurve3d&&(this._bcurve.knots.isAlmostEqual(t._bcurve.knots)&&u.Point3dArray.isAlmostEqual(this._bcurve.packedData,t._bcurve.packedData))}isInPlane(t){return u.Point3dArray.isCloseToPlane(this._bcurve.packedData,t)}quickLength(){return u.Point3dArray.sumEdgeLengths(this._bcurve.packedData)}emitStrokableParts(t,e){const r=void 0!==t.announceBezierCurve,i=this.initializeWorkBezier(),n=this.numSpan;let s;for(let o=0;o<n;o++){const n=this.getSaturatedBezierSpan3dOr3dH(o,!1,i);n&&(s=n.computeStrokeCountForOptions(e),r?t.announceBezierCurve(n,s,this,o,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)):t.announceIntervalForUniformStepStrokes(this,s,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)))}}computeStrokeCountForOptions(t){const e=this.initializeWorkBezier(),r=this.numSpan;let i=0;for(let n=0;n<r;n++){const r=this.getSaturatedBezierSpan3dH(n,e);r&&(i+=r.computeStrokeCountForOptions(t))}return i}computeAndAttachRecursiveStrokeCounts(t,e){const r=this.initializeWorkBezier(),i=this.numSpan,n=c.StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let s=0;s<i;s++){if(this.getSaturatedBezierSpan3dH(s,r)){const e=r.curveLength(),i=r.computeStrokeCountForOptions(t);n.addToCountAndLength(i,e)}}a.CurvePrimitive.installStrokeCountMap(this,n,e)}emitStrokes(t,e){const r=this.initializeWorkBezier(),i=this.numSpan;for(let n=0;n<i;n++){const i=this.getSaturatedBezierSpan3dH(n,r);i&&i.emitStrokes(t,e)}}get isClosable(){const t=this._bcurve.knots.wrappable;return t===h.BSplineWrapMode.None?h.BSplineWrapMode.None:this._bcurve.knots.testClosable(t)&&this._bcurve.testCloseablePolygon(t)?t:h.BSplineWrapMode.None}getSaturatedBezierSpan3dOr3dH(t,e,r){return e?this.getSaturatedBezierSpan3dH(t,r):this.getSaturatedBezierSpan3d(t,r)}getSaturatedBezierSpan3d(t,e){if(t<0||t>=this.numSpan)return;const r=this.order;void 0!==e&&e instanceof g.BezierCurve3d&&e.order===r||(e=g.BezierCurve3d.createOrder(r));const i=e;return i.loadSpanPoles(this._bcurve.packedData,t),i.saturateInPlace(this._bcurve.knots,t)?e:void 0}getSaturatedBezierSpan3dH(t,e){if(t<0||t>=this.numSpan)return;const r=this.order;void 0!==e&&e instanceof f.BezierCurve3dH&&e.order===r||(e=f.BezierCurve3dH.createOrder(r));const i=e;return i.loadSpan3dPolesWithWeight(this._bcurve.packedData,t,1),i.saturateInPlace(this._bcurve.knots,t)?i:void 0}setWrappable(t){this._bcurve.knots.wrappable=t}dispatchToGeometryHandler(t){return t.handleBSplineCurve3d(this)}extendRange(t,e){const r=this._bcurve.packedData,i=r.length-2;if(e)for(let n=0;n<i;n+=3)t.extendTransformedXYZ(e,r[n],r[n+1],r[n+2]);else for(let n=0;n<i;n+=3)t.extendXYZ(r[n],r[n+1],r[n+2])}}e.BSplineCurve3d=BSplineCurve3d},"./lib/bspline/BSplineCurve3dH.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry4d/Point4d.js"),s=r("./lib/Geometry.js"),o=r("./lib/bspline/KnotVector.js"),a=r("./lib/geometry3d/PointHelpers.js"),c=r("./lib/bspline/BezierCurve3dH.js"),l=r("./lib/bspline/BSplineCurve.js"),d=r("./lib/curve/CurvePrimitive.js"),h=r("./lib/curve/Query/StrokeCountMap.js");class BSplineCurve3dH extends l.BSplineCurve3dBase{constructor(t,e,r){super(4,t,e,r)}initializeWorkBezier(){return void 0===this._workBezier&&(this._workBezier=c.BezierCurve3dH.createOrder(this.order)),this._workBezier}isSameGeometryClass(t){return t instanceof BSplineCurve3dH}tryTransformInPlace(t){return a.Point4dArray.multiplyInPlace(t,this._bcurve.packedData),!0}getPolePoint3d(t,e){const r=this.poleIndexToDataIndex(t);if(void 0!==r){const t=this._bcurve.packedData,n=s.Geometry.conditionalDivideFraction(1,t[r+3]);if(void 0!==n)return i.Point3d.create(t[r]*n,t[r+1]*n,t[r+2]*n,e)}}getPolePoint4d(t,e){const r=this.poleIndexToDataIndex(t);if(void 0!==r){const t=this._bcurve.packedData;return n.Point4d.create(t[r],t[r+1],t[r+2],t[r+3],e)}}spanFractionToKnot(t,e){return this._bcurve.spanFractionToKnot(t,e)}copyPoints(){return a.Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData,4)}copyPointsFloat64Array(){return this._bcurve.packedData.slice()}static createUniformKnots(t,e){const r=t instanceof Float64Array?t.length/4:t.length;if(e<1||r<e)return;const s=o.KnotVector.createUniformClamped(t.length,e-1,0,1),a=new BSplineCurve3dH(r,e,s);let c=0;if(t[0]instanceof i.Point3d)for(const i of t)a._bcurve.packedData[c++]=i.x,a._bcurve.packedData[c++]=i.y,a._bcurve.packedData[c++]=i.z,a._bcurve.packedData[c++]=1;else if(t[0]instanceof n.Point4d)for(const i of t)a._bcurve.packedData[c++]=i.x,a._bcurve.packedData[c++]=i.y,a._bcurve.packedData[c++]=i.z,a._bcurve.packedData[c++]=i.w;else{if(!(t instanceof Float64Array))return;{const e=t,r=e.length;for(let t=0;t<r;t++)a._bcurve.packedData[t]=e[t]}}return a}static create(t,e,r){let s=t.length;t instanceof Float64Array&&(s/=4);const a=s+r===e.length;if(r<1||s<r)return;const c=o.KnotVector.create(e,r-1,a),l=new BSplineCurve3dH(s,r,c);if(t instanceof Float64Array){let e=0;for(const r of t)l._bcurve.packedData[e++]=r}else if(t[0]instanceof n.Point4d){let e=0;for(const r of t)l._bcurve.packedData[e++]=r.x,l._bcurve.packedData[e++]=r.y,l._bcurve.packedData[e++]=r.z,l._bcurve.packedData[e++]=r.w}else if(t[0]instanceof i.Point3d){let e=0;for(const r of t)l._bcurve.packedData[e++]=r.x,l._bcurve.packedData[e++]=r.y,l._bcurve.packedData[e++]=r.z,l._bcurve.packedData[e++]=1}return l}clone(){const t=this._bcurve.knots.clone(),e=new BSplineCurve3dH(this.numPoles,this.order,t);return e._bcurve.packedData=this._bcurve.packedData.slice(),e}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}evaluatePointInSpan(t,e,r){this._bcurve.evaluateBuffersInSpan(t,e);const i=this._bcurve.poleBuffer;return n.Point4d.createRealPoint3dDefault000(i[0],i[1],i[2],i[3],r)}evaluatePointAndDerivativeInSpan(t,e,r){this._bcurve.evaluateBuffersInSpan1(t,e);const i=this._bcurve.poleBuffer,s=this._bcurve.poleBuffer1;return n.Point4d.createRealDerivativeRay3dDefault000(i[0],i[1],i[2],i[3],s[0],s[1],s[2],s[3],r)}knotToPoint(t,e){this._bcurve.evaluateBuffersAtKnot(t);const r=this._bcurve.poleBuffer;return n.Point4d.createRealPoint3dDefault000(r[0],r[1],r[2],r[3],e)}knotToPointAndDerivative(t,e){this._bcurve.evaluateBuffersAtKnot(t,1);const r=this._bcurve.poleBuffer,i=this._bcurve.poleBuffer1;return n.Point4d.createRealDerivativeRay3dDefault000(r[0],r[1],r[2],r[3],i[0],i[1],i[2],i[3],e)}knotToPointAnd2Derivatives(t,e){this._bcurve.evaluateBuffersAtKnot(t,2);const r=this._bcurve.poleBuffer,i=this._bcurve.poleBuffer1,s=this._bcurve.poleBuffer2;return n.Point4d.createRealDerivativePlane3dByOriginAndVectorsDefault000(r[0],r[1],r[2],r[3],i[0],i[1],i[2],i[3],s[0],s[1],s[2],s[3],e)}isAlmostEqual(t){return t instanceof BSplineCurve3dH&&(this._bcurve.knots.isAlmostEqual(t._bcurve.knots)&&a.Point4dArray.isAlmostEqual(this._bcurve.packedData,t._bcurve.packedData))}isInPlane(t){return a.Point4dArray.isCloseToPlane(this._bcurve.packedData,t)}quickLength(){return a.Point3dArray.sumEdgeLengths(this._bcurve.packedData)}emitStrokableParts(t,e){const r=t.announceBezierCurve,i=this.initializeWorkBezier(),n=this.numSpan;let s;for(let o=0;o<n;o++){const n=this.getSaturatedBezierSpan3dOr3dH(o,!1,i);n&&(s=n.computeStrokeCountForOptions(e),r?t.announceBezierCurve(n,s,this,o,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)):t.announceIntervalForUniformStepStrokes(this,s,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)))}}emitStrokes(t,e){const r=this.initializeWorkBezier(),i=this.numSpan;for(let n=0;n<i;n++){const i=this.getSaturatedBezierSpan3dH(n,r);i&&i.emitStrokes(t,e)}}computeStrokeCountForOptions(t){const e=this.initializeWorkBezier(),r=this.numSpan;let i=0;for(let n=0;n<r;n++){const r=this.getSaturatedBezierSpan3dH(n,e);r&&(i+=r.computeStrokeCountForOptions(t))}return i}computeAndAttachRecursiveStrokeCounts(t,e){const r=this.initializeWorkBezier(),i=this.numSpan,n=h.StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let s=0;s<i;s++){if(this.getSaturatedBezierSpan3dH(s,r)){const e=r.curveLength(),i=r.computeStrokeCountForOptions(t);n.addToCountAndLength(i,e)}}d.CurvePrimitive.installStrokeCountMap(this,n,e)}get isClosable(){if(!this._bcurve.knots.wrappable)return!1;const t=this.degree,e=this._bcurve.knots.leftKnotIndex,r=this._bcurve.knots.rightKnotIndex,i=this._bcurve.knots.rightKnot-this._bcurve.knots.leftKnot,n=r-e;for(let a=e-t+1;a<e+t-1;a++){const t=a+n;if(!s.Geometry.isSameCoordinate(this._bcurve.knots.knots[a]+i,this._bcurve.knots.knots[t]))return!1}const o=this.numPoles-this.degree;for(let a=0;a<t;a++){const t=a+o;if(!s.Geometry.isSamePoint3d(this.getPolePoint3d(a),this.getPolePoint3d(t)))return!1}return!0}getSaturatedBezierSpan3dH(t,e){if(t<0||t>=this.numSpan)return;const r=this.order;void 0!==e&&e instanceof c.BezierCurve3dH&&e.order===r||(e=c.BezierCurve3dH.createOrder(r));const i=e;return i.loadSpan4dPoles(this._bcurve.packedData,t),i.saturateInPlace(this._bcurve.knots,t)?e:void 0}getSaturatedBezierSpan3dOr3dH(t,e,r){return this.getSaturatedBezierSpan3dH(t,r)}dispatchToGeometryHandler(t){return t.handleBSplineCurve3dH(this)}extendRange(t,e){const r=this._bcurve.packedData,i=r.length-3;if(e)for(let n=0;n<i;n+=4)t.extendTransformedXYZW(e,r[n],r[n+1],r[n+2],r[n+3]);else for(let n=0;n<i;n+=4)t.extendXYZW(r[n],r[n+1],r[n+2],r[n+3])}}e.BSplineCurve3dH=BSplineCurve3dH},"./lib/bspline/BSplineSurface.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/Transform.js"),o=r("./lib/geometry3d/Matrix3d.js"),a=r("./lib/geometry3d/PointHelpers.js"),c=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),l=r("./lib/bspline/KnotVector.js"),d=r("./lib/geometry4d/Point4d.js"),h=r("./lib/curve/GeometryQuery.js");var u;!function(t){t[t.uDirection=0]="uDirection",t[t.VDirection=1]="VDirection"}(e.UVSelect||(e.UVSelect={})),function(t){t[t.UnWeighted=0]="UnWeighted",t[t.WeightsAlreadyAppliedToCoordinates=1]="WeightsAlreadyAppliedToCoordinates",t[t.WeightsSeparateFromCoordinates=2]="WeightsSeparateFromCoordinates"}(u=e.WeightStyle||(e.WeightStyle={}));class BSpline2dNd extends h.GeometryQuery{constructor(t,e,r,i,n){super(),this.geometryCategory="bsurf";const s=i.degree+1,o=n.degree+1;this.knots=[i,n],this.coffs=new Float64Array(t*e*r),this.poleDimension=r,this._basisBufferUV=[new Float64Array(s),new Float64Array(o)],this._basisBuffer1UV=[new Float64Array(s),new Float64Array(o)],this._numPoles=[t,e],this._poleBuffer=new Float64Array(r),this._poleBuffer1UV=[new Float64Array(r),new Float64Array(r)]}degreeUV(t){return this.knots[t].degree}orderUV(t){return this.knots[t].degree+1}numSpanUV(t){return this._numPoles[t]-this.knots[t].degree}numPolesTotal(){return this.coffs.length/this.poleDimension}numPolesUV(t){return this._numPoles[t]}poleStepUV(t){return 0===t?1:this._numPoles[0]}static validOrderAndPoleCounts(t,e,r,i,n){return!(t<2||e<t)&&(!(r<2||i<r)&&e*i===n)}getPoint3dPole(t,e,r){return n.Point3d.createFromPacked(this.coffs,t+e*this._numPoles[0],r)}getPoint3dPoleXYZW(t,e,r){return n.Point3d.createFromPackedXYZW(this.coffs,t+e*this._numPoles[0],r)}numberToUVSelect(t){return 0===t?0:1}extendRangeXYZ(t,e){const r=this.coffs,i=this.poleDimension,n=r.length+1-i;if(e)for(let s=0;s<n;s+=i)t.extendTransformedXYZ(e,r[s],r[s+1],r[s+2]);else for(let s=0;s<n;s+=i)t.extendXYZ(r[s],r[s+1],r[s+2])}extendRangeXYZH(t,e){const r=this.coffs,i=this.poleDimension,n=r.length+1-i;let s=0,o=0;if(e)for(let a=0;a<n;a+=i)0!==(s=r[a+3])&&(o=1/s,t.extendTransformedXYZ(e,r[a]*o,r[a+1]*o,r[a+2]*o));else for(let a=0;a<n;a+=i)0!==(s=r[a+3])&&(o=1/s,t.extendXYZ(r[a]*o,r[a+1]*o,r[a+2]*o))}fractionToRigidFrame(t,e,r){const n=this.fractionToPointAndDerivatives(t,e);if(!n)return;const a=o.Matrix3d.createColumnsInAxisOrder(i.AxisOrder.XYZ,n.vectorU,n.vectorV,void 0),c=o.Matrix3d.createRigidFromMatrix3d(a,i.AxisOrder.XYZ,a);return c&&(r=s.Transform.createOriginAndMatrix(n.origin,c,r)),r}spanFractionToKnot(t,e,r){return this.knots[t].spanFractionToKnot(e,r)}spanFractionsToBasisFunctions(t,e,r,n,s){const o=(e=i.Geometry.clampToStartEnd(e,0,this.numSpanUV(t)))+this.degreeUV(t)-1,a=this.knots[t].baseKnotFractionToKnot(o,r);return s?this.knots[t].evaluateBasisFunctions1(o,a,n,s):this.knots[t].evaluateBasisFunctions(o,a,n)}sumPoleBufferForSpan(t,e){const r=this._poleBuffer,i=this.coffs;r.fill(0);const n=this.poleDimension,s=this.poleDimension*this._numPoles[0];let o=n*t+e*s,a=0;for(const c of this._basisBufferUV[1]){let t=o;for(const e of this._basisBufferUV[0]){a=e*c;for(let e=0;e<n;e++)r[e]+=a*i[t++]}o+=s}}sumpoleBufferDerivativesForSpan(t,e){const r=this._poleBuffer1UV[0],i=this._poleBuffer1UV[1];r.fill(0),i.fill(0);const n=this.poleDimension,s=this.poleDimension*this._numPoles[0];let o=n*t+e*s,a=0;for(const c of this._basisBufferUV[1]){let t=o;for(const e of this._basisBuffer1UV[0]){a=e*c;for(let e=0;e<n;e++)r[e]+=a*this.coffs[t++]}o+=s}o=n*t+e*s;for(const c of this._basisBuffer1UV[1]){let t=o;for(const e of this._basisBufferUV[0]){a=e*c;for(let e=0;e<n;e++)i[e]+=a*this.coffs[t++]}o+=s}}evaluateBuffersAtKnot(t,e,r=0){const i=this.knots[0].knotToLeftKnotIndex(t),n=this.knots[1].knotToLeftKnotIndex(e),s=i-this.degreeUV(0)+1,o=n-this.degreeUV(1)+1;r<1?(this.knots[0].evaluateBasisFunctions(i,t,this._basisBufferUV[0]),this.knots[1].evaluateBasisFunctions(n,e,this._basisBufferUV[1]),this.sumPoleBufferForSpan(s,o)):(this.knots[0].evaluateBasisFunctions1(i,t,this._basisBufferUV[0],this._basisBuffer1UV[0]),this.knots[1].evaluateBasisFunctions1(n,e,this._basisBufferUV[1],this._basisBuffer1UV[1]),this.sumPoleBufferForSpan(s,o),this.sumpoleBufferDerivativesForSpan(s,o))}swapBlocks(t,e,r){let i;for(let n=0;n<r;n++)i=this.coffs[t+n],this.coffs[t+n]=this.coffs[e+n],this.coffs[e+n]=i}reverseInPlace(t){const e=this.poleDimension,r=this.numPolesUV(0),i=this.numPolesUV(1);if(0===t)for(let n=0;n<i;n++){const t=n*r*e;for(let i=0,n=r-1;i<n;i++,n--)this.swapBlocks(t+i*e,t+n*e,e)}else{const t=e*r;for(let e=0,r=(i-1)*t;e<r;e+=t,r-=t)this.swapBlocks(e,r,t)}this.knots[t].reflectKnots()}setWrappable(t,e){this.knots[t].wrappable=e}isClosable(t){if(this.knots[t].wrappable===l.BSplineWrapMode.None)return!1;if(!this.knots[t].testClosable())return!1;const e=this.numPolesUV(0),r=this.numPolesUV(1),n=this.poleDimension,s=e*n,o=this.degreeUV(0),a=this.degreeUV(1),c=this.coffs;if(0===t){const t=n*o;for(let e=0;e<r;e++){const r=e*s,n=r+s-t;for(let e=0;e<t;e++)if(!i.Geometry.isSameCoordinate(c[r+e],c[n+e]))return!1}}else{const t=a*s,o=n*e*r-t;for(let e=0;e<t;e++)if(!i.Geometry.isSameCoordinate(c[e],c[o+e]))return!1}return!0}}e.BSpline2dNd=BSpline2dNd;class BSplineSurface3d extends BSpline2dNd{isSameGeometryClass(t){return t instanceof BSplineSurface3d}tryTransformInPlace(t){return a.Point3dArray.multiplyInPlace(t,this.coffs),!0}getPole(t,e,r){return this.getPoint3dPole(t,e,r)}constructor(t,e,r,i){super(t,e,3,r,i)}getPointArray(t=!0){return t?a.Point3dArray.unpackNumbersToNestedArrays(this.coffs,3):a.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs,3,this.numPolesUV(0))}getPointGridJSON(){return{points:a.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs,3,this.numPolesUV(0)),weighStyle:u.UnWeighted,numCartesianDimensions:3}}copyPointsFloat64Array(){return this.coffs.slice()}copyKnots(t,e){return this.knots[t].copyKnots(e)}static create(t,e,r,i,n,s,o){let a=t.length;if(t instanceof Float64Array&&(a/=3),!this.validOrderAndPoleCounts(r,e,s,n,a))return;const c=e+r===(i?i.length:e+r-2),d=n+s===(o?o.length:n+s-2),h=i?l.KnotVector.create(i,r-1,c):l.KnotVector.createUniformClamped(e,r-1,0,1),u=o?l.KnotVector.create(o,s-1,d):l.KnotVector.createUniformClamped(n,s-1,0,1),f=new BSplineSurface3d(e,n,h,u);if(t instanceof Float64Array){let e=0;for(const r of t)f.coffs[e++]=r}else{let e=0;for(const r of t)f.coffs[e++]=r.x,f.coffs[e++]=r.y,f.coffs[e++]=r.z}return f}static createGrid(t,e,r,i,n){const s=t.length,o=t[0].length,a=o*s,c=o+e===(r?r.length:o+e-2),d=s+i===(n?n.length:s+i-2);if(!this.validOrderAndPoleCounts(e,o,i,s,a))return;const h=r?l.KnotVector.create(r,e-1,c):l.KnotVector.createUniformClamped(o,e-1,0,1),u=n?l.KnotVector.create(n,i-1,d):l.KnotVector.createUniformClamped(o,e-1,0,1),f=new BSplineSurface3d(o,s,h,u);let g=0;for(const l of t)for(const t of l)f.coffs[g++]=t[0],f.coffs[g++]=t[1],f.coffs[g++]=t[2];return f}clone(){const t=this.knots[0].clone(),e=this.knots[1].clone(),r=new BSplineSurface3d(this.numPolesUV(0),this.numPolesUV(1),t,e);return r.coffs=this.coffs.slice(),r}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}knotToPoint(t,e){return this.evaluateBuffersAtKnot(t,e),n.Point3d.createFrom(this._poleBuffer)}knotToPointAndDerivatives(t,e,r){return this.evaluateBuffersAtKnot(t,e,1),c.Plane3dByOriginAndVectors.createOriginAndVectorsArrays(this._poleBuffer,this._poleBuffer1UV[0],this._poleBuffer1UV[1],r)}fractionToPoint(t,e){return this.knotToPoint(this.knots[0].fractionToKnot(t),this.knots[1].fractionToKnot(e))}fractionToPointAndDerivatives(t,e,r){const i=this.knots[0].fractionToKnot(t),n=this.knots[1].fractionToKnot(e);return this.knotToPointAndDerivatives(i,n,r)}isAlmostEqual(t){return t instanceof BSplineSurface3d&&(this.knots[0].isAlmostEqual(t.knots[0])&&this.knots[1].isAlmostEqual(t.knots[1])&&a.Point3dArray.isAlmostEqual(this.coffs,t.coffs))}isInPlane(t){return a.Point3dArray.isCloseToPlane(this.coffs,t)}dispatchToGeometryHandler(t){return t.handleBSplineSurface3d(this)}extendRange(t,e){this.extendRangeXYZ(t,e)}}e.BSplineSurface3d=BSplineSurface3d;class BSplineSurface3dH extends BSpline2dNd{isSameGeometryClass(t){return t instanceof BSplineSurface3dH}tryTransformInPlace(t){return a.Point4dArray.multiplyInPlace(t,this.coffs),!0}getPole(t,e,r){return this.getPoint3dPoleXYZW(t,e,r)}constructor(t,e,r,i){super(t,e,4,r,i)}copyPoints4d(){return a.Point4dArray.unpackToPoint4dArray(this.coffs)}copyPointsAndWeights(t,e,r=n.Point3d.create){a.Point4dArray.unpackFloat64ArrayToPointsAndWeights(this.coffs,t,e,r)}copyKnots(t,e){return this.knots[t].copyKnots(e)}static create(t,e,r,i,n,s,o,c){const d=t.length;if(r*s!==d)return;if(!this.validOrderAndPoleCounts(i,r,o,s,d))return;const h=r+i===(n?n.length:r+i-2),u=s+o===(c?c.length:s+o-2),f=n?l.KnotVector.create(n,i-1,h):l.KnotVector.createUniformClamped(r,i-1,0,1),g=c?l.KnotVector.create(c,o-1,u):l.KnotVector.createUniformClamped(s,o-1,0,1),p=new BSplineSurface3dH(r,s,f,g);return a.Point4dArray.packPointsAndWeightsToFloat64Array(t,e,p.coffs),p}static createGrid(t,e,r,i,n,s){const o=t.length,a=t[0].length,c=a*o;if(!this.validOrderAndPoleCounts(r,a,n,o,c))return;const d=a+r===i.length,h=o+n===s.length,f=l.KnotVector.create(i,r-1,d),g=l.KnotVector.create(s,n-1,h),p=new BSplineSurface3dH(a,o,f,g);if(e===u.WeightsSeparateFromCoordinates){let e=0;for(const r of t)for(const t of r){const r=t[3];p.coffs[e++]=t[0]*r,p.coffs[e++]=t[1]*r,p.coffs[e++]=t[2]*r,p.coffs[e++]=t[3]}}else{let e=0;for(const r of t)for(const t of r)p.coffs[e++]=t[0],p.coffs[e++]=t[1],p.coffs[e++]=t[2],p.coffs[e++]=t[3]}return p}clone(){const t=this.knots[0].clone(),e=this.knots[1].clone(),r=new BSplineSurface3dH(this.numPolesUV(0),this.numPolesUV(1),t,e);return r.coffs=this.coffs.slice(),r}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}getPointGridJSON(){return{points:a.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs,4,this.numPolesUV(0)),numCartesianDimensions:3,weightStyle:u.WeightsAlreadyAppliedToCoordinates}}knotToPoint4d(t,e){return this.evaluateBuffersAtKnot(t,e),d.Point4d.createFromPackedXYZW(this._poleBuffer,0)}knotToPointAndDerivatives(t,e,r){return this.evaluateBuffersAtKnot(t,e,1),c.Plane3dByOriginAndVectors.createOriginAndVectorsWeightedArrays(this._poleBuffer,this._poleBuffer1UV[0],this._poleBuffer1UV[1],r)}fractionToPoint4d(t,e){return this.knotToPoint4d(this.knots[0].fractionToKnot(t),this.knots[1].fractionToKnot(e))}fractionToPoint(t,e,r){return this.knotToPoint4d(this.knots[0].fractionToKnot(t),this.knots[1].fractionToKnot(e)).realPointDefault000(r)}knotToPoint(t,e,r){return this.knotToPoint4d(t,e).realPointDefault000(r)}fractionToPointAndDerivatives(t,e,r){const i=this.knots[0].fractionToKnot(t),n=this.knots[1].fractionToKnot(e);return this.knotToPointAndDerivatives(i,n,r)}isAlmostEqual(t){return t instanceof BSplineSurface3dH&&(this.knots[0].isAlmostEqual(t.knots[0])&&this.knots[1].isAlmostEqual(t.knots[1])&&a.Point4dArray.isAlmostEqual(this.coffs,t.coffs))}isInPlane(t){return a.Point4dArray.isCloseToPlane(this.coffs,t)}dispatchToGeometryHandler(t){return t.handleBSplineSurface3dH(this)}extendRange(t,e){this.extendRangeXYZH(t,e)}}e.BSplineSurface3dH=BSplineSurface3dH},"./lib/bspline/Bezier1dNd.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/Segment1d.js"),o=r("./lib/geometry4d/Point4d.js"),a=r("./lib/Geometry.js"),c=r("./lib/geometry3d/PointHelpers.js"),l=r("./lib/numerics/BezierPolynomials.js");class Bezier1dNd{constructor(t,e){this._blockSize=t,this._order=Math.floor(e.length/t),this._packedData=e,this._basis=new l.UnivariateBezier(this._order)}clonePolygon(t){const e=this._packedData.length;if(!t||t.length!==e)return this._packedData.slice();for(let r=0;r<e;r++)t[r]=this._packedData[r];return t}get order(){return this._order}get packedData(){return this._packedData}static create(t){if(!(t.length<1)){if(t[0]instanceof n.Point3d){const e=new Float64Array(3*t.length);let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=i.z;return new Bezier1dNd(3,e)}if(t[0]instanceof o.Point4d){const e=new Float64Array(4*t.length);let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=i.z,e[r++]=i.w;return new Bezier1dNd(4,e)}if(t[0]instanceof i.Point2d){const e=new Float64Array(2*t.length);let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y;return new Bezier1dNd(2,e)}}}evaluate(t,e){return this._basis.sumBasisFunctions(t,this._packedData,this._blockSize,e)}evaluateDerivative(t,e){return this._basis.sumBasisFunctionDerivatives(t,this._packedData,this._blockSize,e)}getPolygonPoint(t,e){if(e||(e=new Float64Array(this._blockSize)),t>=0&&t<this._order){const r=this._blockSize*t;for(let t=0;t<this._blockSize;t++)e[t]=this._packedData[r+t];return e}}setPolygonPoint(t,e){if(t>=0&&t<this._order){const r=this._blockSize*t;for(let t=0;t<this._blockSize;t++)this._packedData[r+t]=e[t]}}loadSpanPoles(t,e){let r=e*this._blockSize;for(let i=0;i<this._packedData.length;i++)this._packedData[i]=t[r++]}loadSpanPolesWithWeight(t,e,r,i){let n=0;const s=this._order;let o=r*e;for(let a=0;a<s;a++){for(let r=0;r<e;r++)this._packedData[n++]=t[o++];this._packedData[n++]=i}}unpackToJsonArrays(){return c.Point3dArray.unpackNumbersToNestedArrays(this._packedData,this._blockSize)}isAlmostEqual(t){if(t instanceof Bezier1dNd){if(this._blockSize!==t._blockSize)return!1;if(this._order!==t._order)return!1;if(this._packedData.length!==t._packedData.length)return!1;for(let e=0;e<this._packedData.length;e++)if(!a.Geometry.isSameCoordinate(this._packedData[e],t._packedData[e]))return!1;return!0}return!1}reverseInPlace(){const t=this._blockSize;let e,r,i;for(e=0,r=(this._order-1)*t;e<r;e+=t,r-=t)for(let n=0;n<t;n++)i=this._packedData[e+n],this._packedData[e+n]=this._packedData[r+n],this._packedData[r+n]=i}interpolatePoleInPlace(t,e,r){let i=t*this._blockSize,n=r*this._blockSize;const s=this._packedData;for(let o=0;o<this._blockSize;o++,i++,n++)s[i]+=e*(s[n]-s[i])}saturateInPlace(t,e){const r=t.degree,i=e+r-1,n=i+1;if(e<0||e>=t.numSpans)return!1;const s=t.knots,o=s[i],a=s[n];if(this.setInterval(o,a),a<=o+Bezier1dNd._knotTolerance)return!1;for(let c=r-1;c>0;c--){let t=i-c;if(s[t]<o){let e=n;for(let r=0;r<c;r++,t++,e++){const i=s[t],n=(o-i)/(s[e]-i);this.interpolatePoleInPlace(r,n,r+1)}}}for(let c=r-1;c>0;c--){let t=n+c;if(s[t]>a)for(let e=0;e<c;e++,t--){const i=s[t],n=(a-i)/(o-i);this.interpolatePoleInPlace(r-e,n,r-e-1)}}return!0}static saturate1dInPlace(t,e,r){const i=e.degree,n=r+i-1,s=n+1;if(r<0||r>=e.numSpans)return!1;const o=e.knots,a=o[n],c=o[s];for(let l=i-1;l>0;l--){let e=n-l;if(o[e]<a){let r=s;for(let i=0;i<l;i++,e++,r++){const n=o[e],s=(a-n)/(o[r]-n);t[i]=t[i]+s*(t[i+1]-t[i])}}}for(let l=i-1;l>0;l--){let e,r=s+l;if(o[r]>c)for(let n=0;n<l;n++,r--){const s=o[r],l=(c-s)/(a-s);t[e=i-n]+=l*(t[e-1]-t[e])}}return!0}subdivideInPlaceKeepLeft(t){if(a.Geometry.isAlmostEqualNumber(t,1))return!0;if(a.Geometry.isAlmostEqualNumber(t,0))return!1;const e=1-t,r=this.order;for(let i=1;i<r;i++)for(let t=r-1;t>=i;t--)this.interpolatePoleInPlace(t,e,t-1);return!0}subdivideInPlaceKeepRight(t){if(a.Geometry.isAlmostEqualNumber(t,0))return!0;if(a.Geometry.isAlmostEqualNumber(t,1))return!1;const e=this.order;for(let r=1;r<e;r++)for(let i=0;i+r<e;i++)this.interpolatePoleInPlace(i,t,i+1);return!0}subdivideToIntervalInPlace(t,e){return!a.Geometry.isAlmostEqualNumber(t,e)&&(e<t?(this.subdivideToIntervalInPlace(t,e),this.reverseInPlace(),!0):(this.subdivideInPlaceKeepLeft(e),this.subdivideInPlaceKeepRight(t/e),!0))}setInterval(t,e){this.interval=s.Segment1d.create(t,e,this.interval)}fractionToParentFraction(t){return this.interval?this.interval.fractionToPoint(t):t}}e.Bezier1dNd=Bezier1dNd,Bezier1dNd._knotTolerance=1e-8},"./lib/bspline/BezierCurve3d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry4d/Point4d.js"),o=r("./lib/geometry3d/Ray3d.js"),a=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),c=r("./lib/curve/LineString3d.js"),l=r("./lib/bspline/BezierCurveBase.js"),d=r("./lib/numerics/BezierPolynomials.js");class BezierCurve3d extends l.BezierCurveBase{constructor(t){super(3,t),this._workRay0=o.Ray3d.createXAxis(),this._workRay1=o.Ray3d.createXAxis()}isSameGeometryClass(t){return t instanceof BezierCurve3d}tryTransformInPlace(t){const e=this._workData0;for(let r=0;r<this._polygon.order;r++)this._polygon.getPolygonPoint(r,e),t.multiplyXYZToFloat64Array(e[0],e[1],e[2],e),this._polygon.setPolygonPoint(r,e);return!0}getPolePoint3d(t,e){const r=this._polygon.getPolygonPoint(t,this._workData0);if(r)return n.Point3d.create(r[0],r[1],r[2],e)}getPolePoint4d(t,e){const r=this._polygon.getPolygonPoint(t,this._workData0);if(r)return s.Point4d.create(r[0],r[1],r[2],1,e)}copyPointsAsLineString(){const t=c.LineString3d.create();for(let e=0;e<this._polygon.order;e++)t.addPoint(this.getPolePoint3d(e));return t}static create(t){if(t.length<1)return;const e=new Float64Array(3*t.length);if(t[0]instanceof n.Point3d){let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=i.z;return new BezierCurve3d(e)}if(t[0]instanceof i.Point2d){let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=0;return new BezierCurve3d(e)}}static createOrder(t){const e=new Float64Array(3*t);return new BezierCurve3d(e)}loadSpanPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new BezierCurve3d(this._polygon.clonePolygon())}clonePartialCurve(t,e){const r=new BezierCurve3d(this._polygon.clonePolygon());return r._polygon.subdivideToIntervalInPlace(t,e),r}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),n.Point3d.create(this._workData0[0],this._workData0[1],this._workData0[2],e)}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),o.Ray3d.createXYZUVW(this._workData0[0],this._workData0[1],this._workData0[2],this._workData1[0],this._workData1[1],this._workData1[2],e)}fractionToPointAnd2Derivatives(t,e){e||(e=a.Plane3dByOriginAndVectors.createXYPlane());const r=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(r.origin),e.vectorU.setFrom(r.direction);const i=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),s=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return n.Vector3d.createAdd2Scaled(i.direction,-5e7,s.direction,5e7,e.vectorV),e}isAlmostEqual(t){return t instanceof BezierCurve3d&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3d(this)}extendRange(t,e){const r=this.order;if(e){this.allocateAndZeroBezierWorkData(r-1,r,0);const i=this._workBezier,n=this._workCoffsA;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(r-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const s=this._polygon.packedData;for(let o=0;o<3;o++){for(let t=0,i=0;t<r;t++,i+=3)n[t]=e.multiplyComponentXYZ(o,s[i],s[i+1],s[i+2]);d.BezierPolynomialAlgebra.univariateDifference(n,i.coffs);const a=i.roots(0,!0);if(a&&a.length>0)for(const r of a)this.fractionToPoint(r,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(r-1,0,0);const e=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(r-1,this._workPoint0),t.extend(this._workPoint0);for(let i=0;i<3;i++){d.BezierPolynomialAlgebra.componentDifference(e.coffs,this._polygon.packedData,3,r,i);const n=e.roots(0,!0);if(n)for(const e of n)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}e.BezierCurve3d=BezierCurve3d},"./lib/bspline/BezierCurve3dH.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry4d/Point4d.js"),o=r("./lib/geometry3d/Ray3d.js"),a=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),c=r("./lib/Geometry.js"),l=r("./lib/numerics/BezierPolynomials.js"),d=r("./lib/bspline/BezierCurveBase.js");class BezierCurve3dH extends d.BezierCurveBase{constructor(t){super(4,t),this._workRay0=o.Ray3d.createXAxis(),this._workRay1=o.Ray3d.createXAxis()}isSameGeometryClass(t){return t instanceof BezierCurve3dH}tryTransformInPlace(t){const e=this._workData0;for(let r=0;r<this._polygon.order;r++)this._polygon.getPolygonPoint(r,e),t.multiplyXYZWToFloat64Array(e[0],e[1],e[2],e[3],e),this._polygon.setPolygonPoint(r,e);return!0}tryMultiplyMatrix4dInPlace(t){t.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData)}getPolePoint4d(t,e){const r=this._polygon.getPolygonPoint(t,this._workData0);if(r)return s.Point4d.create(r[0],r[1],r[2],r[3],e)}getPolePoint3d(t,e){const r=this._polygon.getPolygonPoint(t,this._workData0);if(r)return n.Point3d.createFromPackedXYZW(r,0,e)}isUnitWeight(t){void 0===t&&(t=c.Geometry.smallAngleRadians);const e=1-t,r=1+t,i=this._polygon.packedData,n=i.length;let s;for(let o=3;o<n;o+=4)if((s=i[o])<e||s>r)return!1;return!0}static create(t){if(t.length<1)return;const e=new Float64Array(4*t.length);if(t[0]instanceof n.Point3d){let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=i.z,e[r++]=1;return new BezierCurve3dH(e)}if(t[0]instanceof s.Point4d){let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=i.z,e[r++]=i.w;return new BezierCurve3dH(e)}if(t[0]instanceof i.Point2d){let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=0,e[r++]=1;return new BezierCurve3dH(e)}}static createOrder(t){const e=new Float64Array(4*t);return new BezierCurve3dH(e)}loadSpan3dPolesWithWeight(t,e,r){this._polygon.loadSpanPolesWithWeight(t,3,e,r)}loadSpan4dPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new BezierCurve3dH(this._polygon.clonePolygon())}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),(e=n.Point3d.createFromPackedXYZW(this._workData0,0,e))||n.Point3d.createZero()}fractionToPoint4d(t,e){return this._polygon.evaluate(t,this._workData0),s.Point4d.createFromPackedXYZW(this._workData0,0,e)}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),(e=o.Ray3d.createWeightedDerivative(this._workData0,this._workData1,e))||o.Ray3d.createXAxis()}fractionToPointAnd2Derivatives(t,e){e||(e=a.Plane3dByOriginAndVectors.createXYPlane());const r=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(r.origin),e.vectorU.setFrom(r.direction);const i=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),s=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return n.Vector3d.createAdd2Scaled(i.direction,-5e7,s.direction,5e7,e.vectorV),e}isAlmostEqual(t){return t instanceof BezierCurve3dH&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3dH(this)}poleProductsXYZW(t,e,r,i,n){const s=this.numPoles,o=this._polygon.packedData;for(let a=0,c=0;a<s;a++,c+=4)t[a]=e*o[c]+r*o[c+1]+i*o[c+2]+n*o[c+3]}updateClosestPointByTruePerpendicular(t,e){let r,i=0;if(this.isUnitWeight()){const e=2*this.order-2;this.allocateAndZeroBezierWorkData(e,0,0);const i=this._workBezier;l.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,0,-t.x,0),l.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,1,-t.y,1),l.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,2,-t.z,2),r=i.roots(0,!0)}else{const e=this.order,i=2*this.order-2,n=e+i-1;this.allocateAndZeroBezierWorkData(n,e,i);const s=this._workBezier,o=this._workCoffsA,a=this._workCoffsB,c=this._polygon.packedData;for(let r=0;r<3;r++)l.BezierPolynomialAlgebra.scaledComponentSum(o,c,4,e,3,t.at(r),r,-1),l.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,1,3,1,r),l.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,-1,r,1,3),l.BezierPolynomialAlgebra.accumulateProduct(s.coffs,o,a);r=s.roots(0,!0)}if(r)for(const n of r){const r=this.fractionToPoint(n),s=r.distance(t);i+=e.updateIfCloserCurveFractionPointDistance(this,n,r,s)?1:0}return i>0}extendRange(t,e){const r=this.order;if(e){this.allocateAndZeroBezierWorkData(2*r-2,r,r);const i=this._workCoffsA,n=this._workCoffsB,s=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(r-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const o=this._polygon.packedData;let a;for(let c=0;c<3;c++){s.zero();for(let t=0,s=0;t<r;t++,s+=4)a=o[s+3],i[t]=e.multiplyComponentXYZW(c,o[s],o[s+1],o[s+2],a),n[t]=a;l.BezierPolynomialAlgebra.accumulateProductWithDifferences(s.coffs,i,n,1),l.BezierPolynomialAlgebra.accumulateProductWithDifferences(s.coffs,n,i,-1);const d=s.roots(0,!0);if(d&&d.length>0)for(const r of d)this.fractionToPoint(r,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(2*r-2,0,0);const e=this._workBezier,i=this._polygon.packedData;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(r-1,this._workPoint0),t.extend(this._workPoint0);for(let n=0;n<3;n++){e.zero(),l.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,i,4,r,1,n,0,3),l.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,i,4,r,-1,3,0,n);const s=e.roots(0,!0);if(s)for(const e of s)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}e.BezierCurve3dH=BezierCurve3dH},"./lib/bspline/BezierCurveBase.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/curve/CurvePrimitive.js"),s=r("./lib/curve/StrokeOptions.js"),o=r("./lib/bspline/Bezier1dNd.js"),a=r("./lib/numerics/BezierPolynomials.js"),c=r("./lib/Geometry.js"),l=r("./lib/geometry3d/Angle.js");e.BezierCurveBase=class BezierCurveBase extends n.CurvePrimitive{constructor(t,e){super(),this.curvePrimitiveType="bezierCurve",this._polygon=new o.Bezier1dNd(t,e),this._workPoint0=i.Point3d.create(),this._workPoint1=i.Point3d.create(),this._workData0=new Float64Array(t),this._workData1=new Float64Array(t)}reverseInPlace(){this._polygon.reverseInPlace()}saturateInPlace(t,e){const r=this._polygon.saturateInPlace(t,e);return r&&this.setInterval(t.spanFractionToFraction(e,0),t.spanFractionToFraction(e,1)),r}get degree(){return this._polygon.order-1}get order(){return this._polygon.order}get numPoles(){return this._polygon.order}setInterval(t,e){this._polygon.setInterval(t,e)}fractionToParentFraction(t){return this._polygon.fractionToParentFraction(t)}emitStrokes(t,e){const r=this.computeStrokeCountForOptions(e),i=1/r;for(let n=0;n<=r;n++){const e=n*i;this.fractionToPoint(e,this._workPoint0),t.appendStrokePoint(this._workPoint0)}}emitStrokableParts(t,e){const r=this.computeStrokeCountForOptions(e);t.announceIntervalForUniformStepStrokes(this,r,0,1)}copyPolesAsJsonArray(){return this._polygon.unpackToJsonArrays()}isInPlane(t){let e=this._workPoint0;for(let r=0;;r++){if(!(e=this.getPolePoint3d(r,e)))return!0;if(!t.isPointInPlane(e))break}return!1}polygonLength(){if(!this.getPolePoint3d(0,this._workPoint0))return 0;let t=0,e=0;for(;this.getPolePoint3d(++t,this._workPoint1);)e+=this._workPoint0.distance(this._workPoint1),this._workPoint0.setFrom(this._workPoint1);return e}startPoint(){return this.getPolePoint3d(0)}endPoint(){return this.getPolePoint3d(this.order-1)}quickLength(){return this.polygonLength()}allocateAndZeroBezierWorkData(t,e,r){t>0&&(void 0!==this._workBezier&&this._workBezier.order===t?this._workBezier.zero():this._workBezier=new a.UnivariateBezier(t)),e>0&&(void 0!==this._workCoffsA&&this._workCoffsA.length===e?this._workCoffsA.fill(0):this._workCoffsA=new Float64Array(e)),r>0&&(void 0!==this._workCoffsB&&this._workCoffsB.length===r?this._workCoffsB.fill(0):this._workCoffsB=new Float64Array(r))}computeStrokeCountForOptions(t){this.getPolePoint3d(0,this._workPoint0),this.getPolePoint3d(1,this._workPoint1);let e=1;if(this._workPoint0&&this._workPoint1){let r,i,n,o=this._workPoint1.x-this._workPoint0.x,a=this._workPoint1.y-this._workPoint0.y,d=this._workPoint1.z-this._workPoint0.z,h=0,u=c.Geometry.hypotenuseXYZ(o,a,d);this._workPoint1.setFromPoint3d(this._workPoint0);let f,g=u,p=u,m=0;for(let t=2;this.getPolePoint3d(t,this._workPoint1);t++)r=this._workPoint1.x-this._workPoint0.x,i=this._workPoint1.y-this._workPoint0.y,n=this._workPoint1.z-this._workPoint0.z,h+=f=l.Angle.radiansBetweenVectorsXYZ(o,a,d,r,i,n),m=c.Geometry.maxAbsXY(f,m),g+=u=c.Geometry.hypotenuseXYZ(r,i,n),p=c.Geometry.maxXY(p,u),o=r,a=i,d=n,this._workPoint0.setFrom(this._workPoint1);const y=p*this.degree,P=Math.sqrt(y*g);let x=m*(this.degree-1);this.degree<3&&(x*=3);const _=Math.sqrt(x*h);e=s.StrokeOptions.applyAngleTol(t,s.StrokeOptions.applyMaxEdgeLength(t,this.degree,P),_,.1),t&&(e=t.applyChordTolToLengthAndRadians(e,g,x))}return e}}},"./lib/bspline/KnotVector.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/PointHelpers.js");var s;!function(t){t[t.None=0]="None",t[t.OpenByAddingControlPoints=1]="OpenByAddingControlPoints",t[t.OpenByRemovingKnots=2]="OpenByRemovingKnots"}(s=e.BSplineWrapMode||(e.BSplineWrapMode={}));class KnotVector{constructor(t,e){this.degree=e,this._knot0=0,this._knot1=1,Array.isArray(t)?(this.knots=new Float64Array(t.length),this.setKnots(t),this.setupFixedValues()):t instanceof Float64Array?(this.knots=t.slice(),this.setupFixedValues()):this.knots=new Float64Array(t)}get leftKnot(){return this._knot0}get rightKnot(){return this._knot1}get leftKnotIndex(){return this.degree-1}get rightKnotIndex(){return this.knots.length-this.degree}get wrappable(){return void 0===this._wrapMode?s.None:this._wrapMode}set wrappable(t){this._wrapMode=t}get numSpans(){return this.rightKnotIndex-this.leftKnotIndex}clone(){return new KnotVector(this.knots,this.degree)}setupFixedValues(){this._knot0=this.knots[this.degree-1],this._knot1=this.knots[this.knots.length-this.degree]}get knotLength01(){return this._knot1-this._knot0}testClosable(t){void 0===t&&(t=this.wrappable);const e=this.leftKnotIndex,r=this.rightKnotIndex,n=this.rightKnot-this.leftKnot,o=this.degree,a=r-e;if(t===s.OpenByAddingControlPoints){for(let t=e-o+1;t<e+o-1;t++){const e=t+a;if(!i.Geometry.isSameCoordinate(this.knots[t]+n,this.knots[e]))return!1}return!0}if(t===s.OpenByRemovingKnots){const t=o-1,n=this.knots[e],s=this.knots[r];for(let o=0;o<t;o++){if(!i.Geometry.isSameCoordinate(n,this.knots[e-o-1]))return!1;if(!i.Geometry.isSameCoordinate(s,this.knots[r+o+1]))return!1}return!0}return!1}isAlmostEqual(t){return this.degree===t.degree&&n.NumberArray.isAlmostEqual(this.knots,t.knots,KnotVector.knotTolerance)}setKnots(t,e){const r=e?t.length-2:t.length;if(r!==this.knots.length&&(this.knots=new Float64Array(r)),e)for(let i=1;i+1<t.length;i++)this.knots[i-1]=t[i];else for(let i=0;i<t.length;i++)this.knots[i]=t[i];this.setupFixedValues()}static createUniformClamped(t,e,r,i){const n=new KnotVector(t+e-1,e);let s=0;for(let a=0;a<e;a++)n.knots[s++]=r;const o=1/(t-e);for(let a=1;a+e<t;a++)n.knots[s++]=r+a*o*(i-r);for(let a=0;a<e;a++)n.knots[s++]=i;return n.setupFixedValues(),n}static createUniformWrapped(t,e,r,n){const s=new KnotVector(t+2*e-1,e),o=1/t;for(let a=1-e,c=0;a<t+e;a++,c++)s.knots[c]=i.Geometry.interpolate(r,a*o,n);return s.setupFixedValues(),s}static create(t,e,r){const i=r?t.length-2:t.length,n=new KnotVector(i,e);return n.setKnots(t,r),n}grevilleKnot(t){if(t<0)return this.leftKnot;if(t>this.rightKnotIndex)return this.rightKnot;let e=0;for(let r=t;r<t+this.degree;r++)e+=this.knots[r];return e/this.degree}createBasisArray(){return new Float64Array(this.degree+1)}baseKnotFractionToKnot(t,e){const r=this.knots[t];return r+e*(this.knots[t+1]-r)}spanFractionToKnot(t,e){const r=this.spanIndexToLeftKnotIndex(t);return this.knots[r]+e*(this.knots[r+1]-this.knots[r])}spanFractionToFraction(t,e){return(this.spanFractionToKnot(t,e)-this.leftKnot)/(this.rightKnot-this.leftKnot)}fractionToKnot(t){return i.Geometry.interpolate(this.knots[this.degree-1],t,this.knots[this.knots.length-this.degree])}evaluateBasisFunctions(t,e,r){if(r[0]=1,this.degree<1)return;const i=this.knots[t],n=this.knots[t+1];if(r[1]=(e-i)/(n-i),r[0]=1-r[1],!(this.degree<2))for(let s=1;s<this.degree;s++){let i=t-s,n=i+s+1,o=0;for(let t=0;t<=s;t++){const s=this.knots[i++],a=(e-s)/(this.knots[n++]-s),c=r[t]*a,l=r[t]*(1-a);r[t]=o+l,o=c}r[s+1]=o}}evaluateBasisFunctions1(t,e,r,i,n){if(r[0]=1,i[0]=0,this.degree<1)return;const s=this.knots[t];let o=1/(this.knots[t+1]-s);if(r[1]=(e-s)*o,r[0]=1-r[1],i[0]=-o,i[1]=o,n&&(n[0]=0,n[1]=0),!(this.degree<2))for(let a=1;a<this.degree;a++){let s=t-a,c=s+a+1,l=0,d=0,h=0;for(let t=0;t<=a;t++){const a=this.knots[s++],u=(e-a)*(o=1/(this.knots[c++]-a)),f=1-u,g=r[t]*u,p=r[t]*f,m=i[t]*u+r[t]*o,y=i[t]*f-r[t]*o,P=2*i[t]*o;if(r[t]=l+p,i[t]=d+y,l=g,d=m,n){const e=n[t]*u+P,r=n[t]*f-P;n[t]=h+r,h=e}}r[a+1]=l,i[a+1]=d,n&&(n[a+1]=h)}}knotToLeftKnotIndex(t){const e=this.degree-1;if(t<this.knots[e+1])return e;const r=this.knots.length-this.degree-1;if(t>=this.knots.length-this.degree)return this.knots[r];for(let i=e+1;i<r;i++)if(t<this.knots[i+1])return i;return r}spanIndexToLeftKnotIndex(t){const e=this.degree;return t<=0?e-1:Math.min(t+e-1,this.knots.length-e)}spanIndexToSpanLength(t){const e=this.spanIndexToLeftKnotIndex(t);return this.knots[e+1]-this.knots[e]}isIndexOfRealSpan(t){return t>=0&&t<this.knots.length-this.degree&&!i.Geometry.isSmallMetricDistance(this.spanIndexToSpanLength(t))}reflectKnots(){const t=this.leftKnot,e=this.rightKnot,r=this.knots.length;for(let i=0;i<r;i++)this.knots[i]=t+(e-this.knots[i]);this.knots.reverse()}copyKnots(t){const e=this.wrappable===s.OpenByAddingControlPoints&&this.testClosable(),r=this.leftKnotIndex,i=this.rightKnotIndex,n=this.leftKnot,o=this.rightKnot-n,a=this.degree,c=[];t&&(e?c.push(this.knots[i-a]-o):c.push(this.knots[0]));for(const s of this.knots)c.push(s);return t&&(e?c.push(this.knots[r+a]+o):c.push(c[c.length-1])),c}}e.KnotVector=KnotVector,KnotVector.knotTolerance=1e-9},"./lib/bspline/SurfaceLocationDetail.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Point2dVector2d.js");class UVSurfaceLocationDetail{constructor(t,e,r){this.surface=t,this.point=r||i.Point3d.createZero(),this.uv=e||n.Point2d.createZero(),this.a=0}static createSurfaceUVPoint(t,e,r){const i=new UVSurfaceLocationDetail(t);return e&&i.uv.setFrom(e),i.point.setFromPoint3d(r),i}}e.UVSurfaceLocationDetail=UVSurfaceLocationDetail;e.CurveAndSurfaceLocationDetail=class CurveAndSurfaceLocationDetail{constructor(t,e){this.curveDetail=t,this.surfaceDetail=e}}},"./lib/clipping/ClipPlane.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Range.js"),s=r("./lib/geometry3d/Transform.js"),o=r("./lib/geometry3d/Matrix3d.js"),a=r("./lib/geometry4d/Point4d.js"),c=r("./lib/geometry3d/Plane3dByOriginAndUnitNormal.js"),l=r("./lib/Geometry.js"),d=r("./lib/geometry3d/GrowableFloat64Array.js"),h=r("./lib/numerics/Polynomials.js"),u=r("./lib/clipping/ClipUtils.js"),f=r("./lib/geometry3d/GrowableXYZArray.js"),g=r("./lib/geometry3d/PolygonOps.js");class ClipPlane{constructor(t,e,r,i){this._invisible=r,this._interior=i,this._inwardNormal=t,this._distanceFromOrigin=e}safeSetXYZDistance(t,e,r,i){this._inwardNormal.set(t,e,r),this._distanceFromOrigin=i}isAlmostEqual(t){return l.Geometry.isSameCoordinate(this._distanceFromOrigin,t._distanceFromOrigin)&&this._inwardNormal.isAlmostEqual(t._inwardNormal)&&this._interior===t._interior&&this._invisible===t._invisible}clone(){return new ClipPlane(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior)}cloneNegated(){const t=new ClipPlane(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior);return t.negateInPlace(),t}static createPlane(t,e=!1,r=!1,i){const n=t.getNormalRef().dotProduct(t.getOriginRef());return i?(i._invisible=e,i._interior=r,i._inwardNormal=t.getNormalRef().clone(),i._distanceFromOrigin=n,i):new ClipPlane(t.getNormalRef().clone(),n,e,r)}static createNormalAndDistance(t,e,r=!1,i=!1,n){const s=t.normalize();if(s)return n&&(n._invisible=r,n._interior=i,n._inwardNormal=s,n._distanceFromOrigin=e),new ClipPlane(s,e,r,i)}static createNormalAndPoint(t,e,r=!1,i=!1,n){const s=t.normalize();if(s){const t=s.dotProduct(e);return n&&(n._invisible=r,n._interior=i,n._inwardNormal=s,n._distanceFromOrigin=t),new ClipPlane(s,t,r,i)}}static createNormalAndPointXYZXYZ(t,e,r,n,s,o,a=!1,c=!1,d){const h=l.Geometry.hypotenuseXYZ(t,e,r),u=l.Geometry.conditionalDivideFraction(1,h);if(void 0!==u){if(d)return d._inwardNormal.set(t*u,e*u,r*u),d._distanceFromOrigin=d._inwardNormal.dotProductXYZ(n,s,o),d._invisible=a,d._interior=c,d;const l=i.Vector3d.create(t*u,e*u,r*u);return new ClipPlane(l,l.dotProductXYZ(n,s,o),a,c)}}toJSON(){const t={};return t.normal=this.inwardNormalRef.toJSON(),t.dist=this.distance,this.interior&&(t.interior=!0),this.invisible&&(t.invisible=!0),t}static fromJSON(t,e){return t&&t.normal&&Number.isFinite(t.dist)?ClipPlane.createNormalAndDistance(i.Vector3d.fromJSON(t.normal),t.dist,!!t.invisible,!!t.interior):ClipPlane.createNormalAndDistance(i.Vector3d.unitZ(),0,!1,!1,e)}setFlags(t,e){this._invisible=t,this._interior=e}get distance(){return this._distanceFromOrigin}get inwardNormalRef(){return this._inwardNormal}get interior(){return this._interior}get invisible(){return this._invisible}static createEdgeAndUpVector(t,e,r,n,s){const o=i.Vector3d.createFrom(e.minus(t));let a=r.crossProduct(o).normalize();if(a){if(!n.isAlmostZero){const t=i.Vector3d.createRotateVectorAroundVector(a,o,n);t&&(a=t.clone())}return a.negate(a),ClipPlane.createNormalAndPoint(a,t,!1,!1,s)}}static createEdgeXY(t,e,r){const n=i.Vector3d.create(t.y-e.y,e.x-t.x);if(n.normalizeInPlace())return ClipPlane.createNormalAndPoint(n,t,!1,!1,r)}getPlane3d(){const t=this._distanceFromOrigin;return c.Plane3dByOriginAndUnitNormal.create(i.Point3d.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),this._inwardNormal)}getPlane4d(){return a.Point4d.create(this._inwardNormal.x,this._inwardNormal.y,this._inwardNormal.z,-this._distanceFromOrigin)}setPlane4d(t){const e=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z),r=0===e?1:1/e;this._inwardNormal.x=r*t.x,this._inwardNormal.y=r*t.y,this._inwardNormal.z=r*t.z,this._distanceFromOrigin=-r*t.w}evaluatePoint(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-this._distanceFromOrigin}weightedAltitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-t.w*this._distanceFromOrigin}altitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-this._distanceFromOrigin}altitudeXYZ(t,e,r){return t*this._inwardNormal.x+e*this._inwardNormal.y+r*this._inwardNormal.z-this._distanceFromOrigin}dotProductVector(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}velocity(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}velocityXYZ(t,e,r){return t*this._inwardNormal.x+e*this._inwardNormal.y+r*this._inwardNormal.z}dotProductPlaneNormalPoint(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}isPointOnOrInside(t,e=l.Geometry.smallMetricDistance){let r=this.altitude(t);return e&&(r+=e),r>=0}isPointInside(t,e=l.Geometry.smallMetricDistance){let r=this.altitude(t);return e&&(r-=e),r>0}isPointOn(t,e=l.Geometry.smallMetricDistance){return Math.abs(this.altitude(t))<=e}appendIntersectionRadians(t,e){const r=t.toVectors(),i=this.altitude(t.center),n=this.velocity(r.vector0),s=this.velocity(r.vector90);h.AnalyticRoots.appendImplicitLineUnitCircleIntersections(i,n,s,void 0,void 0,e)}announceClippedArcIntervals(t,e){const r=ClipPlane._clipArcFractionArray;return r.clear(),this.appendIntersectionRadians(t,r),t.sweep.radiansArraytoPositivePeriodicFractions(r),u.ClipUtilities.selectIntervals01(t,r,this,e)}getBoundedSegmentSimpleIntersection(t,e){const r=this.altitude(t),i=this.altitude(e);if(!(r*i>0)&&(0!==r||0!==i))return-r/(i-r)}transformInPlace(t){const e=this.getPlane3d(),r=t.matrix,i=t.multiplyPoint3d(e.getOriginRef()),n=r.multiplyInverseTranspose(e.getNormalRef());if(!n)return!1;e.set(i,n);const s=e.getNormalRef().normalize();return!!s&&(this._inwardNormal=s,this._distanceFromOrigin=this._inwardNormal.dotProduct(e.getOriginRef()),!0)}setInvisible(t){this._invisible=t}negateInPlace(){this._inwardNormal=this._inwardNormal.negate(),this._distanceFromOrigin=-this._distanceFromOrigin}offsetDistance(t){this._distanceFromOrigin+=t}convexPolygonClipInPlace(t,e,r=l.Geometry.smallMetricDistance){return g.Point3dArrayPolygonOps.convexPolygonClipInPlace(this,t,e,r)}clipConvexPolygonInPlace(t,e,r=!0,i=l.Geometry.smallMetricDistance){return g.IndexedXYZCollectionPolygonOps.clipConvexPolygonInPlace(this,t,e,r,i)}convexPolygonSplitInsideOutside(t,e,r,i){g.Point3dArrayPolygonOps.convexPolygonSplitInsideOutsidePlane(this,t,e,r,i)}convexPolygonSplitInsideOutsideGrowableArrays(t,e,r,i){g.IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(this,t,e,r,i)}multiplyPlaneByMatrix4d(t,e=!0,r=!0){const i=this.getPlane4d();if(e){const e=t.createInverse();return!!e&&this.multiplyPlaneByMatrix4d(e,!1,r)}return r?t.multiplyTransposePoint4d(i,i):t.multiplyPoint4d(i,i),this.setPlane4d(i),!0}polygonCrossings(t,e){return g.Point3dArrayPolygonOps.polygonPlaneCrossings(this,t,e)}announceClippedSegmentIntervals(t,e,r,i,n){if(e<t)return!1;const s=-this.altitude(r),o=-this.altitude(i)-s,a=l.Geometry.conditionalDivideFraction(-s,o);return void 0===a?s<=0&&(n&&n(t,e),!0):(o>0?a<e&&(e=a):a>t&&(t=a),!(e<t)&&(n&&n(t,e),!0))}getFrame(){const t=this._distanceFromOrigin,e=i.Point3d.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),r=o.Matrix3d.createRigidHeadsUp(this._inwardNormal,l.AxisOrder.ZXY);return s.Transform.createOriginAndMatrix(e,r)}intersectRange(t,e=!1){if(t.isNull)return;const r=t.corners(),i=this.getFrame();i.multiplyInversePoint3dArrayInPlace(r);const s=n.Range3d.createArray(r);if(s.low.z*s.high.z>0)return;const o=new f.GrowableXYZArray;return o.pushXYZ(s.low.x,s.low.y,0),o.pushXYZ(s.high.x,s.low.y,0),o.pushXYZ(s.high.x,s.high.y,0),o.pushXYZ(s.low.x,s.high.y,0),o.multiplyTransformInPlace(i),ClipPlane.intersectRangeConvexPolygonInPlace(t,o),0!==o.length?(e&&o.pushWrap(1),o):void 0}static intersectRangeConvexPolygonInPlace(t,e){if(t.isNull)return;const r=new f.GrowableXYZArray,i=ClipPlane.createNormalAndPointXYZXYZ(-1,0,0,t.high.x,t.high.y,t.high.z);return i.clipConvexPolygonInPlace(e,r),0!==e.length&&(i.safeSetXYZDistance(0,-1,0,-t.high.y),i.clipConvexPolygonInPlace(e,r),0!==e.length&&(i.safeSetXYZDistance(0,0,-1,-t.high.z),i.clipConvexPolygonInPlace(e,r),0!==e.length&&(i.safeSetXYZDistance(1,0,0,t.low.x),i.clipConvexPolygonInPlace(e,r),0!==e.length&&(i.safeSetXYZDistance(0,1,0,t.low.y),i.clipConvexPolygonInPlace(e,r),0!==e.length&&(i.safeSetXYZDistance(0,0,1,t.low.z),i.clipConvexPolygonInPlace(e,r),0!==e.length)))))?e:void 0}}e.ClipPlane=ClipPlane,ClipPlane._clipArcFractionArray=new d.GrowableFloat64Array},"./lib/clipping/ClipPrimitive.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/clipping/ClipPlane.js"),n=r("./lib/clipping/ConvexClipPlaneSet.js"),s=r("./lib/clipping/ClipUtils.js"),o=r("./lib/geometry3d/Point2dVector2d.js"),a=r("./lib/geometry3d/Point3dVector3d.js"),c=r("./lib/geometry3d/Transform.js"),l=r("./lib/Geometry.js"),d=r("./lib/geometry3d/PolygonOps.js"),h=r("./lib/clipping/UnionOfConvexClipPlaneSets.js"),u=r("./lib/topology/Triangulation.js"),f=r("./lib/topology/Graph.js");var g;!function(t){t[t.None=0]="None",t[t.XLow=1]="XLow",t[t.XHigh=2]="XHigh",t[t.YLow=4]="YLow",t[t.YHigh=8]="YHigh",t[t.ZLow=16]="ZLow",t[t.ZHigh=32]="ZHigh",t[t.XAndY=15]="XAndY",t[t.All=63]="All"}(g=e.ClipMaskXYZRangePlanes||(e.ClipMaskXYZRangePlanes={}));class ClipPrimitive{constructor(t,e=!1){this._clipPlanes=t,this._invisible=e}fetchClipPlanesRef(){return this.ensurePlaneSets(),this._clipPlanes}get invisible(){return this._invisible}static createCapture(t,e=!1){let r;return t instanceof h.UnionOfConvexClipPlaneSets&&(r=t),t instanceof n.ConvexClipPlaneSet&&(r=h.UnionOfConvexClipPlaneSets.createConvexSets([t])),new ClipPrimitive(r,e)}toJSON(){const t={};return this._clipPlanes&&(t.clips=this._clipPlanes.toJSON()),this._invisible&&(t.invisible=!0),{planes:t}}arePlanesDefined(){return void 0!==this._clipPlanes}clone(){const t=this._clipPlanes?this._clipPlanes.clone():void 0;return new ClipPrimitive(t,this._invisible)}ensurePlaneSets(){}pointInside(t,e=l.Geometry.smallMetricDistanceSquared){this.ensurePlaneSets();let r=!0;return this._clipPlanes&&(r=this._clipPlanes.isPointOnOrInside(t,e)),this._invisible&&(r=!r),r}multiplyPlanesByMatrix4d(t,e=!0,r=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,r)}return this._clipPlanes&&this._clipPlanes.multiplyPlanesByMatrix4d(t),!0}transformInPlace(t){return this._clipPlanes&&this._clipPlanes.transformInPlace(t),!0}setInvisible(t){this._invisible=t}containsZClip(){if(void 0!==this.fetchClipPlanesRef())for(const t of this._clipPlanes.convexSets)for(const e of t.planes)if(Math.abs(e.inwardNormalRef.z)>1e-6&&Math.abs(e.distance)!==Number.MAX_VALUE)return!0;return!1}classifyPointContainment(t,e){this.ensurePlaneSets();const r=this._clipPlanes;let i=s.ClipPlaneContainment.StronglyInside;if(r&&(i=r.classifyPointContainment(t,!1)),this._invisible&&!e)switch(i){case s.ClipPlaneContainment.StronglyInside:return s.ClipPlaneContainment.StronglyOutside;case s.ClipPlaneContainment.StronglyOutside:return s.ClipPlaneContainment.StronglyInside;case s.ClipPlaneContainment.Ambiguous:return s.ClipPlaneContainment.Ambiguous}return i}static fromJSON(t){const e=ClipShape.fromClipShapeJSON(t);if(e)return e;const r=ClipPrimitive.fromJSONClipPrimitive(t);return r||void 0}static fromJSONClipPrimitive(t){if(t&&t.planes){const e=t.planes,r=e.hasOwnProperty("clips")?h.UnionOfConvexClipPlaneSets.fromJSON(e.clips):void 0,i=!!e.hasOwnProperty("invisible")&&e.invisible;return new ClipPrimitive(r,i)}}}e.ClipPrimitive=ClipPrimitive;class PolyEdge{constructor(t,e,r,i){this.origin=a.Point3d.create(t.x,t.y,i),this.next=a.Point3d.create(e.x,e.y,i),this.normal=r}}class ClipShape extends ClipPrimitive{constructor(t=[],e,r,i,n=!1,s=!1){super(void 0,s),this._isMask=!1,this._polygon=t,this.initSecondaryProps(n,e,r,i)}get invisible(){return this._invisible}get transformFromClip(){return this._transformFromClip}get transformToClip(){return this._transformToClip}get transformValid(){return void 0!==this.transformFromClip}get zLowValid(){return void 0!==this._zLow}get zHighValid(){return void 0!==this._zHigh}get transformIsValid(){return void 0!==this._transformFromClip}get zLow(){return this._zLow}get zHigh(){return this._zHigh}get polygon(){return this._polygon}get isMask(){return this._isMask}setPolygon(t){t[0].isAlmostEqual(t[t.length-1])||t.push(t[0].clone()),this._polygon=t}ensurePlaneSets(){void 0===this._clipPlanes&&(this._clipPlanes=h.UnionOfConvexClipPlaneSets.createEmpty(),this.parseClipPlanes(this._clipPlanes),this._transformFromClip&&this._clipPlanes.transformInPlace(this._transformFromClip))}initSecondaryProps(t,e,r,i){this._isMask=t,this._zLow=e,this._zHigh=r,void 0!==i?(this._transformFromClip=i,this._transformToClip=i.inverse()):(this._transformFromClip=c.Transform.createIdentity(),this._transformToClip=c.Transform.createIdentity())}toJSON(){const t={shape:{}};t.shape.points=[];for(const e of this._polygon)t.shape.points.push(e.toJSON());return this.invisible&&(t.shape.invisible=!0),this._transformFromClip&&!this._transformFromClip.isIdentity&&(t.shape.trans=this._transformFromClip.toJSON()),this.isMask&&(t.shape.mask=!0),"undefined"!==typeof this.zLow&&this.zLow!==-Number.MAX_VALUE&&(t.shape.zlow=this.zLow),"undefined"!==typeof this.zHigh&&this.zHigh!==Number.MAX_VALUE&&(t.shape.zhigh=this.zHigh),t}static fromClipShapeJSON(t,e){if(!t.shape)return;const r=[];if(t.shape.points)for(const c of t.shape.points)r.push(a.Point3d.fromJSON(c));let i,n,s;t.shape.trans&&(i=c.Transform.fromJSON(t.shape.trans)),void 0!==t.shape.zlow&&(n=t.shape.zlow),void 0!==t.shape.zhigh&&(s=t.shape.zhigh);let o=!1;t.shape.mask&&(o=t.shape.mask);let l=!1;return t.shape.invisible&&(l=!0),ClipShape.createShape(r,n,s,i,o,l,e)}static createFrom(t,e){const r=ClipShape.createEmpty(!1,!1,void 0,e);r._invisible=t._invisible;for(const i of t._polygon)r._polygon.push(i.clone());return r._isMask=t._isMask,r._zLow=t._zLow,r._zHigh=t._zHigh,r._transformToClip=t._transformToClip?t._transformToClip.clone():void 0,r._transformFromClip=t._transformFromClip?t._transformFromClip.clone():void 0,r}static createShape(t=[],e,r,i,n=!1,s=!1,o){if(t.length<3)return;const a=t.slice(0);return a[0].isExactEqual(a[a.length-1])||a.push(a[0]),o?(o._clipPlanes=void 0,o._invisible=s,o._polygon=a,o.initSecondaryProps(n,e,r,i),o):new ClipShape(a,e,r,i,n,s)}static createBlock(t,e,r=!1,i=!1,n,s){const o=t.low,c=t.high,l=[];for(let d=0;d<5;d++)l.push(a.Point3d.create());return l[0].x=l[3].x=l[4].x=o.x,l[1].x=l[2].x=c.x,l[0].y=l[1].y=l[4].y=o.y,l[2].y=l[3].y=c.y,ClipShape.createShape(l,g.None!==(e&g.ZLow)?o.z:void 0,g.None!==(e&g.ZHigh)?c.z:void 0,n,r,i,s)}static createEmpty(t=!1,e=!1,r,i){return i?(i._clipPlanes=void 0,i._invisible=e,i._polygon.length=0,i.initSecondaryProps(t,void 0,void 0,r),i):new ClipShape([],void 0,void 0,r,t,e)}get isValidPolygon(){return!(this._polygon.length<3)&&!!this._polygon[0].isExactEqual(this._polygon[this._polygon.length-1])}clone(t){return ClipShape.createFrom(this,t)}parseClipPlanes(t){const e=this._polygon;if(3===e.length&&!this._isMask&&e[0].isExactEqual(e[e.length-1]))return this.parseLinearPlanes(t,this._polygon[0],this._polygon[1]),!0;const r=d.PolygonOps.testXYPolygonTurningDirections(e);return 0!==r?(this.parseConvexPolygonPlanes(t,this._polygon,r),!0):(this.parseConcavePolygonPlanes(t,this._polygon),!1)}parseLinearPlanes(t,e,r,s){const c=e.vectorTo(r);if(0===c.magnitude())return!1;c.normalize(c);const l=n.ConvexClipPlaneSet.createEmpty();if(void 0===s){const t=o.Vector2d.create(-c.y,c.x);l.planes.push(i.ClipPlane.createNormalAndPoint(a.Vector3d.create(c.x,c.y),a.Point3d.createFrom(e),this._invisible)),l.planes.push(i.ClipPlane.createNormalAndPoint(a.Vector3d.create(-c.x,-c.y),a.Point3d.createFrom(r),this._invisible)),l.planes.push(i.ClipPlane.createNormalAndPoint(a.Vector3d.create(t.x,t.y),a.Point3d.createFrom(e),this._invisible)),l.planes.push(i.ClipPlane.createNormalAndPoint(a.Vector3d.create(-t.x,-t.y),a.Point3d.createFrom(e),this._invisible))}else{const t=a.Point3d.create(e.x,e.y,-s),n=a.Point3d.create(r.x,r.y,-s),o=a.Vector3d.createFrom(n),c=o.crossProduct(a.Vector3d.createFrom(t)).normalize();let d=a.Vector3d.createFrom(t).crossProduct(c).normalize();l.planes.push(i.ClipPlane.createNormalAndDistance(c,0,this._invisible)),l.planes.push(i.ClipPlane.createNormalAndDistance(d,0,this._invisible)),c.negate(),d=o.crossProduct(c).normalize(),l.planes.push(i.ClipPlane.createNormalAndDistance(c,0,this._invisible)),l.planes.push(i.ClipPlane.createNormalAndDistance(d,0,this._invisible))}return l.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(l),!0}parseConvexPolygonPlanes(t,e,r,s){const c=[],l=r<0!==this._isMask;for(let i=0;i<e.length-1;i++){const t=void 0===s?0:-s,r=o.Vector2d.createFrom(e[i+1].minus(e[i])),n=r.magnitude();if(r.normalize(r),n>1e-8){const n=o.Vector2d.create(l?r.y:-r.y,l?-r.x:r.x);c.push(new PolyEdge(e[i],e[i+1],n,t))}}if(c.length<3)return!1;if(this._isMask){const e=c.length-1;for(let r=0;r<=e;r++){const s=c[r],o=c[r?r-1:e],l=c[r===e?0:r+1],d=n.ConvexClipPlaneSet.createEmpty(),h=s.normal.minus(o.normal),u=s.normal.minus(l.normal);h.normalize(h),u.normalize(u),d.planes.push(i.ClipPlane.createNormalAndPoint(a.Vector3d.create(h.x,h.y),s.origin,this._invisible,!0)),d.planes.push(i.ClipPlane.createNormalAndPoint(a.Vector3d.create(s.normal.x,s.normal.y),s.origin,this._invisible,!1)),d.planes.push(i.ClipPlane.createNormalAndPoint(a.Vector3d.create(u.x,u.y),l.origin,this._invisible,!0)),d.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(d)}t.addOutsideZClipSets(this._invisible,this._zLow,this._zHigh)}else{const e=n.ConvexClipPlaneSet.createEmpty();if(void 0===s)for(const t of c)e.planes.push(i.ClipPlane.createNormalAndPoint(a.Vector3d.create(t.normal.x,t.normal.y),t.origin));else if(l)for(const t of c)e.planes.push(i.ClipPlane.createNormalAndDistance(a.Vector3d.createFrom(t.origin).crossProduct(a.Vector3d.createFrom(t.next)).normalize(),0));else for(const t of c)e.planes.push(i.ClipPlane.createNormalAndDistance(a.Vector3d.createFrom(t.next).crossProduct(a.Vector3d.createFrom(t.origin)).normalize(),0));e.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(e)}return!0}parseConcavePolygonPlanes(t,e,r){const i=u.Triangulator.createTriangulatedGraphFromSingleLoop(e);return u.Triangulator.flipTriangles(i),i.announceFaceLoops((e,i)=>{if(!i.isMaskSet(f.HalfEdgeMask.EXTERIOR)){const e=i.collectAroundFace(t=>{if(!t.isMaskSet(f.HalfEdgeMask.EXTERIOR))return a.Point3d.create(t.x,t.y,0)});e.push(e[0]);const n=d.PolygonOps.testXYPolygonTurningDirections(e);this.parseConvexPolygonPlanes(t,e,n,r)}return!0}),!0}multiplyPlanesByMatrix4d(t,e=!0,r=!0){return this.ensurePlaneSets(),super.multiplyPlanesByMatrix4d(t,e,r)}transformInPlace(t){return!!t.isIdentity||(super.transformInPlace(t),this._transformFromClip?t.multiplyTransformTransform(this._transformFromClip,this._transformFromClip):this._transformFromClip=t.clone(),this._transformToClip=this._transformFromClip.inverse(),!0)}get isXYPolygon(){if(0===this._polygon.length)return!1;if(void 0===this._transformFromClip)return!0;return this._transformFromClip.matrix.columnZ().magnitudeXY()<1e-8}performTransformToClip(t){void 0!==this._transformToClip&&this._transformToClip.multiplyPoint3d(t)}performTransformFromClip(t){void 0!==this._transformFromClip&&this._transformFromClip.multiplyPoint3d(t)}}e.ClipShape=ClipShape},"./lib/clipping/ClipUtils.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Range.js"),s=r("./lib/geometry3d/GrowableXYZArray.js"),o=r("./lib/clipping/UnionOfConvexClipPlaneSets.js"),a=r("./lib/clipping/ClipPrimitive.js"),c=r("./lib/clipping/ConvexClipPlaneSet.js"),l=r("./lib/curve/Loop.js"),d=r("./lib/curve/LineString3d.js"),h=r("./lib/clipping/ClipVector.js");var u;!function(t){t[t.StronglyInside=1]="StronglyInside",t[t.Ambiguous=2]="Ambiguous",t[t.StronglyOutside=3]="StronglyOutside"}(e.ClipPlaneContainment||(e.ClipPlaneContainment={})),function(t){t[t.ClipRequired=0]="ClipRequired",t[t.TrivialReject=1]="TrivialReject",t[t.TrivialAccept=2]="TrivialAccept"}(u=e.ClipStatus||(e.ClipStatus={}));class ClipUtilities{static selectIntervals01(t,e,r,i){e.push(0),e.push(1),e.sort();let n,s,o=e.atUncheckedIndex(0);const a=ClipUtilities._selectIntervals01TestPoint,c=e.length;for(let l=1;l<c;l++,o=n)if(s=.5*(o+(n=e.atUncheckedIndex(l))),n>o&&s>=0&&s<=1&&(t.fractionToPoint(s,a),r.isPointOnOrInside(a))){if(!i)return!0;i(o,n,t)}return!1}static announceNNC(t,e,r){if(r)for(const i of t)r(i.low,i.high,e);return t.length>0}static collectClippedCurves(t,e){const r=[];return t.announceClipIntervals(e,(t,e,i)=>{if(e!==t){const n=i.clonePartialCurve(t,e);n&&r.push(n)}}),r}static clipPolygonToClipShape(t,e){const r=this.clipPolygonToClipShapeReturnGrowableXYZArrays(t,e),i=[];for(const n of r)i.push(n.getPoint3dArray());return i}static clipPolygonToClipShapeReturnGrowableXYZArrays(t,e){const r=[],i=e.fetchClipPlanesRef();return i&&i.polygonClip(t,r),r}static pointSetSingleClipStatus(t,e,r){if(0===e.convexSets.length)return u.TrivialAccept;for(const n of e.convexSets){let e=!1,s=!1;for(const o of n.planes){let n=0,a=0;const c=o.distance-r,l=i.Point3d.create(),d=i.Vector3d.create();for(let e=0;e<t.length;e++)t.getPoint3dAtUncheckedPointIndex(e,l),d.setFrom(l),d.dotProduct(o.inwardNormalRef)>c?n++:a++;if(s=0!==a||s,0===n){e=!0;break}}if(!s)return u.TrivialAccept;if(!e)return u.ClipRequired}return u.TrivialReject}static announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,r,i=!0,o=!0,a=!1){const c=new s.GrowableXYZArray;if(i)for(const n of t.planes){if(a&&n.invisible)continue;const i=n.intersectRange(e,!0),o=new s.GrowableXYZArray;i&&(t.polygonClip(i,o,c,n),o.length>0&&r(o))}if(o){const i=e.corners();for(let e=0;e<6;e++){const o=n.Range3d.faceCornerIndices(e),a=new s.GrowableXYZArray,l=d.LineString3d.createIndexedPoints(i,o);t.polygonClip(l.packedPoints,a,c),a.length>0&&r(a)}}}static loopsOfConvexClipPlaneIntersectionWithRange(t,e,r=!0,i=!0,n=!1){const s=[];return this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,t=>{t.length>0&&s.push(l.Loop.createPolygon(t))},r,i,n),s}static rangeOfConvexClipPlaneSetIntersectionWithRange(t,e){const r=n.Range3d.createNull();return this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,t=>{t.length>0&&r.extendArray(t)},!0,!0,!1),r}static rangeOfClipperIntersectionWithRange(t,e,r=!0){if(void 0===t)return e.clone();if(t instanceof c.ConvexClipPlaneSet)return this.rangeOfConvexClipPlaneSetIntersectionWithRange(t,e);if(t instanceof o.UnionOfConvexClipPlaneSets){const r=n.Range3d.createNull();for(const i of t.convexSets){const t=this.rangeOfConvexClipPlaneSetIntersectionWithRange(i,e);r.extendRange(t)}return r}if(t instanceof a.ClipPrimitive)return r&&t.invisible?e.clone():this.rangeOfClipperIntersectionWithRange(t.fetchClipPlanesRef(),e);if(t instanceof h.ClipVector){const i=e.clone();for(const n of t.clips)if(r&&n.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(n,e,r);i.intersect(t,i)}return i}return e.clone()}static doesClipperIntersectRange(t,e,r=!0){if(void 0===t)return!0;if(t instanceof c.ConvexClipPlaneSet)return this.doesConvexClipPlaneSetIntersectRange(t,e);if(t instanceof o.UnionOfConvexClipPlaneSets){for(const r of t.convexSets)if(this.doesConvexClipPlaneSetIntersectRange(r,e))return!0;return!1}if(t instanceof a.ClipPrimitive)return!(!r||!t.invisible)||this.doesClipperIntersectRange(t.fetchClipPlanesRef(),e);if(t instanceof h.ClipVector){const i=e.clone();for(const n of t.clips)if(r&&n.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(n,e,r);i.intersect(t,i)}return!i.isNull}return!1}static doesConvexClipPlaneSetIntersectRange(t,e,r=!0,i=!0,o=!1){const a=new s.GrowableXYZArray;if(r)for(const n of t.planes){if(o&&n.invisible)continue;const r=n.intersectRange(e,!0);if(r){const e=new s.GrowableXYZArray;if(t.polygonClip(r,e,a,n),e.length>0)return!0}}if(i){const r=e.corners();for(let e=0;e<6;e++){const i=n.Range3d.faceCornerIndices(e),o=new s.GrowableXYZArray,c=d.LineString3d.createIndexedPoints(r,i);if(t.polygonClip(c.packedPoints,o,a),o.length>0)return!0}}return!1}}e.ClipUtilities=ClipUtilities,ClipUtilities._selectIntervals01TestPoint=i.Point3d.create()},"./lib/clipping/ClipVector.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/clipping/ClipPrimitive.js"),n=r("./lib/clipping/ClipUtils.js"),s=r("./lib/geometry3d/Range.js"),o=r("./lib/geometry3d/Transform.js"),a=r("./lib/Geometry.js"),c=r("./lib/curve/LineSegment3d.js");class ClipVector{constructor(t){this.boundingRange=s.Range3d.createNull(),this._clips=t||[]}get clips(){return this._clips}get isValid(){return this._clips.length>0}static createEmpty(t){return t?(t._clips.length=0,t):new ClipVector}static createCapture(t,e){return e?(e._clips=t,e):new ClipVector(t)}static create(t,e){const r=[];for(const i of t)r.push(i.clone());return ClipVector.createCapture(r,e)}clone(t){const e=t||new ClipVector;e._clips.length=0;for(const r of this._clips)e._clips.push(r.clone());return e.boundingRange.setFrom(this.boundingRange),e}toJSON(){if(!this.isValid)return[];const t=[];for(const e of this.clips)t.push(e.toJSON());return t}static fromJSON(t,e){(e=e||new ClipVector).clear();try{for(const r of t){const t=i.ClipPrimitive.fromJSON(r);t&&e._clips.push(t)}}catch(t){e.clear()}return e}clear(){this._clips.length=0}appendClone(t){this._clips.push(t.clone())}appendReference(t){this._clips.push(t)}appendShape(t,e,r,n,s=!1,o=!1){const a=i.ClipShape.createShape(t,e,r,n,s,o);return!!a&&(this._clips.push(a),!0)}pointInside(t,e=a.Geometry.smallMetricDistanceSquared){if(!this.boundingRange.isNull&&!this.boundingRange.containsPoint(t))return!1;for(const r of this._clips)if(!r.pointInside(t,e))return!1;return!0}transformInPlace(t){for(const e of this._clips)if(!1===e.transformInPlace(t))return!1;return this.boundingRange.isNull||t.multiplyRange(this.boundingRange,this.boundingRange),!0}extractBoundaryLoops(t,e){let r=i.ClipMaskXYZRangePlanes.None,n=-Number.MAX_VALUE,s=Number.MAX_VALUE;const a=[];let c,l=0;if(0===this._clips.length)return a;const d=o.Transform.createIdentity();for(const h of this._clips)if(h instanceof i.ClipShape){if(void 0!==c&&h!==c){let t=o.Transform.createIdentity(),e=o.Transform.createIdentity();c.transformValid&&h.transformValid&&(t=h.transformFromClip.clone(),e=c.transformToClip.clone()),d.setFrom(e.multiplyTransformTransform(t))}if(c||(c=h),t[l]=[],void 0!==h.polygon){r=i.ClipMaskXYZRangePlanes.XAndY,h.zHighValid&&(r|=i.ClipMaskXYZRangePlanes.ZHigh,s=h.zHigh),h.zLowValid&&(r|=i.ClipMaskXYZRangePlanes.ZLow,n=h.zLow);for(const e of h.polygon)t[l].push(e.clone());d.multiplyPoint3dArray(t[l],t[l]),l++}}return a.push(r),a.push(n),a.push(s),e&&c&&e.setFrom(c.transformFromClip),a}setInvisible(t){for(const e of this._clips)e.setInvisible(t)}parseClipPlanes(){for(const t of this._clips)t.fetchClipPlanesRef()}multiplyPlanesByMatrix4d(t,e=!0,r=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,r)}for(const i of this._clips)i.multiplyPlanesByMatrix4d(t,!1,r);return!0}classifyPointContainment(t,e=!1){let r=n.ClipPlaneContainment.Ambiguous;for(const i of this._clips){const s=i.classifyPointContainment(t,e);if(n.ClipPlaneContainment.Ambiguous===s)return n.ClipPlaneContainment.Ambiguous;if(n.ClipPlaneContainment.Ambiguous===r)r=s;else if(r!==s)return n.ClipPlaneContainment.Ambiguous}return r}classifyRangeContainment(t,e){const r=t.corners();return this.classifyPointContainment(r,e)}isAnyLineStringPointInside(t){for(const e of this._clips){const r=e.fetchClipPlanesRef();if(void 0!==r)for(let e=0;e+1<t.length;e++){const i=c.LineSegment3d.create(t[e],t[e+1]);if(r.isAnyPointInOrOnFromSegment(i))return!0}}return!1}sumSizes(t,e,r){let i=0;for(let n=e;n<r;n++)i+=t[n].x1-t[n].x0;return i}isLineStringCompletelyContained(t){const e=[];for(let r=0;r+1<t.length;r++){const i=c.LineSegment3d.create(t[r],t[r+1]);let n=0,s=0;for(const t of this._clips){const r=t.fetchClipPlanesRef();if(void 0!==r){r.appendIntervalsFromSegment(i,e);const t=e.length;if(n+=this.sumSizes(e,s,t),s=t,n>=ClipVector._TARGET_FRACTION_SUM)break}}if(n<ClipVector._TARGET_FRACTION_SUM)return!1}return!0}}e.ClipVector=ClipVector,ClipVector._TARGET_FRACTION_SUM=.99999999},"./lib/clipping/ConvexClipPlaneSet.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Matrix3d.js"),s=r("./lib/Geometry.js"),o=r("./lib/geometry3d/PolygonOps.js"),a=r("./lib/geometry3d/GrowableFloat64Array.js"),c=r("./lib/clipping/ClipPlane.js"),l=r("./lib/clipping/ClipUtils.js"),d=r("./lib/geometry3d/GrowableXYZArray.js");class ConvexClipPlaneSet{constructor(t){this._planes=t||[]}toJSON(){const t=[];for(const e of this._planes)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new ConvexClipPlaneSet)._planes.length=0,!Array.isArray(t))return e;for(const r of t){const t=c.ClipPlane.fromJSON(r);t&&e._planes.push(t)}return e}isAlmostEqual(t){if(this._planes.length!==t._planes.length)return!1;for(let e=0;e<this._planes.length;e++)if(!this._planes[e].isAlmostEqual(t._planes[e]))return!1;return!0}static createPlanes(t,e){e=e||new ConvexClipPlaneSet;for(const r of t)e._planes.push(r);return e}static createRange3dPlanes(t,e=!0,r=!0,i=!0,n=!0,s=!0,o=!0){const a=ConvexClipPlaneSet.createEmpty();return e&&a.planes.push(c.ClipPlane.createNormalAndPointXYZXYZ(1,0,0,t.low.x,0,0)),r&&a.planes.push(c.ClipPlane.createNormalAndPointXYZXYZ(-1,0,0,t.high.x,0,0)),i&&a.planes.push(c.ClipPlane.createNormalAndPointXYZXYZ(0,1,0,0,t.low.y,0)),n&&a.planes.push(c.ClipPlane.createNormalAndPointXYZXYZ(0,-1,0,0,t.high.y,0)),s&&a.planes.push(c.ClipPlane.createNormalAndPointXYZXYZ(0,0,1,0,0,t.low.z)),o&&a.planes.push(c.ClipPlane.createNormalAndPointXYZXYZ(0,0,-1,0,0,t.high.z)),a}static createEmpty(t){return t?(t._planes.length=0,t):new ConvexClipPlaneSet}negateAllPlanes(){for(const t of this._planes)t.negateInPlace()}static createXYBox(t,e,r,n,s){(s=s||new ConvexClipPlaneSet)._planes.length=0;const o=c.ClipPlane.createNormalAndDistance(i.Vector3d.create(-1,0,0),-r,!1,!0),a=c.ClipPlane.createNormalAndDistance(i.Vector3d.create(1,0,0),t,!1,!0),l=c.ClipPlane.createNormalAndDistance(i.Vector3d.create(0,-1,0),-n,!1,!0),d=c.ClipPlane.createNormalAndDistance(i.Vector3d.create(0,1,0),e,!1,!0);return o&&a&&l&&d&&s._planes.push(o,a,l,d),s}static createXYPolyLine(t,e,r,n){(n=n||new ConvexClipPlaneSet)._planes.length=0;for(let s=0;s+1<t.length;s++){const o=i.Vector3d.createStartEnd(t[s],t[s+1]).unitPerpendicularXY();if(o.z=0,r||o.negate(),o.normalize()){const r=c.ClipPlane.createNormalAndPoint(o,t[s],e[s],e[s]);r&&n._planes.push(r)}}return n}static createXYPolyLineInsideLeft(t,e){(e=e||new ConvexClipPlaneSet)._planes.length=0;for(let r=0;r+1<t.length;r++){const n=i.Vector3d.createStartEnd(t[r],t[r+1]).unitPerpendicularXY();if(n.z=0,n.normalize()){const i=c.ClipPlane.createNormalAndPoint(n,t[r],!1,!1);i&&e._planes.push(i)}}return e}static setPlaneAndXYLoopCCW(t,e,r){let i=t.length-1;const n=t.length;let s,o,a,l,d=t.getXAtUncheckedPointIndex(i),h=t.getYAtUncheckedPointIndex(i);r._planes.length=0;const u=t.getZAtUncheckedPointIndex(i),f=t.crossProductIndexIndexIndex(0,2,1);if(c.ClipPlane.createNormalAndPointXYZXYZ(f.x,f.y,f.z,d,h,u,!1,!1,e),f.normalizeInPlace())for(let g=0;g<n;i=g,g++,d=s,h=o){s=t.getXAtUncheckedPointIndex(g),a=-((o=t.getYAtUncheckedPointIndex(g))-h),l=s-d;const e=c.ClipPlane.createNormalAndPointXYZXYZ(a,l,0,s,o,u);e&&r._planes.push(e)}}clone(t){(t=t||new ConvexClipPlaneSet)._planes.length=0;for(const e of this._planes)t._planes.push(e.clone());return t}get planes(){return this._planes}hasIntersectionWithRay(t,e){let r=-s.Geometry.hugeCoordinate,i=s.Geometry.hugeCoordinate;e&&e.setNull();for(const n of this._planes){const e=n.velocity(t.direction),s=n.altitude(t.origin);if(0===e){if(s<0)return!1}else{const t=-s/e;e<0?t<i&&(i=t):t>r&&(r=t)}}return!(i<r)&&(e&&(e.extendX(r),e.extendX(i)),!0)}multiplyPlanesByMatrix4d(t,e=!0,r=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,r)}for(const i of this._planes)i.multiplyPlaneByMatrix4d(t,!1,r);return!0}isPointInside(t){for(const e of this._planes)if(!e.isPointInside(t))return!1;return!0}isPointOnOrInside(t,e){const r=Math.abs(e);for(const i of this._planes)if(!i.isPointOnOrInside(t,i.interior?r:e))return!1;return!0}isSphereInside(t,e){const r=Math.abs(e)+s.Geometry.smallMetricDistance;for(const i of this._planes)if(!i.isPointOnOrInside(t,r))return!1;return!0}announceClippedSegmentIntervals(t,e,r,i,n){let o;if(e<t)return!1;for(const a of this._planes){const n=-a.altitude(r),c=-a.altitude(i);if(void 0===(o=s.Geometry.safeDivideFraction(-n,c-n,0))){if(n>0)return!1}else if(c>n){if(o<t)return!1;o<e&&(e=o)}else if(n>c){if(o>e)return!1;o>t&&(t=o)}else if(n>0)return!1}return e>=t&&(n&&n(t,e),!0)}announceClippedArcIntervals(t,e){const r=ConvexClipPlaneSet._clipArcFractionArray;r.clear();for(const i of this.planes)i.appendIntersectionRadians(t,r);return t.sweep.radiansArraytoPositivePeriodicFractions(r),l.ClipUtilities.selectIntervals01(t,r,this,e)}clipUnboundedSegment(t,e,r){return this.announceClippedSegmentIntervals(-Number.MAX_VALUE,Number.MAX_VALUE,t,e,r)}transformInPlace(t){for(const e of this._planes)e.transformInPlace(t)}clipConvexPolygonInPlace(t,e,r=s.Geometry.smallMetricDistance){for(const i of this._planes)if(i.clipConvexPolygonInPlace(t,e,!0,r),t.length<3)return}classifyPointContainment(t,e){let r=!0;const i=e?1e-8:-1e-8;for(const n of this._planes){let e=0;for(const s of t)n.altitude(s)<(n.interior?1e-8:i)&&(e++,r=!1);if(e===t.length)return l.ClipPlaneContainment.StronglyOutside}return r?l.ClipPlaneContainment.StronglyInside:l.ClipPlaneContainment.Ambiguous}static createSweptPolyline(t,e,r){const i=ConvexClipPlaneSet.createEmpty();let n=!1;if(t.length>3&&t[0].isAlmostEqual(t[t.length-1])){o.PolygonOps.areaNormal(t).dotProduct(e)>0&&(n=!0)}for(let s=0;s+1<t.length;s++)if(n){const n=c.ClipPlane.createEdgeAndUpVector(t[s+1],t[s],e,r);if(!n)return;i.addPlaneToConvexSet(n)}else{const n=c.ClipPlane.createEdgeAndUpVector(t[s],t[s+1],e,r);if(!n)return;i.addPlaneToConvexSet(n)}return i}addPlaneToConvexSet(t){t&&this._planes.push(t)}clipPointsOnOrInside(t,e,r){e.length=0,r.length=0;for(const i of t)this.isPointOnOrInside(i,0)?e.push(i):r.push(i)}polygonClip(t,e,r,i){t instanceof d.GrowableXYZArray?t.clone(e):d.GrowableXYZArray.create(t,e);for(const n of this._planes)if(i!==n){if(0===e.length)break;n.clipConvexPolygonInPlace(e,r)}}reloadSweptPolygon(t,e,r){this._planes.length=0;const n=t.length;if(n<=2)return 0;const s=o.PolygonOps.areaNormal(t),a=e.dotProduct(s)>0,l=a?1:n-1;for(let o=0;o<n;o++){const r=(o+l)%n,s=t[o],a=t[r];if(s.isAlmostEqual(a))continue;const d=i.Vector3d.createStartEnd(s,a),h=i.Vector3d.createCrossProduct(e.x,e.y,e.z,d.x,d.y,d.z).normalize();let u;if(h){u=h.dotProduct(s);const t=c.ClipPlane.createNormalAndDistance(h,u,!1,!1);t&&this._planes.push(t)}}if(0!==r){let i=s.normalize();if(i){e.dotProduct(i)*r<0&&(i=i.negate());const n=t[0],s=i.dotProduct(n),o=c.ClipPlane.createNormalAndDistance(i,s,!1,!1);o&&this._planes.push(o)}}return a?1:-1}computePlanePlanePlaneIntersections(t,e,r,i=!0){const o=n.Matrix3d.createIdentity(),a=this._planes,c=a.length;let l=0;for(let d=0;d<c;d++)for(let h=d+1;h<c;h++)for(let u=h+1;u<c;u++)if(n.Matrix3d.createRowValues(a[d].inwardNormalRef.x,a[d].inwardNormalRef.y,a[d].inwardNormalRef.z,a[h].inwardNormalRef.x,a[h].inwardNormalRef.y,a[h].inwardNormalRef.z,a[u].inwardNormalRef.x,a[u].inwardNormalRef.y,a[u].inwardNormalRef.z,o),o.computeCachedInverse(!1)){const n=o.multiplyInverseXYZAsPoint3d(a[d].distance,a[h].distance,a[u].distance);i&&!this.isPointOnOrInside(n,s.Geometry.smallMetricDistance)||(l++,r&&r.multiplyPoint3d(n,n),t&&t.push(n),e&&e.extendPoint(n))}return l}setInvisible(t){for(const e of this._planes)e.setInvisible(t)}addZClipPlanes(t,e,r){void 0!==e&&this._planes.push(c.ClipPlane.createNormalAndDistance(i.Vector3d.create(0,0,1),e,t)),void 0!==r&&this._planes.push(c.ClipPlane.createNormalAndDistance(i.Vector3d.create(0,0,-1),-r,t))}}e.ConvexClipPlaneSet=ConvexClipPlaneSet,ConvexClipPlaneSet.hugeVal=1e37,ConvexClipPlaneSet._clipArcFractionArray=new a.GrowableFloat64Array},"./lib/clipping/UnionOfConvexClipPlaneSets.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Segment1d.js"),n=r("./lib/geometry3d/Range.js"),s=r("./lib/geometry3d/GrowableFloat64Array.js"),o=r("./lib/clipping/ClipUtils.js"),a=r("./lib/clipping/ConvexClipPlaneSet.js"),c=r("./lib/Geometry.js"),l=r("./lib/geometry3d/GrowableXYZArray.js");class UnionOfConvexClipPlaneSets{constructor(){this._convexSets=[]}get convexSets(){return this._convexSets}toJSON(){const t=[];for(const e of this._convexSets)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new UnionOfConvexClipPlaneSets)._convexSets.length=0,!Array.isArray(t))return e;for(const r of t)e._convexSets.push(a.ConvexClipPlaneSet.fromJSON(r));return e}static createEmpty(t){return t?(t._convexSets.length=0,t):new UnionOfConvexClipPlaneSets}isAlmostEqual(t){if(this._convexSets.length!==t._convexSets.length)return!1;for(let e=0;e<this._convexSets.length;e++)if(!this._convexSets[e].isAlmostEqual(t._convexSets[e]))return!1;return!0}static createConvexSets(t,e){e=e||new UnionOfConvexClipPlaneSets;for(const r of t)e._convexSets.push(r);return e}clone(t){(t=t||new UnionOfConvexClipPlaneSets)._convexSets.length=0;for(const e of this._convexSets)t._convexSets.push(e.clone());return t}addConvexSet(t){this._convexSets.push(t)}hasIntersectionWithRay(t,e){if(void 0===e){for(const e of this._convexSets)if(e.hasIntersectionWithRay(t))return!0;return!1}e.setNull();const r=n.Range1d.createNull();for(const i of this._convexSets)i.hasIntersectionWithRay(t,r)&&e.extendRange(r);return!e.isNull}isPointInside(t){for(const e of this._convexSets)if(e.isPointInside(t))return!0;return!1}isPointOnOrInside(t,e=c.Geometry.smallMetricDistance){for(const r of this._convexSets)if(r.isPointOnOrInside(t,e))return!0;return!1}isSphereInside(t,e){for(const r of this._convexSets)if(r.isSphereInside(t,e))return!0;return!1}isAnyPointInOrOnFromSegment(t){for(const e of this._convexSets)if(e.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref))return!0;return!1}appendIntervalsFromSegment(t,e){for(const r of this._convexSets)r.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref,(t,r)=>e.push(i.Segment1d.create(t,r)))}transformInPlace(t){for(const e of this._convexSets)e.transformInPlace(t)}classifyPointContainment(t,e){for(const r of this._convexSets){const i=r.classifyPointContainment(t,e);if(i!==o.ClipPlaneContainment.StronglyOutside)return i}return o.ClipPlaneContainment.StronglyOutside}polygonClip(t,e){e.length=0,Array.isArray(t)&&(t=l.GrowableXYZArray.create(t));const r=new l.GrowableXYZArray;for(const i of this._convexSets){const n=new l.GrowableXYZArray;i.polygonClip(t,n,r),0!==n.length&&e.push(n)}}announceClippedSegmentIntervals(t,e,r,i,n){let s=0;for(const o of this._convexSets)o.announceClippedSegmentIntervals(t,e,r,i,n)&&s++;return s>0}announceClippedArcIntervals(t,e){const r=UnionOfConvexClipPlaneSets._clipArcFractionArray;r.clear();for(const i of this._convexSets)for(const e of i.planes)e.appendIntersectionRadians(t,r);return t.sweep.radiansArraytoPositivePeriodicFractions(r),o.ClipUtilities.selectIntervals01(t,r,this,e)}computePlanePlanePlaneIntersectionsInAllConvexSets(t,e,r,i=!0){let n=0;for(const s of this._convexSets)n+=s.computePlanePlanePlaneIntersections(t,e,r,i);return n}multiplyPlanesByMatrix4d(t,e=!0,r=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,r)}for(const i of this._convexSets)i.multiplyPlanesByMatrix4d(t,!1,r);return!0}setInvisible(t){for(const e of this._convexSets)e.setInvisible(t)}addOutsideZClipSets(t,e,r){if(e){const r=a.ConvexClipPlaneSet.createEmpty();r.addZClipPlanes(t,e),this._convexSets.push(r)}if(r){const e=a.ConvexClipPlaneSet.createEmpty();e.addZClipPlanes(t,void 0,r),this._convexSets.push(e)}}}e.UnionOfConvexClipPlaneSets=UnionOfConvexClipPlaneSets,UnionOfConvexClipPlaneSets._clipArcFractionArray=new s.GrowableFloat64Array},"./lib/curve/Arc3d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/AngleSweep.js"),s=r("./lib/geometry3d/Angle.js"),o=r("./lib/numerics/Polynomials.js"),a=r("./lib/geometry3d/Point3dVector3d.js"),c=r("./lib/geometry3d/Matrix3d.js"),l=r("./lib/geometry3d/Ray3d.js"),d=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),h=r("./lib/curve/CurvePrimitive.js"),u=r("./lib/curve/CurveExtendMode.js"),f=r("./lib/curve/CurveLocationDetail.js"),g=r("./lib/curve/StrokeOptions.js"),p=r("./lib/curve/LineString3d.js");class Arc3d extends h.CurvePrimitive{constructor(t,e,r){super(),this.curvePrimitiveType="arc",this._center=t,this._matrix=e,this._sweep=r}isSameGeometryClass(t){return t instanceof Arc3d}get center(){return this._center.clone()}get vector0(){return this._matrix.columnX()}get vector90(){return this._matrix.columnY()}get perpendicularVector(){return this._matrix.columnZ()}get matrix(){return this._matrix.clone()}get matrixRef(){return this._matrix}get sweep(){return this._sweep}set sweep(t){this._sweep.setFrom(t)}get isExtensibleFractionSpace(){return!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}setRefs(t,e,r){this._center=t,this._matrix=e,this._sweep=r}set(t,e,r){this.setRefs(t.clone(),e.clone(),r?r.clone():n.AngleSweep.create360())}setFrom(t){this._center.setFrom(t._center),this._matrix.setFrom(t._matrix),this._sweep.setFrom(t._sweep)}clone(){return new Arc3d(this._center.clone(),this._matrix.clone(),this._sweep.clone())}static createRefs(t,e,r,i){return i?(i.setRefs(t,e,r),i):new Arc3d(t,e,r)}static createScaledXYColumns(t,e,r,i,n,s){const o=e.columnX(),a=e.columnY();return Arc3d.create(t,o.scale(r,o),a.scale(i,a),n,s)}static createCenterNormalRadius(t,e,r,n){const s=c.Matrix3d.createRigidHeadsUp(e,i.AxisOrder.ZYX);return Arc3d.createScaledXYColumns(t,s,r,r,void 0,n)}static create(t,e,r,i,s){const o=e.unitCrossProductWithDefault(r,0,0,0),a=c.Matrix3d.createColumns(e,r,o);return Arc3d.createRefs(t.clone(),a,i?i.clone():n.AngleSweep.create360(),s)}cloneAtZ(t){return void 0===t&&(t=this._center.z),Arc3d.createXYZXYZXYZ(this._center.x,this._center.y,this._center.z,this._matrix.coffs[0],this._matrix.coffs[3],t,this._matrix.coffs[1],this._matrix.coffs[4],t,this._sweep)}static createXYZXYZXYZ(t,e,r,i,n,s,o,c,l,d,h){return Arc3d.create(a.Point3d.create(t,e,r),a.Vector3d.create(i,n,s),a.Vector3d.create(o,c,l),d,h)}quickEccentricity(){const t=this._matrix.columnXMagnitude(),e=this._matrix.columnYMagnitude(),r=this._matrix.columnXYCrossProductMagnitude(),n=i.Geometry.maxXY(t,e);return r/(n*n)}static createCircularStartMiddleEnd(t,e,r,i){const c=a.Vector3d.createStartEnd(t,e),l=a.Vector3d.createStartEnd(t,r),d=c.magnitude(),h=l.magnitude(),u=c.sizedCrossProduct(l,Math.sqrt(d*h));if(u){const e=o.SmallSystem.linearSystem3d(u.x,u.y,u.z,c.x,c.y,c.z,l.x,l.y,l.z,0,.5*d*d,.5*h*h);if(e){const o=a.Point3d.create(t.x,t.y,t.z).plus(e),c=a.Vector3d.createStartEnd(o,t),l=a.Vector3d.createRotateVectorAroundVector(c,u,s.Angle.createDegrees(90));if(l){const t=a.Vector3d.createStartEnd(o,r),e=c.signedAngleTo(t,u);return e.radians<0&&e.addMultipleOf2PiInPlace(1),Arc3d.create(o,c,l,n.AngleSweep.createStartEndRadians(0,e.radians),i)}}}return p.LineString3d.create(t,e,r)}getFractionToDistanceScale(){const t=this.circularRadius();if(void 0!==t)return Math.abs(t*this._sweep.sweepRadians)}fractionToPoint(t,e){const r=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,Math.cos(r),Math.sin(r),e)}fractionAndRadialFractionToPoint(t,e,r){const i=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,e*Math.cos(i),e*Math.sin(i),r)}fractionToPointAndDerivative(t,e){return(e=this.radiansToPointAndDerivative(this._sweep.fractionToRadians(t),e)).direction.scaleInPlace(this._sweep.sweepRadians),e}fractionToPointAnd2Derivatives(t,e){const r=this._sweep.fractionToRadians(t);e||(e=d.Plane3dByOriginAndVectors.createXYPlane());const i=Math.cos(r),n=Math.sin(r);this._matrix.originPlusMatrixTimesXY(this._center,i,n,e.origin);const s=this._sweep.sweepRadians;this._matrix.multiplyXY(-s*n,s*i,e.vectorU);const o=s*s;return this._matrix.multiplyXY(-o*i,-o*n,e.vectorV),e}radiansToPointAndDerivative(t,e){e=e||l.Ray3d.createZero();const r=Math.cos(t),i=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,r,i,e.origin),this._matrix.multiplyXY(-i,r,e.direction),e}radiansToRotatedBasis(t,e){e=e||d.Plane3dByOriginAndVectors.createXYPlane();const r=Math.cos(t),i=Math.sin(t);return e.origin.setFromPoint3d(this.center),this._matrix.multiplyXY(r,i,e.vectorU),this._matrix.multiplyXY(-i,r,e.vectorV),e}angleToPointAndDerivative(t,e){e=e||l.Ray3d.createZero();const r=t.cos(),i=t.sin();return this._matrix.originPlusMatrixTimesXY(this._center,r,i,e.origin),this._matrix.multiplyXY(-i,r,e.direction),e}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}curveLength(){return this.curveLengthBetweenFractions(0,1)}curveLengthBetweenFractions(t,e){const r=this.getFractionToDistanceScale();if(void 0!==r)return r*Math.abs(e-t);let i=t,n=e;t>e&&(i=e,n=t);const s=(n-i)*this._sweep.sweepDegrees;let o=this.quickEccentricity();o<1e-5&&(o=1e-5);let a=Math.ceil(s/(o*Arc3d.quadratureIntervalAngleDegrees));return a>400&&(a=400),a<1&&(a=1),super.curveLengthWithFixedIntervalCountQuadrature(i,n,a,Arc3d.quadratureGuassCount)}quickLength(){const t=Math.abs(this._sweep.sweepRadians);let e=Math.ceil(4*t/Math.PI);e<1&&(e=1),e<4?e+=3:e<6&&(e+=2);const r=Arc3d._workPointA,i=Arc3d._workPointB;let n=0;this.fractionToPoint(0,r);for(let o=1;o<=e;o++)this.fractionToPoint(o/e,i),n+=r.distance(i),r.setFromPoint3d(i);const s=t/e;return n*(s/(2*Math.sin(.5*s)))}moveSignedDistanceFromFraction(t,e,r,n){if(!this.isCircular)return super.moveSignedDistanceFromFractionGeneric(t,e,r,n);const s=this.curveLength(),o=i.Geometry.conditionalDivideFraction(e,s);return void 0===o?f.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,f.CurveSearchStatus.error):f.CurveLocationDetail.createConditionalMoveSignedDistance(r,this,t,t+o,e,n)}allPerpendicularAngles(t,e=!0,r=!1){const i=[],n=t.vectorTo(this.center),s=this._matrix.columnXMagnitudeSquared(),a=this._matrix.columnXDotColumnY(),c=this._matrix.columnYMagnitudeSquared();return o.TrigPolynomial.solveUnitCircleImplicitQuadricIntersection(a,c-s,-a,this._matrix.dotColumnY(n),-this._matrix.dotColumnX(n),0,i),r&&(i.push(this.sweep.startRadians),i.push(this.sweep.endRadians)),i}closestPoint(t,e,r){r=f.CurveLocationDetail.create(this,r);const i=this.allPerpendicularAngles(t,!0,!0);e||this._sweep.isFullCircle||(i.push(this._sweep.startRadians),i.push(this._sweep.endRadians));const n=l.Ray3d.createZero();if(0===i.length)r.setFR(0,this.radiansToPointAndDerivative(this._sweep.startRadians,n)),r.a=t.distance(r.point);else{let s=Number.MAX_VALUE,o=0;for(const a of i){const i=u.CurveExtendOptions.resolveRadiansToSweepFraction(e,a,this.sweep);void 0!==i&&(this.fractionToPointAndDerivative(i,n),(o=t.distance(n.origin))<s&&(s=o,r.setFR(i,n),r.a=o))}}return r}reverseInPlace(){this._sweep.reverseInPlace()}tryTransformInPlace(t){return this._center=t.multiplyPoint3d(this._center,this._center),this._matrix=t.matrix.multiplyMatrixMatrix(this._matrix,this._matrix),this.setVector0Vector90(this._matrix.columnX(),this._matrix.columnY()),!0}isInPlane(t){const e=t.getNormalRef();return i.Geometry.isSmallMetricDistance(t.altitude(this._center))&&i.Geometry.isSmallMetricDistance(this._matrix.dotColumnX(e))&&i.Geometry.isSmallMetricDistance(this._matrix.dotColumnY(e))}get isCircular(){const t=this._matrix.columnXMagnitudeSquared(),e=this._matrix.columnYMagnitudeSquared(),r=this._matrix.columnXDotColumnY();return s.Angle.isPerpendicularDotSet(t,e,r)&&i.Geometry.isSameCoordinateSquared(t,e)}circularRadius(){return this.isCircular?this._matrix.columnXMagnitude():void 0}maxVectorLength(){return Math.max(this._matrix.columnXMagnitude(),this._matrix.columnYMagnitude())}appendPlaneIntersectionPoints(t,e){const r=t.altitude(this._center),n=this._matrix.coffs,o=t.velocityXYZ(n[0],n[3],n[6]),a=t.velocityXYZ(n[1],n[4],n[7]),c=i.Geometry.solveTrigForm(r,o,a);let l=0;if(void 0!==c){let t;for(t of(l=c.length,c)){const r=Math.atan2(t.y,t.x),i=this._sweep.radiansToPositivePeriodicFraction(r),n=f.CurveLocationDetail.createCurveFractionPoint(this,i,this.fractionToPoint(i));n.intervalRole=f.CurveIntervalRole.isolated,s.Angle.isAlmostEqualRadiansAllowPeriodShift(r,this._sweep.startRadians)?n.intervalRole=f.CurveIntervalRole.isolatedAtVertex:s.Angle.isAlmostEqualRadiansAllowPeriodShift(r,this._sweep.startRadians)&&(n.intervalRole=f.CurveIntervalRole.isolatedAtVertex),e.push(n)}}return l}extendRange(t,e){let r=a.Point3d.create();for(let i=0;i<=1.001;i+=1/32)r=this.fractionToPoint(i,r),e?t.extendTransformedPoint(e,r):t.extendPoint(r)}static createUnitCircle(){return Arc3d.createRefs(a.Point3d.create(0,0,0),c.Matrix3d.createIdentity(),n.AngleSweep.create360())}static createXY(t,e,r=n.AngleSweep.create360()){return new Arc3d(t.clone(),c.Matrix3d.createScale(e,e,1),r)}static createXYEllipse(t,e,r,i=n.AngleSweep.create360()){return new Arc3d(t.clone(),c.Matrix3d.createScale(e,r,1),i)}setVector0Vector90(t,e){this._matrix.setColumns(t,e,t.unitCrossProductWithDefault(e,0,0,0))}toScaledMatrix3d(){const t=s.Angle.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(),this._matrix.columnYMagnitudeSquared(),this._matrix.columnXDotColumnY(),!0),e=this._matrix.multiplyXY(t.c,t.s),r=this._matrix.multiplyXY(-t.s,t.c),n=c.Matrix3d.createRigidFromColumns(e,r,i.AxisOrder.XYZ);return{axes:n||c.Matrix3d.createIdentity(),center:this._center,r0:e.magnitude(),r90:r.magnitude(),sweep:this.sweep.cloneMinusRadians(t.radians)}}toVectors(){return{center:this.center,vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep}}toTransformedVectors(t){return t?{center:t.multiplyPoint3d(this._center),vector0:t.multiplyVector(this._matrix.columnX()),vector90:t.multiplyVector(this._matrix.columnY()),sweep:this.sweep}:{center:this._center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep}}toTransformedPoint4d(t){return{center:t.multiplyPoint3d(this._center,1),vector0:t.multiplyPoint3d(this._matrix.columnX(),0),vector90:t.multiplyPoint3d(this._matrix.columnY(),0),sweep:this.sweep}}setFromJSON(t){if(t&&t.center&&t.vector0&&t.vector90&&t.sweep){this._center.setFromJSON(t.center);const e=a.Vector3d.create(),r=a.Vector3d.create();e.setFromJSON(t.vector0),r.setFromJSON(t.vector90),this.setVector0Vector90(e,r),this._sweep.setFromJSON(t.sweep)}else this._center.set(0,0,0),this._matrix.setFrom(c.Matrix3d.identity),this._sweep.setStartEndRadians()}toJSON(){return{center:this._center.toJSON(),sweep:this._sweep.toJSON(),vector0:this._matrix.columnX().toJSON(),vector90:this._matrix.columnY().toJSON()}}isAlmostEqual(t){if(t instanceof Arc3d){const e=t;return this._center.isAlmostEqual(e._center)&&this._matrix.isAlmostEqual(e._matrix)&&this._sweep.isAlmostEqualAllowPeriodShift(e._sweep)}return!1}emitStrokes(t,e){const r=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,r,0,1,!0)}emitStrokableParts(t,e){const r=this.computeStrokeCountForOptions(e);t.startCurvePrimitive(this),t.announceIntervalForUniformStepStrokes(this,r,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e=1;if(t){const r=this.maxVectorLength();e=t.applyTolerancesToArc(r,this._sweep.sweepRadians)}else e=g.StrokeOptions.applyAngleTol(void 0,1,this._sweep.sweepRadians);return e}dispatchToGeometryHandler(t){return t.handleArc3d(this)}clonePartialCurve(t,e){if(e<t){const r=this.clonePartialCurve(e,t);return r&&r.reverseInPlace(),r}const r=this.clone();return r.sweep.setStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),r}cloneInRotatedBasis(t){const e=t.cos(),r=t.sin(),i=this._matrix.multiplyXY(e,r),s=this.matrix.multiplyXY(-r,e),o=n.AngleSweep.createStartEndRadians(this._sweep.startRadians-t.radians,this._sweep.endRadians-t.radians);return Arc3d.create(this._center.clone(),i,s,o)}announceClipIntervals(t,e){return t.announceClippedArcIntervals(this,e)}otherArcAsLocalVectors(t){const e=this._matrix.multiplyInverseXYZAsPoint3d(t.center.x-this.center.x,t.center.y-this.center.y,t.center.z-this.center.z),r=this._matrix.multiplyInverse(t.vector0),i=this._matrix.multiplyInverse(t.vector90);if(e&&r&&i)return{center:e,vector0:r,vector90:i,sweep:this.sweep.clone()}}static createFilletArc(t,e,r,s){const o=a.Vector3d.createStartEnd(e,t),c=a.Vector3d.createStartEnd(e,r),l=o.magnitude(),d=c.magnitude();if(o.normalizeInPlace()&&c.normalizeInPlace()){const t=o.plus(c);if(t.normalizeInPlace()){const r=c.minus(o),a=r.magnitude(),h=.5*a;if(!i.Geometry.isSmallAngleRadians(h)){const i=h/Math.sqrt(1-h*h),o=Math.acos(h),c=s/h,u=s/i,f=u/l,g=u/d,p=e.plusScaled(t,c);return t.scaleInPlace(-s),r.scaleInPlace(s/a),{arc:Arc3d.create(p,t,r,n.AngleSweep.createStartEndRadians(-o,o)),fraction10:f,fraction12:g,point:e.clone()}}}}return{fraction10:0,fraction12:0,point:e.clone()}}}e.Arc3d=Arc3d,Arc3d._workPointA=a.Point3d.create(),Arc3d._workPointB=a.Point3d.create(),Arc3d.quadratureGuassCount=5,Arc3d.quadratureIntervalAngleDegrees=10},"./lib/curve/ChainCollectorContext.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurveCollection.js"),n=r("./lib/curve/CurvePrimitive.js"),s=r("./lib/curve/Path.js");class ChainCollectorContext{constructor(t){this._chains=[],this._makeClones=t}pushNewChain(t){const e=[];t&&e.push(t),this._chains.push(e)}findOrCreateTailChain(){return 0===this._chains.length&&this.pushNewChain(),this._chains[this._chains.length-1]}announceCurvePrimitive(t){if(t){if(this._makeClones){const e=t.clone();if(!e||!(e instanceof n.CurvePrimitive))return;this.transferMarkup(t,e),t=e}const e=this.findOrCreateTailChain();0!==e.length&&ChainCollectorContext.needBreakBetweenPrimitives(e[e.length-1],t)?this.pushNewChain(t):e.push(t)}}transferMarkup(t,e){t&&e&&(e.startCut=t.startCut,e.endCut=t.endCut)}promoteArrayToCurves(t){if(0!==t.length)return 1===t.length?t[0]:s.Path.createArray(t)}grabResult(){const t=this._chains;if(0===t.length)return;if(1===t.length)return this.promoteArrayToCurves(t[0]);const e=i.BagOfCurves.create();for(const r of t){const t=this.promoteArrayToCurves(r);e.tryAddChild(t)}return e}static needBreakBetweenPrimitives(t,e,r=!1){return void 0===t||(void 0===e||(void 0!==t.endCut||(void 0!==e.startCut||(ChainCollectorContext._workPointA=t.endPoint(ChainCollectorContext._workPointA),ChainCollectorContext._workPointB=t.startPoint(ChainCollectorContext._workPointB),r?ChainCollectorContext._workPointA.isAlmostEqualXY(ChainCollectorContext._workPointB):ChainCollectorContext._workPointA.isAlmostEqual(ChainCollectorContext._workPointB)))))}}e.ChainCollectorContext=ChainCollectorContext},"./lib/curve/ConstructCurveBetweenCurves.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/GeometryHandler.js"),n=r("./lib/curve/LineSegment3d.js"),s=r("./lib/curve/Arc3d.js"),o=r("./lib/geometry3d/Point3dVector3d.js"),a=r("./lib/curve/LineString3d.js"),c=r("./lib/Geometry.js");class ConstructCurveBetweenCurves extends i.NullGeometryHandler{constructor(t,e,r){super(),this._geometry1=r,this._fraction=e}handleLineSegment3d(t){if(this._geometry1 instanceof n.LineSegment3d){const e=this._geometry1;return n.LineSegment3d.create(t.startPoint().interpolate(this._fraction,e.startPoint()),t.endPoint().interpolate(this._fraction,e.endPoint()))}}handleLineString3d(t){if(this._geometry1 instanceof a.LineString3d){const e=this._geometry1;if(t.numPoints()===e.numPoints()){const r=t.numPoints(),i=a.LineString3d.create(),n=o.Point3d.create(),s=o.Point3d.create(),l=o.Point3d.create();let d,h;const u=this._fraction;for(let o=0;o<r;o++)t.pointAt(o,s),e.pointAt(o,l),s.interpolate(u,l,n),i.addPoint(n);if(t.fractions&&e.fractions)for(let o=0;o<r;o++)i.addFraction(c.Geometry.interpolate(t.fractions.atUncheckedIndex(o),u,e.fractions.atUncheckedIndex(o)));if(t.strokeData&&e.strokeData&&(i.strokeData=t.strokeData.clone()),t.packedDerivatives&&e.packedDerivatives){d||(d=o.Vector3d.create()),h||(h=o.Vector3d.create());for(let n=0;n<r;n++)t.packedDerivatives.getVector3dAtCheckedVectorIndex(n,d),e.packedDerivatives.getVector3dAtCheckedVectorIndex(n,h),i.addDerivative(d.interpolate(u,h))}return i}}}handleArc3d(t){if(this._geometry1 instanceof s.Arc3d){const e=this._geometry1;return s.Arc3d.create(t.center.interpolate(this._fraction,e.center),t.vector0.interpolate(this._fraction,e.vector0),t.vector90.interpolate(this._fraction,e.vector90),t.sweep.interpolate(this._fraction,e.sweep))}}static interpolateBetween(t,e,r){const i=new ConstructCurveBetweenCurves(t,e,r);return t.dispatchToGeometryHandler(i)}}e.ConstructCurveBetweenCurves=ConstructCurveBetweenCurves},"./lib/curve/CoordinateXYZ.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Range.js"),s=r("./lib/curve/GeometryQuery.js");class CoordinateXYZ extends s.GeometryQuery{constructor(t){super(),this.geometryCategory="point",this._xyz=t}get point(){return this._xyz}static create(t){return new CoordinateXYZ(t.clone())}static createXYZ(t=0,e=0,r=0){return new CoordinateXYZ(i.Point3d.create(t,e,r))}range(){return n.Range3d.create(this._xyz)}extendRange(t,e){e?t.extendTransformedXYZ(e,this._xyz.x,this._xyz.y,this._xyz.z):t.extend(this._xyz)}tryTransformInPlace(t){return t.multiplyPoint3d(this._xyz,this._xyz),!0}cloneTransformed(t){const e=new CoordinateXYZ(this._xyz.clone());return e.tryTransformInPlace(t),e}clone(){return new CoordinateXYZ(this._xyz.clone())}isSameGeometryClass(t){return t instanceof CoordinateXYZ}isAlmostEqual(t){return t instanceof CoordinateXYZ&&this._xyz.isAlmostEqual(t._xyz)}dispatchToGeometryHandler(t){return t.handleCoordinateXYZ(this)}}e.CoordinateXYZ=CoordinateXYZ},"./lib/curve/CurveChainWithDistanceIndex.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/curve/CurvePrimitive.js"),o=r("./lib/curve/Query/StrokeCountMap.js"),a=r("./lib/curve/CurveCollection.js"),c=r("./lib/curve/CurveLocationDetail.js"),l=r("./lib/curve/CurveExtendMode.js");class PathFragment{constructor(t,e,r,i,n){this.childFraction0=t,this.childFraction1=e,this.chainDistance0=r,this.chainDistance1=i,this.childCurve=n}containsChainDistance(t){return t>=this.chainDistance0&&t<=this.chainDistance1}containsChildCurveAndChildFraction(t,e){return this.childCurve===t&&e>=this.childFraction0&&e<=this.childFraction1}chainDistanceToInterpolatedChildFraction(t){return i.Geometry.inverseInterpolate(this.childFraction0,this.chainDistance0,this.childFraction1,this.chainDistance1,t,this.childFraction0)}chainDistanceToAccurateChildFraction(t){return this.childCurve.moveSignedDistanceFromFraction(this.childFraction0,t-this.chainDistance0,!1).fraction}fractionScaleFactor(t){return t*(this.childFraction1-this.childFraction0)/(this.chainDistance1-this.chainDistance0)}reverseFractionsAndDistances(t){const e=this.childFraction0,r=this.childFraction1,i=this.chainDistance0,n=this.chainDistance1;this.childFraction0=1-r,this.childFraction1=1-e,this.chainDistance0=t-n,this.chainDistance1=t-i}childFractionTChainDistance(t){let e=this.childCurve.curveLengthBetweenFractions(this.childFraction0,t);return t<this.childFraction0&&(e=-e),this.chainDistance0+e}}e.PathFragment=PathFragment;class DistanceIndexConstructionContext{constructor(){this._accumulatedDistance=0,this._fragments=[]}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endParentCurvePrimitive(t){}endCurvePrimitive(t){}announcePointTangent(t,e,r){}announceSegmentInterval(t,e,r,n,s,o){let a=this._accumulatedDistance;if(n<=1)this._accumulatedDistance+=e.distance(r),this._fragments.push(new PathFragment(s,o,a,this._accumulatedDistance,t));else{let c;for(let l=1,d=0;l<=n;l++,d=c)c=i.Geometry.interpolate(s,l/n,o),a=this._accumulatedDistance,this._accumulatedDistance+=Math.abs(c-d)*e.distance(r),this._fragments.push(new PathFragment(d,c,a,this._accumulatedDistance,t))}}announceIntervalForUniformStepStrokes(t,e,r,n){let s,o,a;for(let c=1,l=r;c<=e;c++,l=s)s=i.Geometry.interpolate(r,c/e,n),o=t.curveLengthBetweenFractions(l,s),a=this._accumulatedDistance,this._accumulatedDistance+=o,this._fragments.push(new PathFragment(l,s,a,this._accumulatedDistance,t))}static createPathFragmentIndex(t,e){const r=new DistanceIndexConstructionContext;for(const i of t.children)i.emitStrokableParts(r,e);return r._fragments}}class CurveChainWithDistanceIndex extends s.CurvePrimitive{constructor(t,e){super(),this.curvePrimitiveType="curveChainWithDistanceIndex",this._path=t,this._fragments=e,this._totalLength=e[e.length-1].chainDistance1}isSameGeometryClass(t){return t instanceof CurveChainWithDistanceIndex}cloneTransformed(t){const e=this._path.clone();if(void 0!==e&&e instanceof a.CurveChain&&e.tryTransformInPlace(t))return CurveChainWithDistanceIndex.createCapture(e)}get path(){return this._path}clone(){const t=this._path.clone();if(void 0!==t&&t instanceof a.CurveChain)return CurveChainWithDistanceIndex.createCapture(t)}isInPlane(t){for(const e of this._path.children)if(!e.isInPlane(t))return!1;return!0}startPoint(t){const e=this._path.cyclicCurvePrimitive(0);return e?e.startPoint(t):n.Point3d.createZero(t)}endPoint(t){const e=this._path.cyclicCurvePrimitive(-1);return e?e.endPoint(t):n.Point3d.createZero(t)}emitStrokes(t,e){for(const r of this._path.children)r.emitStrokes(t,e)}emitStrokableParts(t,e){for(const r of this._path.children)r.emitStrokableParts(t,e)}computeStrokeCountForOptions(t){let e=0;for(const r of this._path.children)e+=r.computeStrokeCountForOptions(t);return e}computeAndAttachRecursiveStrokeCounts(t,e){const r=o.StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this,e);for(const i of this._path.children)i.computeAndAttachRecursiveStrokeCounts(t,r);s.CurvePrimitive.installStrokeCountMap(this,r,e)}dispatchToGeometryHandler(t){return this._path.dispatchToGeometryHandler(t)}extendRange(t,e){this._path.extendRange(t,e)}curveLengthBetweenFractions(t,e){return Math.abs(e-t)*this._totalLength}static createCapture(t,e){if(0===t.children.length)return;const r=DistanceIndexConstructionContext.createPathFragmentIndex(t,e);return new CurveChainWithDistanceIndex(t,r)}chainDistanceToFragment(t,e=!1){const r=this._fragments.length,i=this._fragments;if(r>0){if(t<0)return e?i[0]:void 0;if(t>=this._totalLength)return e?i[r-1]:void 0;for(const e of i)if(e.containsChainDistance(t))return e}}chainDistanceToChainFraction(t){return t/this._totalLength}curveAndChildFractionToFragment(t,e){const r=this._fragments.length,i=this._fragments;if(r>0){for(const r of i)if(r.containsChildCurveAndChildFraction(t,e))return r;if(e<=0)return i[0];if(e>1)return i[r-1]}}curveLength(){return this._totalLength}quickLength(){return this._totalLength}fractionToPoint(t,e){const r=t*this._totalLength;let i=this.chainDistanceToFragment(r,!0);if(i){const t=i.chainDistanceToAccurateChildFraction(r);return i.childCurve.fractionToPoint(t,e)}return i=this.chainDistanceToFragment(r,!0),this._fragments[0].childCurve.fractionToPoint(0,e)}fractionToPointAndDerivative(t,e){const r=t*this._totalLength,i=this.chainDistanceToFragment(r,!0),n=i.chainDistanceToAccurateChildFraction(r);e=i.childCurve.fractionToPointAndDerivative(n,e);const s=this._totalLength/e.direction.magnitude();return e.direction.scaleInPlace(s),e}fractionToPointAndUnitTangent(t,e){const r=t*this._totalLength,i=this.chainDistanceToFragment(r,!0),n=i.chainDistanceToAccurateChildFraction(r);return(e=i.childCurve.fractionToPointAndDerivative(n,e)).direction.normalizeInPlace(),e}fractionToPointAnd2Derivatives(t,e){const r=this._totalLength,i=t*r,s=this.chainDistanceToFragment(i,!0),o=s.chainDistanceToAccurateChildFraction(i);if(!(e=s.childCurve.fractionToPointAnd2Derivatives(o,e)))return;const a=e.vectorU.magnitudeSquared(),c=Math.sqrt(a),l=e.vectorU.dotProduct(e.vectorV),d=1/c,h=d*d;return n.Vector3d.createAdd2Scaled(e.vectorV,h,e.vectorU,-h*l/a,e.vectorV),e.vectorU.scale(d),e.vectorU.scaleInPlace(r),e.vectorV.scaleInPlace(r*r),e}tryTransformInPlace(t){let e=0;for(const r of this._path.children)r.tryTransformInPlace(t)||e++;return 0===e}reverseInPlace(){this._path.reverseChildrenInPlace();const t=this._totalLength;for(const e of this._fragments)e.reverseFractionsAndDistances(t);for(let e=0,r=this._fragments.length-1;e<r;e++,r--){const t=this._fragments[e];this._fragments[e]=this._fragments[r],this._fragments[r]=t}}isAlmostEqual(t){return t instanceof CurveChainWithDistanceIndex&&(i.Geometry.isSameCoordinate(this._totalLength,t._totalLength)&&this._path.isAlmostEqual(t._path))}moveSignedDistanceFromFraction(t,e,r,i){const n=t*this._totalLength+e,s=this.chainDistanceToFragment(n,!0),o=s.childCurve.moveSignedDistanceFromFraction(s.childFraction0,n-s.chainDistance0,r,i),a=t+e/this._totalLength,l=c.CurveLocationDetail.createConditionalMoveSignedDistance(r,this,t,a,e,i);return l.childDetail=o,l}closestPoint(t,e){let r,i=Number.MAX_VALUE;const n=this.path.children.length;if(1===n)r=this.path.children[0].closestPoint(t,e);else{const s=[l.CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),l.CurveExtendMode.None],o=[l.CurveExtendMode.None,l.CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(e,1)];for(let e=0;e<n;e++){const a=this.path.children[e].closestPoint(t,0===e?s:e+1===n&&o);a&&a.a<i&&(i=a.a,(r=c.CurveLocationDetail.createCurveFractionPoint(a.curve,a.fraction,a.point,r)).a=a.a)}}if(!r)return;const s=this.curveAndChildFractionToFragment(r.curve,r.fraction);if(s){const t=s.childFractionTChainDistance(r.fraction),e=this.chainDistanceToChainFraction(t),i=c.CurveLocationDetail.createCurveFractionPoint(this,e,r.point);return i.childDetail=r,i}}}e.CurveChainWithDistanceIndex=CurveChainWithDistanceIndex},"./lib/curve/CurveCollection.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/GeometryQuery.js"),n=r("./lib/curve/CurveProcessor.js"),s=r("./lib/curve/CurvePrimitive.js"),o=r("./lib/curve/LineSegment3d.js"),a=r("./lib/curve/LineString3d.js"),c=r("./lib/Geometry.js"),l=r("./lib/curve/CurveLocationDetail.js");class GapSearchContext extends n.RecursiveCurveProcessorWithStack{constructor(){super(),this.maxGap=0}static maxGap(t){const e=new GapSearchContext;return t.announceToCurveProcessor(e),e.maxGap}announceCurvePrimitive(t,e){if(this._stack.length>0){const r=this._stack[this._stack.length-1];if(r instanceof CurveChain){const i=r.cyclicCurvePrimitive(e+1);void 0!==t&&void 0!==i&&(this.maxGap=Math.max(this.maxGap,t.endPoint().distance(i.startPoint())))}}}}class CountLinearPartsSearchContext extends n.RecursiveCurveProcessorWithStack{constructor(){super(),this.numLineSegment=0,this.numLineString=0,this.numOther=0}static hasNonLinearPrimitives(t){const e=new CountLinearPartsSearchContext;return t.announceToCurveProcessor(e),e.numOther>0}announceCurvePrimitive(t,e){t instanceof o.LineSegment3d?this.numLineSegment++:t instanceof a.LineString3d?this.numLineString++:this.numOther++}}class TransformInPlaceContext extends n.RecursiveCurveProcessor{constructor(t){super(),this.numFail=0,this.numOK=0,this.transform=t}static tryTransformInPlace(t,e){const r=new TransformInPlaceContext(e);return t.announceToCurveProcessor(r),0===r.numFail}announceCurvePrimitive(t,e){t.tryTransformInPlace(this.transform)?this.numOK++:this.numFail++}}class SumLengthsContext extends n.RecursiveCurveProcessor{constructor(){super(),this._sum=0}static sumLengths(t){const e=new SumLengthsContext;return t.announceToCurveProcessor(e),e._sum}announceCurvePrimitive(t,e){this._sum+=t.curveLength()}}class CloneCurvesContext extends n.RecursiveCurveProcessorWithStack{constructor(t){super(),this._transform=t,this._result=void 0}static clone(t,e){const r=new CloneCurvesContext(e);return t.announceToCurveProcessor(r),r._result}enter(t){t instanceof CurveCollection&&super.enter(t.cloneEmptyPeer())}leave(){const t=super.leave();return t&&(0===this._stack.length?this._result=t:this._stack[this._stack.length-1].tryAddChild(t)),t}doClone(t){return this._transform?t.cloneTransformed(this._transform):t.clone()}announceCurvePrimitive(t,e){const r=this.doClone(t);if(void 0!==r&&this._stack.length>0){const t=this._stack[this._stack.length-1];if(t instanceof CurveChain||t instanceof BagOfCurves)if(Array.isArray(r))for(const e of r)t.tryAddChild(e);else t.tryAddChild(r)}}}class CloneWithExpandedLineStrings extends CloneCurvesContext{constructor(){super(void 0)}doClone(t){if(t instanceof a.LineString3d&&t.numPoints()>1){const e=t.packedPoints,r=e.length,i=[];for(let t=0;t+1<r;t++)i.push(o.LineSegment3d.createCapture(e.getPoint3dAtUncheckedPointIndex(t),e.getPoint3dAtUncheckedPointIndex(t+1)));return i}return t.clone()}static clone(t){const e=new CloneWithExpandedLineStrings;return t.announceToCurveProcessor(e),e._result}}class CurveCollection extends i.GeometryQuery{constructor(){super(...arguments),this.geometryCategory="curveCollection",this.isInner=!1}sumLengths(){return SumLengthsContext.sumLengths(this)}maxGap(){return GapSearchContext.maxGap(this)}checkForNonLinearPrimitives(){return CountLinearPartsSearchContext.hasNonLinearPrimitives(this)}tryTransformInPlace(t){return TransformInPlaceContext.tryTransformInPlace(this,t)}clone(){return CloneCurvesContext.clone(this)}cloneTransformed(t){return CloneCurvesContext.clone(this,t)}cloneWithExpandedLineStrings(){return CloneWithExpandedLineStrings.clone(this)}collectCurvePrimitivesGo(t){if(this.children)for(const e of this.children)e instanceof s.CurvePrimitive?t.push(e):e instanceof CurveCollection&&e.collectCurvePrimitivesGo(t)}collectCurvePrimitives(){const t=[];return this.collectCurvePrimitivesGo(t),t}get isAnyRegionType(){return 2===this.dgnBoundaryType()||5===this.dgnBoundaryType()||4===this.dgnBoundaryType()}get isOpenPath(){return 1===this.dgnBoundaryType()}get isClosedPath(){return 2===this.dgnBoundaryType()}extendRange(t,e){const r=this.children;if(r)for(const i of r)i.extendRange(t,e)}static createCurveLocationDetailOnAnyCurvePrimitive(t,e=.5){if(t){if(t instanceof s.CurvePrimitive)return l.CurveLocationDetail.createCurveEvaluatedFraction(t,e);if(t instanceof CurveCollection&&void 0!==t.children)for(const r of t.children){const t=this.createCurveLocationDetailOnAnyCurvePrimitive(r,e);if(t)return t}}}}e.CurveCollection=CurveCollection;class CurveChain extends CurveCollection{constructor(){super(),this._curves=[]}get children(){return void 0===this._curves&&(this._curves=[]),this._curves}cyclicCurvePrimitive(t){const e=this.children.length;if(0===e)return;const r=c.Geometry.modulo(t,e);return this.children[r]}getPackedStrokes(t){const e=this.cloneStroked(t);if(e instanceof CurveChain){const t=e.children;if(1===t.length){const e=t[0];if(e instanceof a.LineString3d)return e.packedPoints}}}cloneStroked(t){const e=a.LineString3d.create();for(const r of this.children)r.emitStrokes(e,t);return e}tryAddChild(t){return!!(t&&t instanceof s.CurvePrimitive)&&(this._curves.push(t),!0)}getChild(t){if(t<this._curves.length)return this._curves[t]}extendRange(t,e){for(const r of this._curves)r.extendRange(t,e)}reverseChildrenInPlace(){for(const t of this._curves)t.reverseInPlace();this._curves.reverse()}}e.CurveChain=CurveChain;class BagOfCurves extends CurveCollection{constructor(){super(),this.curveCollectionType="bagOfCurves",this._children=[]}isSameGeometryClass(t){return t instanceof BagOfCurves}get children(){return this._children}static create(...t){const e=new BagOfCurves;for(const r of t)e.tryAddChild(r);return e}dgnBoundaryType(){return 0}announceToCurveProcessor(t,e=-1){return t.announceBagOfCurves(this,e)}cloneStroked(t){const e=new BagOfCurves;let r;for(r of this.children)if(r instanceof s.CurvePrimitive){const i=a.LineString3d.create();r.emitStrokes(i,t),i&&e.children.push(i)}else if(r instanceof CurveCollection){const i=r.cloneStroked(t);i&&e.children.push(i)}return e}cloneEmptyPeer(){return new BagOfCurves}tryAddChild(t){return t&&this._children.push(t),!0}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleBagOfCurves(this)}}e.BagOfCurves=BagOfCurves;e.ConsolidateAdjacentCurvePrimitivesOptions=class ConsolidateAdjacentCurvePrimitivesOptions{constructor(){this.consolidateLinearGeometry=!0,this.consolidateCompatibleArcs=!0,this.duplicatePointTolerance=c.Geometry.smallMetricDistance,this.colinearPointTolerance=c.Geometry.smallMetricDistance}}},"./lib/curve/CurveCurve.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurveCurveIntersectXY.js"),n=r("./lib/curve/CurveCurveIntersectXYZ.js"),s=r("./lib/curve/CurveCollection.js"),o=r("./lib/curve/CurvePrimitive.js");e.CurveCurve=class CurveCurve{static intersectionXY(t,e,r,n){const s=new i.CurveCurveIntersectXY(void 0,t,e,r,n);return t.dispatchToGeometryHandler(s),s.grabResults()}static intersectionXYPairs(t,e,r,n){const a=new i.CurveCurveIntersectXY(void 0,t,e,r,n);if(r instanceof o.CurvePrimitive)t.dispatchToGeometryHandler(a);else if(r instanceof s.CurveCollection){const e=r.collectCurvePrimitives();for(const r of e)a.resetGeometry(t,!1,r,!1),t.dispatchToGeometryHandler(a)}return a.grabPairedResults()}static intersectionProjectedXY(t,e,r,n,s){const o=new i.CurveCurveIntersectXY(t,e,r,n,s);return e.dispatchToGeometryHandler(o),o.grabResults()}static intersectionXYZ(t,e,r,i){const s=new n.CurveCurveIntersectXYZ(t,e,r,i);return t.dispatchToGeometryHandler(s),s.grabResults()}}},"./lib/curve/CurveCurveIntersectXY.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/GeometryHandler.js"),n=r("./lib/curve/CurveLocationDetail.js"),s=r("./lib/Geometry.js"),o=r("./lib/curve/LineSegment3d.js"),a=r("./lib/curve/LineString3d.js"),c=r("./lib/geometry3d/Point2dVector2d.js"),l=r("./lib/geometry3d/Point3dVector3d.js"),d=r("./lib/numerics/Polynomials.js"),h=r("./lib/geometry4d/Point4d.js"),u=r("./lib/geometry3d/Matrix3d.js"),f=r("./lib/curve/Arc3d.js"),g=r("./lib/geometry3d/GrowableFloat64Array.js"),p=r("./lib/bspline/BSplineCurve.js"),m=r("./lib/numerics/BezierPolynomials.js"),y=r("./lib/numerics/Newton.js"),P=r("./lib/geometry3d/Ray3d.js");class BezierBezierIntersectionXYRRToRRD extends y.NewtonEvaluatorRRtoRRD{constructor(t,e){super(),this._curveA=t,this._curveB=e,this._rayA=P.Ray3d.createZero(),this._rayB=P.Ray3d.createZero()}evaluate(t,e){return this._curveA.fractionToPointAndDerivative(t,this._rayA),this._curveB.fractionToPointAndDerivative(e,this._rayB),this.currentF.setOriginAndVectorsXYZ(this._rayB.origin.x-this._rayA.origin.x,this._rayB.origin.y-this._rayA.origin.y,0,-this._rayA.direction.x,-this._rayA.direction.y,0,this._rayB.direction.x,this._rayB.direction.y,0),!0}}class CurveLocationDetailArrayPair{constructor(){this.dataA=[],this.dataB=[]}}e.CurveLocationDetailArrayPair=CurveLocationDetailArrayPair;class CurveCurveIntersectXY extends i.NullGeometryHandler{constructor(t,e,r,i,n){super(),this._extendA=r,this._geometryB=i,this._extendB=n,this._worldToLocalPerspective=void 0,this._worldToLocalAffine=void 0,void 0===t||t.isIdentity()||(this._worldToLocalAffine=t.asTransform,this._worldToLocalAffine||(this._worldToLocalPerspective=t.clone())),this.reinitialize()}reinitialize(){this._results=[]}resetGeometry(t,e,r,i){this._extendA=e,this._geometryB=r,this._extendB=i}grabResults(t=!1){const e=this._results;t&&this.reinitialize();const r=new CurveLocationDetailArrayPair;for(const i of e)r.dataA.push(i.detailA),r.dataB.push(i.detailB);return r}acceptFraction(t,e,r){return!(!t&&e<0)&&!(!r&&e>1)}grabPairedResults(t=!1){const e=this._results;return t&&this.reinitialize(),e}recordPointWithLocalFractions(t,e,r,i,o,a,c,l,d){const h=s.Geometry.interpolate(r,t,i),u=s.Geometry.interpolate(c,o,l),f=this._results.length;if(f>0){const t=this._results[f-1].detailA.fraction,e=this._results[f-1].detailB.fraction;if(d){if(s.Geometry.isAlmostEqualNumber(t,u)&&s.Geometry.isAlmostEqualNumber(e,h))return}else if(s.Geometry.isAlmostEqualNumber(t,h)&&s.Geometry.isAlmostEqualNumber(e,u))return}const g=n.CurveLocationDetail.createCurveFractionPoint(e,h,e.fractionToPoint(h));g.setIntervalRole(n.CurveIntervalRole.isolated);const p=n.CurveLocationDetail.createCurveFractionPoint(a,u,a.fractionToPoint(u));p.setIntervalRole(n.CurveIntervalRole.isolated),d?this._results.push(new n.CurveLocationDetailPair(p,g)):this._results.push(new n.CurveLocationDetailPair(g,p))}computeSegmentSegment3D(t,e,r,i,n,s,o,a,c,l,h,u,f,g,p){const m=CurveCurveIntersectXY._workVector2dA;d.SmallSystem.lineSegment3dXYTransverseIntersectionUnbounded(r,n,l,u,m)&&this.acceptFraction(e,m.x,o)&&this.acceptFraction(c,m.y,g)&&this.recordPointWithLocalFractions(m.x,t,i,s,m.y,a,h,f,p)}computeSegmentSegment3DH(t,e,r,i,n,s,o,a,c,l,h,u,f,g,p){const m=CurveCurveIntersectXY._workPointA0H,y=CurveCurveIntersectXY._workPointA1H,P=CurveCurveIntersectXY._workPointB0H,x=CurveCurveIntersectXY._workPointB1H;this._worldToLocalPerspective.multiplyPoint3d(r,1,m),this._worldToLocalPerspective.multiplyPoint3d(n,1,y),this._worldToLocalPerspective.multiplyPoint3d(l,1,P),this._worldToLocalPerspective.multiplyPoint3d(u,1,x);const _=d.SmallSystem.lineSegment3dHXYTransverseIntersectionUnbounded(m,y,P,x);if(void 0!==_){const r=_.x,n=_.y;this.acceptFraction(e,r,o)&&this.acceptFraction(c,n,g)&&this.recordPointWithLocalFractions(r,t,i,s,n,a,h,f,p)}}dispatchSegmentSegment(t,e,r,i,n,s,o,a,c,l,d,h,u,f,g){this._worldToLocalAffine?(CurveCurveIntersectXY.setTransformedWorkPoints(this._worldToLocalAffine,r,n,l,h),this.computeSegmentSegment3D(t,e,CurveCurveIntersectXY._workPointA0,i,CurveCurveIntersectXY._workPointA1,s,o,a,c,CurveCurveIntersectXY._workPointB0,d,CurveCurveIntersectXY._workPointB1,u,f,g)):this._worldToLocalPerspective?this.computeSegmentSegment3DH(t,e,r,i,n,s,o,a,c,l,d,h,u,f,g):this.computeSegmentSegment3D(t,e,r,i,n,s,o,a,c,l,d,h,u,f,g)}dispatchSegmentArc(t,e,r,i,n,o,a,c,l,h,u){if(this._worldToLocalPerspective){const f=c.toTransformedPoint4d(this._worldToLocalPerspective),p=this._worldToLocalPerspective.multiplyPoint3d(r,1),m=this._worldToLocalPerspective.multiplyPoint3d(n,1),y=s.Geometry.tripleProductPoint4dXYW(p,m,f.center),P=s.Geometry.tripleProductPoint4dXYW(p,m,f.vector0),x=s.Geometry.tripleProductPoint4dXYW(p,m,f.vector90),_=new g.GrowableFloat64Array(2),v=new g.GrowableFloat64Array(2),S=new g.GrowableFloat64Array(2),C=d.AnalyticRoots.appendImplicitLineUnitCircleIntersections(y,P,x,_,v,S);for(let r=0;r<C;r++){const n=f.center.plus2Scaled(f.vector0,_.atUncheckedIndex(r),f.vector90,v.atUncheckedIndex(r)),s=f.sweep.radiansToSignedPeriodicFraction(S.atUncheckedIndex(r)),g=d.SmallSystem.lineSegment3dHXYClosestPointUnbounded(p,m,n);void 0!==g&&this.acceptFraction(e,g,a)&&this.acceptFraction(l,s,h)&&this.recordPointWithLocalFractions(g,t,i,o,s,c,0,1,u)}}else{const f=c.toTransformedVectors(this._worldToLocalAffine);let p=r,m=n;this._worldToLocalAffine&&(p=this._worldToLocalAffine.multiplyPoint3d(r),m=this._worldToLocalAffine.multiplyPoint3d(n));const y=s.Geometry.tripleProductXYW(p,1,m,1,f.center,1),P=s.Geometry.tripleProductXYW(p,1,m,1,f.vector0,0),x=s.Geometry.tripleProductXYW(p,1,m,1,f.vector90,0),_=new g.GrowableFloat64Array(2),v=new g.GrowableFloat64Array(2),S=new g.GrowableFloat64Array(2),C=d.AnalyticRoots.appendImplicitLineUnitCircleIntersections(y,P,x,_,v,S);for(let r=0;r<C;r++){const n=f.center.plus2Scaled(f.vector0,_.atUncheckedIndex(r),f.vector90,v.atUncheckedIndex(r)),s=f.sweep.radiansToSignedPeriodicFraction(S.atUncheckedIndex(r)),g=d.SmallSystem.lineSegment3dXYClosestPointUnbounded(p,m,n);void 0!==g&&this.acceptFraction(e,g,a)&&this.acceptFraction(l,s,h)&&this.recordPointWithLocalFractions(g,t,i,o,s,c,0,1,u)}}}dispatchArcArcThisOrder(t,e,r,i,n,s,o){const a=e.inverse();if(a){const e=a.multiplyMatrixMatrix(n),c=[],l=[];d.TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(e.coffs[2],e.coffs[5],e.coffs[8],e.coffs[0],e.coffs[3],e.coffs[6],e.coffs[1],e.coffs[4],e.coffs[7],c,l);for(let n=0;n<c.length;n++){const e=t.sweep.radiansToSignedPeriodicFraction(l[n]),a=i.sweep.radiansToSignedPeriodicFraction(c[n]);this.acceptFraction(r,e,r)&&this.acceptFraction(s,a,s)&&this.recordPointWithLocalFractions(e,t,0,1,a,i,0,1,o)}}}dispatchArcArc(t,e,r,i,n){let s,o;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective),i=r.toTransformedPoint4d(this._worldToLocalPerspective);s=u.Matrix3d.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w),o=u.Matrix3d.createColumnsXYW(i.vector0,i.vector0.w,i.vector90,e.vector90.w,i.center,i.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine),i=r.toTransformedVectors(this._worldToLocalAffine);s=u.Matrix3d.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1),o=u.Matrix3d.createColumnsXYW(i.vector0,0,i.vector90,0,i.center,1)}s.conditionNumber()>o.conditionNumber()?this.dispatchArcArcThisOrder(t,s,e,r,o,i,n):this.dispatchArcArcThisOrder(r,o,i,t,s,e,!n)}dispatchArcBsplineCurve3d(t,e,r,i,n){let s;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective);s=u.Matrix3d.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine);s=u.Matrix3d.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1)}const o=s.inverse();if(o){const s=r.order,a=2*s-1,c=new Float64Array(s),l=new m.UnivariateBezier(a),d=o.at(0,0),h=o.at(0,1),u=0,f=o.at(0,2),g=o.at(1,0),p=o.at(1,1),y=0,P=o.at(1,2),x=o.at(2,0),_=o.at(2,1),v=0,S=o.at(2,2);if(o){let s;for(let o=0;s=r.getSaturatedBezierSpan3dH(o,s);o++){this._worldToLocalPerspective?s.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective):this._worldToLocalAffine&&s.tryTransformInPlace(this._worldToLocalAffine),l.zero(),s.poleProductsXYZW(c,d,h,u,f),l.addSquaredSquaredBezier(c,1),s.poleProductsXYZW(c,g,p,y,P),l.addSquaredSquaredBezier(c,1),s.poleProductsXYZW(c,x,_,v,S),l.addSquaredSquaredBezier(c,-1);const o=l.roots(0,!0);if(o)for(const a of o){const o=s.fractionToParentFraction(a),c=s.fractionToPoint4d(a),l=c.dotProductXYZW(d,h,u,f),m=c.dotProductXYZW(g,p,y,P),x=t.sweep.radiansToSignedPeriodicFraction(Math.atan2(m,l));this.acceptFraction(e,x,e)&&this.acceptFraction(i,o,i)&&this.recordPointWithLocalFractions(x,t,0,1,o,r,0,1,n)}}}}}transformBeziers(t){if(this._worldToLocalAffine)for(const e of t)e.tryTransformInPlace(this._worldToLocalAffine);else if(this._worldToLocalPerspective)for(const e of t)e.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective)}getRanges(t){const e=[];e.length=0;for(const r of t)e.push(r.range());return e}dispatchBezierBezierStrokeFirst(t,e,r,i,n,o,a,c){this._xyzwA0||(this._xyzwA0=h.Point4d.create()),this._xyzwA1||(this._xyzwA1=h.Point4d.create()),this._xyzwPlane||(this._xyzwPlane=h.Point4d.create()),this._xyzwB||(this._xyzwB=h.Point4d.create()),t.fractionToPoint4d(0,this._xyzwA0);let l=0,u=1;const f=1/r;for(let g=1;g<=r;g++,l=u,this._xyzwA0.setFrom(this._xyzwA1)){u=g*f,t.fractionToPoint4d(u,this._xyzwA1),h.Point4d.createPlanePointPointZ(this._xyzwA0,this._xyzwA1,this._xyzwPlane),i.poleProductsXYZW(a.coffs,this._xyzwPlane.x,this._xyzwPlane.y,this._xyzwPlane.z,this._xyzwPlane.w);let r=0;const o=a.roots(0,!0);if(o)for(const a of o){let o=a;i.fractionToPoint4d(o,this._xyzwB);const h=d.SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0,this._xyzwA1,this._xyzwB);if(h&&s.Geometry.isIn01WithTolerance(h,1e-5)){let a=s.Geometry.interpolate(l,h,u);const d=new BezierBezierIntersectionXYRRToRRD(t,i),f=new y.Newton2dUnboundedWithDerivative(d);f.setUV(a,o),f.runIterations()&&(a=f.getU(),o=f.getV());const g=t.fractionToParentFraction(a),p=i.fractionToParentFraction(o),m=t.fractionToPoint(a),P=e.fractionToPoint(g),x=i.fractionToPoint(o),_=n.fractionToPoint(p);m.isAlmostEqualXY(P)||r++,x.isAlmostEqualXY(_)||r++,r>0&&!m.isAlmostEqual(x)&&r++,r>0&&!P.isAlmostEqual(_)&&r++,this.acceptFraction(!1,g,!1)&&this.acceptFraction(!1,p,!1)&&this.recordPointWithLocalFractions(g,e,0,1,p,n,0,1,c)}}}}dispatchBSplineCurve3dBSplineCurve3d(t,e,r){const i=t.collectBezierSpans(!0),n=e.collectBezierSpans(!0),s=i.length,o=n.length;this.transformBeziers(i),this.transformBeziers(n);const a=this.getRanges(i),c=this.getRanges(n),l=t.order,d=e.order,h=new m.UnivariateBezier(l),u=new m.UnivariateBezier(d);for(let f=0;f<s;f++)for(let s=0;s<o;s++)if(a[f].intersectsRangeXY(c[s])){const o=i[f].computeStrokeCountForOptions(),a=n[s].computeStrokeCountForOptions();o<a?this.dispatchBezierBezierStrokeFirst(i[f],t,o,n[s],e,a,u,!r):this.dispatchBezierBezierStrokeFirst(n[s],e,a,i[f],t,o,h,r)}}projectPoint(t,e=1){return this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyPoint3d(t,e):this._worldToLocalAffine?this._worldToLocalAffine.multiplyXYZW(t.x,t.y,t.z,e):h.Point4d.createFromPointAndWeight(t,e)}mapNPCPlaneToWorld(t,e){this._worldToLocalAffine?this._worldToLocalAffine.multiplyTransposeXYZW(t.x,t.y,t.z,t.w,e):this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyTransposePoint4d(t,e):t.clone(e)}dispatchSegmentBsplineCurve(t,e,r,i,n,s,o,a,c,l){const u=this.projectPoint(r),f=this.projectPoint(n),g=h.Point4d.createPlanePointPointZ(u,f);this.mapNPCPlaneToWorld(g,g);const p=[];a.appendPlaneIntersectionPoints(g,p);for(const h of p){const r=h.fraction,n=h.point,g=this.projectPoint(n),p=d.SmallSystem.lineSegment3dHXYClosestPointUnbounded(u,f,g);void 0!==p&&this.acceptFraction(e,p,o)&&this.acceptFraction(c,r,c)&&this.recordPointWithLocalFractions(p,t,i,s,r,a,0,1,l)}}dispatchLineStringBSplineCurve(t,e,r,i,n){const s=t.numPoints();if(s>1){const o=1/(s-1);let a,c;a=0;const l=CurveCurveIntersectXY._workPointA0,d=CurveCurveIntersectXY._workPointA1;t.pointAt(0,l);for(let h=1;h<s;h++,l.setFrom(d),a=c)t.pointAt(h,d),c=h*o,this.dispatchSegmentBsplineCurve(t,1===h&&e,l,a,d,c,h+1===s&&e,r,i,n)}}computeSegmentLineString(t,e,r,i,n){const s=t.point0Ref,o=t.point1Ref,a=CurveCurveIntersectXY._workPointBB0,c=CurveCurveIntersectXY._workPointBB1,l=r.numPoints();if(l>1){const d=1/(l-1);let h,u;h=0,r.pointAt(0,a);for(let f=1;f<l;f++,a.setFrom(c),h=u)r.pointAt(f,c),u=f*d,this.dispatchSegmentSegment(t,e,s,0,o,1,e,r,1===f&&i,a,h,c,u,f+1===l&&i,n)}}computeArcLineString(t,e,r,i,n){const s=CurveCurveIntersectXY._workPointBB0,o=CurveCurveIntersectXY._workPointBB1,a=r.numPoints();if(a>1){const c=1/(a-1);let l,d;l=0,r.pointAt(0,s);for(let h=1;h<a;h++,s.setFrom(o),l=d)r.pointAt(h,o),d=h*c,this.dispatchSegmentArc(r,1===h&&i,s,l,o,d,h+1===a&&i,t,e,e,!n)}}static setTransformedWorkPoints(t,e,r,i,n){t.multiplyPoint3d(e,this._workPointA0),t.multiplyPoint3d(r,this._workPointA1),t.multiplyPoint3d(i,this._workPointB0),t.multiplyPoint3d(n,this._workPointB1)}handleLineSegment3d(t){if(this._geometryB instanceof o.LineSegment3d){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,e,this._extendB,e.point0Ref,0,e.point1Ref,1,this._extendB,!1)}else this._geometryB instanceof a.LineString3d?this.computeSegmentLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof f.Arc3d?this.dispatchSegmentArc(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,this._extendB,!1):this._geometryB instanceof p.BSplineCurve3d&&this.dispatchSegmentBsplineCurve(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,!1)}handleLineString3d(t){if(this._geometryB instanceof a.LineString3d){const e=this._geometryB,r=CurveCurveIntersectXY._workPointAA0,i=CurveCurveIntersectXY._workPointAA1,n=CurveCurveIntersectXY._workPointBB0,s=CurveCurveIntersectXY._workPointBB1,o=t.numPoints(),a=e.numPoints();if(o>1&&a>1){t.pointAt(0,r);const c=1/(o-1),l=1/(a-1);let d,h,u,f=0;const g=this._extendA,p=this._extendB;t.pointAt(0,r);for(let m=1;m<o;m++,r.setFrom(i),f=h){h=m*c,d=0,t.pointAt(m,i),e.pointAt(0,n);for(let c=1;c<a;c++,n.setFrom(s),d=u)e.pointAt(c,s),u=c*l,this.dispatchSegmentSegment(t,1===m&&g,r,f,i,h,m+1===o&&g,e,1===c&&p,n,d,s,u,c+1===a&&p,!1)}}}else this._geometryB instanceof o.LineSegment3d?this.computeSegmentLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof f.Arc3d?this.computeArcLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof p.BSplineCurve3d&&this.dispatchLineStringBSplineCurve(t,this._extendA,this._geometryB,this._extendB,!1)}handleArc3d(t){this._geometryB instanceof o.LineSegment3d?this.dispatchSegmentArc(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,this._extendA,!0):this._geometryB instanceof a.LineString3d?this.computeArcLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof f.Arc3d?this.dispatchArcArc(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof p.BSplineCurve3d&&this.dispatchArcBsplineCurve3d(t,this._extendA,this._geometryB,this._extendB,!1)}handleBSplineCurve3d(t){this._geometryB instanceof o.LineSegment3d?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,!0):this._geometryB instanceof a.LineString3d?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof f.Arc3d?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof p.BSplineCurve3dBase&&this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1)}handleBSplineCurve3dH(t){}}e.CurveCurveIntersectXY=CurveCurveIntersectXY,CurveCurveIntersectXY._workVector2dA=c.Vector2d.create(),CurveCurveIntersectXY._workPointA0H=h.Point4d.create(),CurveCurveIntersectXY._workPointA1H=h.Point4d.create(),CurveCurveIntersectXY._workPointB0H=h.Point4d.create(),CurveCurveIntersectXY._workPointB1H=h.Point4d.create(),CurveCurveIntersectXY._workPointAA0=l.Point3d.create(),CurveCurveIntersectXY._workPointAA1=l.Point3d.create(),CurveCurveIntersectXY._workPointBB0=l.Point3d.create(),CurveCurveIntersectXY._workPointBB1=l.Point3d.create(),CurveCurveIntersectXY._workPointA0=l.Point3d.create(),CurveCurveIntersectXY._workPointA1=l.Point3d.create(),CurveCurveIntersectXY._workPointB0=l.Point3d.create(),CurveCurveIntersectXY._workPointB1=l.Point3d.create()},"./lib/curve/CurveCurveIntersectXYZ.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/GeometryHandler.js"),n=r("./lib/curve/CurveLocationDetail.js"),s=r("./lib/Geometry.js"),o=r("./lib/curve/LineSegment3d.js"),a=r("./lib/curve/LineString3d.js"),c=r("./lib/geometry3d/Point2dVector2d.js"),l=r("./lib/geometry3d/Point3dVector3d.js"),d=r("./lib/numerics/Polynomials.js"),h=r("./lib/curve/Arc3d.js"),u=r("./lib/bspline/BSplineCurve.js"),f=r("./lib/curve/CurveCurveIntersectXY.js"),g=r("./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");class CurveCurveIntersectXYZ extends i.NullGeometryHandler{constructor(t,e,r,i){super(),this._extendA=e,this._geometryB=r,this._extendB=i,this.reinitialize()}reinitialize(){this._results=new f.CurveLocationDetailArrayPair}grabResults(t=!1){const e=this._results;return t&&this.reinitialize(),e}acceptFraction(t,e,r){return!(!t&&e<0)&&!(!r&&e>1)}recordPointWithLocalFractions(t,e,r,i,o,a,c,l,d){const h=s.Geometry.interpolate(r,t,i),u=s.Geometry.interpolate(c,o,l),f=this._results.dataA.length;if(f>0){const t=this._results.dataA[f-1].fraction,e=this._results.dataB[f-1].fraction;if(d){if(s.Geometry.isAlmostEqualNumber(t,u)&&s.Geometry.isAlmostEqualNumber(e,h))return}else if(s.Geometry.isAlmostEqualNumber(t,h)&&s.Geometry.isAlmostEqualNumber(e,u))return}const g=e.fractionToPoint(h),p=a.fractionToPoint(u);if(!g.isAlmostEqualMetric(p))return;const m=n.CurveLocationDetail.createCurveFractionPoint(e,h,g);m.setIntervalRole(n.CurveIntervalRole.isolated);const y=n.CurveLocationDetail.createCurveFractionPoint(a,u,p);y.setIntervalRole(n.CurveIntervalRole.isolated),d?(this._results.dataA.push(y),this._results.dataB.push(m)):(this._results.dataA.push(m),this._results.dataB.push(y))}computeSegmentSegment3D(t,e,r,i,n,s,o,a,c,l,h,u,f,g,p){const m=CurveCurveIntersectXYZ._workVector2dA;d.SmallSystem.lineSegment3dClosestApproachUnbounded(r,n,l,u,m)&&this.acceptFraction(e,m.x,o)&&this.acceptFraction(c,m.y,g)&&this.recordPointWithLocalFractions(m.x,t,i,s,m.y,a,h,f,p)}dispatchSegmentSegment(t,e,r,i,n,s,o,a,c,l,d,h,u,f,g){this.computeSegmentSegment3D(t,e,r,i,n,s,o,a,c,l,d,h,u,f,g)}createPlaneWithPreferredPerpendicular(t,e,r,i,n){const s=e.magnitudeSquared(),o=i.magnitudeSquared(),a=Math.abs(e.dotProduct(i)),c=e.unitCrossProduct(a<r*s*o?i:n);if(c)return g.Plane3dByOriginAndUnitNormal.create(t,c)}dispatchSegmentArc(t,e,r,i,n,s,o,a,c,h,u){const f=l.Vector3d.createStartEnd(r,n),g=this.createPlaneWithPreferredPerpendicular(r,f,.9,a.perpendicularVector,a.vector0);if(void 0!==g){const l=[];let f,p;a.appendPlaneIntersectionPoints(g,l);for(const g of l)this.acceptFraction(c,g.fraction,h)&&void 0!==(f=d.SmallSystem.lineSegment3dXYClosestPointUnbounded(r,n,g.point))&&(p=r.interpolate(f,n,p)).isAlmostEqualMetric(g.point)&&this.acceptFraction(e,f,o)&&this.recordPointWithLocalFractions(f,t,i,s,g.fraction,a,0,1,u)}}dispatchArcArcInPlane(t,e,r,i,n){const s=t.otherArcAsLocalVectors(r);if(void 0!==s){const o=[],a=[];d.TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(s.center.x,s.center.y,1,s.vector0.x,s.vector0.y,0,s.vector90.x,s.vector90.y,0,o,a);for(let s=0;s<o.length;s++){const c=t.sweep.radiansToSignedPeriodicFraction(a[s]),l=t.sweep.radiansToSignedPeriodicFraction(o[s]);this.acceptFraction(e,c,e)&&this.acceptFraction(i,l,i)&&this.recordPointWithLocalFractions(c,t,0,1,l,r,0,1,n)}}}dispatchArcArc(t,e,r,i,n){const s=g.Plane3dByOriginAndUnitNormal.create(t.center,t.perpendicularVector),o=g.Plane3dByOriginAndUnitNormal.create(r.center,r.perpendicularVector);if(void 0!==s&&void 0!==o)if(s.getNormalRef().isParallelTo(o.getNormalRef()))s.isPointInPlane(o.getOriginRef())&&o.isPointInPlane(s.getOriginRef())&&this.dispatchArcArcInPlane(t,e,r,i,n);else{const a=[];r.appendPlaneIntersectionPoints(s,a);const c=[];t.appendPlaneIntersectionPoints(o,c);for(const s of a)for(const o of c)o.point.isAlmostEqual(s.point)&&this.acceptFraction(e,o.fraction,e)&&this.acceptFraction(i,s.fraction,i)&&this.recordPointWithLocalFractions(o.fraction,t,0,1,s.fraction,r,0,1,n)}}dispatchArcBsplineCurve3d(t,e,r,i,n){}dispatchBSplineCurve3dBSplineCurve3d(t,e,r){}dispatchSegmentBsplineCurve(t,e,r,i,n,s,o,a,c,l){}dispatchLineStringBSplineCurve(t,e,r,i,n){}computeSegmentLineString(t,e,r,i,n){const s=t.point0Ref,o=t.point1Ref,a=CurveCurveIntersectXYZ._workPointBB0,c=CurveCurveIntersectXYZ._workPointBB1,l=r.numPoints();if(l>1){const d=1/(l-1);let h,u;h=0,r.pointAt(0,a);for(let f=1;f<l;f++,a.setFrom(c),h=u)r.pointAt(f,c),u=f*d,this.dispatchSegmentSegment(t,e,s,0,o,1,e,r,1===f&&i,a,h,c,u,f+1===l&&i,n)}}computeArcLineString(t,e,r,i,n){const s=CurveCurveIntersectXYZ._workPointBB0,o=CurveCurveIntersectXYZ._workPointBB1,a=r.numPoints();if(a>1){const c=1/(a-1);let l,d;l=0,r.pointAt(0,s);for(let h=1;h<a;h++,s.setFrom(o),l=d)r.pointAt(h,o),d=h*c,this.dispatchSegmentArc(r,1===h&&i,s,l,o,d,h+1===a&&i,t,e,e,!n)}}handleLineSegment3d(t){if(this._geometryB instanceof o.LineSegment3d){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,e,this._extendB,e.point0Ref,0,e.point1Ref,1,this._extendB,!1)}else this._geometryB instanceof a.LineString3d?this.computeSegmentLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof h.Arc3d?this.dispatchSegmentArc(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,this._extendB,!1):this._geometryB instanceof u.BSplineCurve3d&&this.dispatchSegmentBsplineCurve(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,!1)}handleLineString3d(t){if(this._geometryB instanceof a.LineString3d){const e=this._geometryB,r=CurveCurveIntersectXYZ._workPointAA0,i=CurveCurveIntersectXYZ._workPointAA1,n=CurveCurveIntersectXYZ._workPointBB0,s=CurveCurveIntersectXYZ._workPointBB1,o=t.numPoints(),a=e.numPoints();if(o>1&&a>1){t.pointAt(0,r);const c=1/(o-1),l=1/(a-1);let d,h,u,f=0;const g=this._extendA,p=this._extendB;t.pointAt(0,r);for(let m=1;m<o;m++,r.setFrom(i),f=h){h=m*c,d=0,t.pointAt(m,i),e.pointAt(0,n);for(let c=1;c<a;c++,n.setFrom(s),d=u)e.pointAt(c,s),u=c*l,this.dispatchSegmentSegment(t,1===m&&g,r,f,i,h,m+1===o&&g,e,1===c&&p,n,d,s,u,c+1===a&&p,!1)}}}else this._geometryB instanceof o.LineSegment3d?this.computeSegmentLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof h.Arc3d?this.computeArcLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof u.BSplineCurve3d&&this.dispatchLineStringBSplineCurve(t,this._extendA,this._geometryB,this._extendB,!1)}handleArc3d(t){this._geometryB instanceof o.LineSegment3d?this.dispatchSegmentArc(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,this._extendA,!0):this._geometryB instanceof a.LineString3d?this.computeArcLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof h.Arc3d?this.dispatchArcArc(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof u.BSplineCurve3d&&this.dispatchArcBsplineCurve3d(t,this._extendA,this._geometryB,this._extendB,!1)}handleBSplineCurve3d(t){this._geometryB instanceof o.LineSegment3d?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,!0):this._geometryB instanceof a.LineString3d?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof h.Arc3d?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof u.BSplineCurve3dBase&&this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1)}handleBSplineCurve3dH(t){}}e.CurveCurveIntersectXYZ=CurveCurveIntersectXYZ,CurveCurveIntersectXYZ._workVector2dA=c.Vector2d.create(),CurveCurveIntersectXYZ._workPointAA0=l.Point3d.create(),CurveCurveIntersectXYZ._workPointAA1=l.Point3d.create(),CurveCurveIntersectXYZ._workPointBB0=l.Point3d.create(),CurveCurveIntersectXYZ._workPointBB1=l.Point3d.create()},"./lib/curve/CurveExtendMode.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js");var n;!function(t){t[t.None=0]="None",t[t.OnTangent=1]="OnTangent",t[t.OnCurve=2]="OnCurve"}(n=e.CurveExtendMode||(e.CurveExtendMode={}));class CurveExtendOptions{static resolveVariantCurveExtendParameterToCurveExtendMode(t,e){return!1===t?n.None:!0===t?n.OnCurve:Array.isArray(t)?t[e]:t}static correctFraction(t,e){if(e<0){CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(t,0)===n.None&&(e=0)}else if(e>1){CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(t,1)===n.None&&(e=1)}return e}static resolveRadiansToSweepFraction(t,e,r){let s=r.radiansToSignedPeriodicFraction(e);if(!r.isRadiansInSweep(e)){const o=r.fractionPeriod(),a=CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(t,0),c=CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(t,1);a!==n.None?c!==n.None?s=r.radiansToSignedPeriodicFraction(e):s>1&&(s-=o):c!==n.None?s<0&&(s+=o):s=i.Geometry.clamp(s,0,1)}return s}}e.CurveExtendOptions=CurveExtendOptions},"./lib/curve/CurveFactory.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/Arc3d.js"),n=r("./lib/curve/LineString3d.js"),s=r("./lib/curve/LineSegment3d.js"),o=r("./lib/geometry3d/Point3dArrayCarrier.js"),a=r("./lib/curve/Path.js"),c=r("./lib/Geometry.js");e.CurveFactory=class CurveFactory{static addPartialSegment(t,e,r,i,n,o){(e||o>n)&&(void 0===r||void 0===i||c.Geometry.isAlmostEqualNumber(n,o)||t.tryAddChild(s.LineSegment3d.create(r.interpolate(n,i),r.interpolate(o,i))))}static createFilletsInLineString(t,e,r=!0){if(Array.isArray(t))return this.createFilletsInLineString(new o.Point3dArrayCarrier(t),e,r);if(t instanceof n.LineString3d)return this.createFilletsInLineString(t.packedPoints,e,r);const s=t.length;if(s<=1)return;const c=t.getPoint3dAtCheckedPointIndex(0),l=t.getPoint3dAtCheckedPointIndex(1),d=[];d.push({fraction10:0,fraction12:0,point:c.clone()});for(let n=1;n+1<s;n++){const r=t.getPoint3dAtCheckedPointIndex(n+1);d.push(i.Arc3d.createFilletArc(c,l,r,e)),c.setFromPoint3d(l),l.setFromPoint3d(r)}if(d.push({fraction10:0,fraction12:0,point:l.clone()}),!r){for(let t=1;t+1<s;t++){const e=d[t];(e.fraction10>1||e.fraction12>1||1-e.fraction10<d[t-1].fraction12||e.fraction12>1-d[t+1].fraction10)&&(e.fraction10=0,e.fraction12=0,d[t].arc=void 0)}for(let t=1;t<s;t++){const e=d[t-1],r=d[t];if(e.fraction12>1-r.fraction10){const i=e.fraction12>r.fraction12?r:e;i.fraction10=0,i.fraction12=0,d[t].arc=void 0}}}const h=a.Path.create();this.addPartialSegment(h,r,d[0].point,d[1].point,d[0].fraction12,1-d[1].fraction10);for(let i=1;i+1<t.length;i++){const t=d[i],e=d[i+1];h.tryAddChild(t.arc),this.addPartialSegment(h,r,t.point,e.point,t.fraction12,1-e.fraction10)}return h}static appendToArcInPlace(t,e,r=!1){if(t.center.isAlmostEqual(e.center)){const i=c.Geometry.split3WaySign(t.sweep.sweepRadians*e.sweep.sweepRadians,-1,0,1),n=t.angleToPointAndDerivative(t.sweep.fractionToAngle(1));t.sweep.sweepRadians<0&&n.direction.scaleInPlace(-1);const s=e.angleToPointAndDerivative(e.sweep.fractionToAngle(0));if(e.sweep.sweepRadians<0&&s.direction.scaleInPlace(-1),n.isAlmostEqual(s))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians+i*e.sweep.sweepRadians),!0;if(r&&(s.direction.scaleInPlace(-1),n.isAlmostEqual(s)))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians-i*e.sweep.sweepRadians),!0}return!1}}},"./lib/curve/CurveLocationDetail.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/Geometry.js");var s,o;function a(t,e){if(t)return t.clone(e)}!function(t){t[t.isolated=0]="isolated",t[t.isolatedAtVertex=1]="isolatedAtVertex",t[t.intervalStart=10]="intervalStart",t[t.intervalInterior=11]="intervalInterior",t[t.intervalEnd=12]="intervalEnd"}(s=e.CurveIntervalRole||(e.CurveIntervalRole={})),function(t){t[t.error=0]="error",t[t.success=1]="success",t[t.stoppedAtBoundary=2]="stoppedAtBoundary"}(o=e.CurveSearchStatus||(e.CurveSearchStatus={}));class CurveLocationDetail{constructor(){this.pointQ=i.Point3d.createZero(),this.fraction=0,this.point=i.Point3d.createZero(),this.a=0}setIntervalRole(t){this.intervalRole=t}get isIsolated(){return void 0===this.intervalRole||this.intervalRole===s.isolated||this.intervalRole===s.isolatedAtVertex}clone(t){return t===this?t:((t=t||new CurveLocationDetail).curve=this.curve,t.fraction=this.fraction,t.point.setFromPoint3d(this.point),t.vectorInCurveLocationDetail=a(this.vectorInCurveLocationDetail,t.vectorInCurveLocationDetail),t.a=this.a,t.curveSearchStatus=this.curveSearchStatus,t)}setFP(t,e,r,i=0){this.fraction=t,this.point.setFrom(e),this.vectorInCurveLocationDetail=a(r,this.vectorInCurveLocationDetail),this.a=i}setFR(t,e,r=0){return this.setFP(t,e.origin,e.direction,r)}setCurve(t){this.curve=t}setDistanceTo(t){this.a=this.point.distance(t)}static create(t,e){return(e=e||new CurveLocationDetail).curve=t,e}static createCurveFractionPoint(t,e,r,i){return(i=i||new CurveLocationDetail).curve=t,i.fraction=e,i.point.setFromPoint3d(r),i.vectorInCurveLocationDetail=void 0,i.a=0,i.curveSearchStatus=void 0,i}static createRayFractionPoint(t,e,r,i){return(i=i||new CurveLocationDetail).fraction=e,i.ray=t,i.point.setFromPoint3d(r),i}static createCurveFractionPointDistanceCurveSearchStatus(t,e,r,i,n,s){return(s=s||new CurveLocationDetail).curve=t,s.fraction=e,s.point.setFromPoint3d(r),s.vectorInCurveLocationDetail=void 0,s.a=i,s.curveSearchStatus=n,s}static createConditionalMoveSignedDistance(t,e,r,i,s,a){let c=s,l=o.success;return t||n.Geometry.isIn01(i)||(i<0?(c=-e.curveLengthBetweenFractions(r,0),i=0,l=o.stoppedAtBoundary):i>1&&(i=1,c=e.curveLengthBetweenFractions(r,1),l=o.stoppedAtBoundary)),(a=a||new CurveLocationDetail).curve=e,a.fraction=i,a.point=e.fractionToPoint(i,a.point),a.vectorInCurveLocationDetail=void 0,a.a=c,a.curveSearchStatus=l,a}static createCurveEvaluatedFraction(t,e,r){return(r=r||new CurveLocationDetail).curve=t,r.fraction=e,r.point=t.fractionToPoint(e),r.vectorInCurveLocationDetail=void 0,r.curveSearchStatus=void 0,r.a=0,r}static createCurveFractionPointDistance(t,e,r,i,n){return(n=n||new CurveLocationDetail).curve=t,n.fraction=e,n.point.setFromPoint3d(r),n.vectorInCurveLocationDetail=void 0,n.a=i,n.curveSearchStatus=void 0,n}updateIfCloserCurveFractionPointDistance(t,e,r,i){return!(this.a<i)&&(CurveLocationDetail.createCurveFractionPointDistance(t,e,r,i,this),!0)}}e.CurveLocationDetail=CurveLocationDetail,function(t){t[t.Intersection=0]="Intersection",t[t.PerpendicularChord=1]="PerpendicularChord",t[t.CoincidentGeometry=2]="CoincidentGeometry",t[t.ParallelGeometry=3]="ParallelGeometry"}(e.CurveCurveApproachType||(e.CurveCurveApproachType={}));class CurveLocationDetailPair{constructor(t,e){this.detailA=t||new CurveLocationDetail,this.detailB=e||new CurveLocationDetail}static createCapture(t,e,r){return(r=r||new CurveLocationDetailPair).detailA=t,r.detailB=e,r}clone(t){return(t=t||new CurveLocationDetailPair).detailA=this.detailA.clone(),t.detailB=this.detailB.clone(),t.approachType=this.approachType,t}}e.CurveLocationDetailPair=CurveLocationDetailPair},"./lib/curve/CurvePrimitive.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/numerics/BezierPolynomials.js"),s=r("./lib/geometry3d/Point3dVector3d.js"),o=r("./lib/geometry3d/Transform.js"),a=r("./lib/geometry3d/Matrix3d.js"),c=r("./lib/geometry3d/Ray3d.js"),l=r("./lib/numerics/Newton.js"),d=r("./lib/numerics/Quadrature.js"),h=r("./lib/curve/CurveLocationDetail.js"),u=r("./lib/curve/GeometryQuery.js"),f=r("./lib/curve/Query/StrokeCountMap.js"),g=r("./lib/curve/CurveExtendMode.js");class CurvePrimitive extends u.GeometryQuery{constructor(){super(),this.geometryCategory="curvePrimitive"}fractionToPointAndUnitTangent(t,e){const r=this.fractionToPointAndDerivative(t,e);return r.trySetDirectionMagnitudeInPlace(1),r}fractionToFrenetFrame(t,e){const r=this.fractionToPointAnd2Derivatives(t);if(!r)return;let n=a.Matrix3d.createRigidFromColumns(r.vectorU,r.vectorV,i.AxisOrder.XYZ);if(n)return o.Transform.createRefs(r.origin,n,e);const s=a.Matrix3d.createPerpendicularVectorFavorXYPlane(r.vectorU,r.vectorV);return(n=a.Matrix3d.createRigidFromColumns(r.vectorU,s,i.AxisOrder.XYZ))?o.Transform.createRefs(r.origin,n,e):void 0}fractionAndDistanceToPointOnTangent(t,e){return this.fractionToPointAndUnitTangent(t).fractionToPoint(e)}curveLength(){const t=new CurveLengthContext;return this.emitStrokableParts(t),t.getSum()}curveLengthBetweenFractions(t,e){if(t===e)return 0;if(void 0!==this.getFractionToDistanceScale()){const r=this.curveLength();return Math.abs((e-t)*r)}const r=new CurveLengthContext(t,e);return this.emitStrokableParts(r),Math.abs(r.getSum())}curveLengthWithFixedIntervalCountQuadrature(t,e,r,i=5){if(t>e){const r=t;t=e,e=r}const n=new CurveLengthContext(t,e,i);return n.announceIntervalForUniformStepStrokes(this,r,t,e),Math.abs(n.getSum())}moveSignedDistanceFromFraction(t,e,r,n){if(void 0!==this.getFractionToDistanceScale()){const s=this.curveLength(),o=i.Geometry.conditionalDivideFraction(e,s);return void 0===o?h.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,h.CurveSearchStatus.error):h.CurveLocationDetail.createConditionalMoveSignedDistance(r,this,t,t+o,e,n)}return this.moveSignedDistanceFromFractionGeneric(t,e,r,n)}moveSignedDistanceFromFractionGeneric(t,e,r,n){const s=e>0?1:0,o=Math.abs(e),a=e<0?-1:1,l=this.curveLengthBetweenFractions(t,s);if(l<o&&!r)return h.CurveLocationDetail.createConditionalMoveSignedDistance(r,this,t,s,e,n);const d=o/l;let u=i.Geometry.interpolate(t,d,s),f=t,g=0;const p=1e-12*l;let m=0;const y=c.Ray3d.createXAxis();for(let i=0;i<10;i++){const t=this.curveLengthBetweenFractions(f,u),e=g+(u>f?a:-a)*t,r=o-e;if(Math.abs(r)<p){if(++m>1)break}else m=0;if(this.fractionToPointAndDerivative(u,y),(f=u)===(u=f+a*r/y.direction.magnitude())){m=100;break}g=e}return m>1?h.CurveLocationDetail.createConditionalMoveSignedDistance(!1,this,t,u,e,n):((n=h.CurveLocationDetail.createCurveEvaluatedFraction(this,t,n)).a=0,n.curveSearchStatus=h.CurveSearchStatus.error,n)}get isExtensibleFractionSpace(){return!1}closestPoint(t,e){const r=new ClosestPointStrokeHandler(t,e);return this.emitStrokableParts(r),r.claimResult()}announceClipIntervals(t,e){return!1}clonePartialCurve(t,e){}getFractionToDistanceScale(){}appendPlaneIntersectionPoints(t,e){const r=new AppendPlaneIntersectionStrokeHandler(t,e),i=e.length;return this.emitStrokableParts(r),e.length-i}static snapAndRestrictDetails(t,e=!0,r=!1,n=i.Geometry.smallAngleRadians,o=i.Geometry.smallMetricDistance){const a=t.length;let c=0;const l=s.Point3d.create(),d=s.Point3d.create();let u;for(let s=0;s<a;s++){u=void 0;const a=t[s];let f=a.fraction,g=e||i.Geometry.isIn01(f);a.curve&&(a.curve.startPoint(l),a.curve.endPoint(d)),n>0&&(Math.abs(f)<n&&(f=0,g=!0,a.intervalRole=h.CurveIntervalRole.isolatedAtVertex,u=l),Math.abs(f-1)<n&&(f=1,g=!0,a.intervalRole=h.CurveIntervalRole.isolatedAtVertex,u=d,a.curve&&(u=a.curve.startPoint(d)))),o>0&&void 0!==a.curve&&(a.point.distance(l)<=o?(f=0,a.intervalRole=h.CurveIntervalRole.isolatedAtVertex,u=l):a.point.distance(d)<=o&&(f=1,a.intervalRole=h.CurveIntervalRole.isolatedAtVertex,u=d)),g&&(r&&(a.fraction=f,void 0!==u&&a.point.setFrom(u)),c<s&&(t[c]=a),c++)}c<a&&(t.length=c)}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}computeAndAttachRecursiveStrokeCounts(t,e){const r=this.computeStrokeCountForOptions(t),i=this.curveLength();CurvePrimitive.installStrokeCountMap(this,f.StrokeCountMap.createWithCurvePrimitive(this,r,i,0,i),e)}addMappedStrokesToLineString3D(t,e){const r=e.numPoints();if(t.primitive&&t.primitive===this&&t.numStroke>0)for(let i=0;i<=t.numStroke;i++){const r=i/t.numStroke;e.appendFractionToPoint(this,r)}return e.numPoints()-r}static installStrokeCountMap(t,e,r){r&&r.addToCountAndLength(e.numStroke,e.curveLength),t.strokeData=e}}e.CurvePrimitive=CurvePrimitive;class NewtonRotRStrokeHandler extends l.NewtonEvaluatorRtoR{constructor(){super(),this._parentCurvePrimitive=void 0}startParentCurvePrimitive(t){this._parentCurvePrimitive=t}endParentCurvePrimitive(t){this._parentCurvePrimitive=void 0}}class AppendPlaneIntersectionStrokeHandler extends NewtonRotRStrokeHandler{constructor(t,e){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._derivativeB=0,this._numThisCurve=0,this._plane=t,this._intersections=e,this.startCurvePrimitive(void 0),this._ray=c.Ray3d.createZero(),this._newtonSolver=new l.Newton1dUnboundedApproximateDerivative(this)}effectiveCurve(){return this._parentCurvePrimitive?this._parentCurvePrimitive:this._curve}get getDerivativeB(){return this._derivativeB}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,r,n){this.startCurvePrimitive(t),e<1&&(e=1);const s=1/e;for(let o=0;o<=e;o++){const e=i.Geometry.interpolate(r,o*s,n);t.fractionToPointAndDerivative(e,this._ray),this.announcePointTangent(this._ray.origin,e,this._ray.direction)}}announceSegmentInterval(t,e,r,s,o,a){const c=this._plane.altitude(e),l=this._plane.altitude(r);if(c*l>0)return;const d=n.Order2Bezier.solveCoffs(c,l);if(void 0!==d){const t=i.Geometry.interpolate(o,d,a);this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX())}}announceSolutionFraction(t){const e=this.effectiveCurve();e&&(this._ray=e.fractionToPointAndDerivative(t,this._ray),this._intersections.push(h.CurveLocationDetail.createCurveFractionPoint(e,t,this._ray.origin)))}evaluate(t){const e=this.effectiveCurve();return!!e&&(this.currentF=this._plane.altitude(e.fractionToPoint(t)),!0)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=i.Geometry.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e,r){this._functionB=this._plane.altitude(t),this._derivativeB=this._plane.velocity(r),this._fractionB=e}announcePointTangent(t,e,r){this.evaluateB(t,e,r),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB,this._fractionA=this._fractionB}}class CurveLengthContext{constructor(t=0,e=1,r=5){this.startCurvePrimitive(void 0),this._summedLength=0,this._ray=c.Ray3d.createZero(),t<e?(this._fraction0=t,this._fraction1=e):(this._fraction0=e,this._fraction1=t),this._gaussMapper=new d.GaussMapper(r)}tangentMagnitude(t){return this._ray=this._curve.fractionToPointAndDerivative(t,this._ray),this._ray.direction.magnitude()}getSum(){return this._summedLength}startCurvePrimitive(t){this._curve=t}startParentCurvePrimitive(t){}endParentCurvePrimitive(t){}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,r,n){if(r<this._fraction0&&(r=this._fraction0),n>this._fraction1&&(n=this._fraction1),n>r){this.startCurvePrimitive(t),e<1&&(e=1);const s=1/e;for(let t=1;t<=e;t++){const o=i.Geometry.interpolate(r,(t-1)*s,n),a=t===e?n:i.Geometry.interpolate(r,t*s,n),c=this._gaussMapper.mapXAndW(o,a);for(let t=0;t<c;t++)this._summedLength+=this._gaussMapper.gaussW[t]*this.tangentMagnitude(this._gaussMapper.gaussX[t])}}}announceSegmentInterval(t,e,r,i,n,s){const o=e.distance(r);if(this._fraction0<=n&&s<=this._fraction1)this._summedLength+=o;else{let t=n,e=s;t<this._fraction0&&(t=this._fraction0),e>this._fraction1&&(e=this._fraction1),e>t&&(this._summedLength+=o*(e-t)/(s-n))}}announcePointTangent(t,e,r){}}class ClosestPointStrokeHandler extends NewtonRotRStrokeHandler{constructor(t,e){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._numThisCurve=0,this._spacePoint=t,this._workPoint=s.Point3d.create(),this._workRay=c.Ray3d.createZero(),this._closestPoint=void 0,this._extend=e,this.startCurvePrimitive(void 0),this._newtonSolver=new l.Newton1dUnboundedApproximateDerivative(this)}claimResult(){if(this._closestPoint&&(this._newtonSolver.setX(this._closestPoint.fraction),this._curve=this._closestPoint.curve,this._newtonSolver.runIterations())){let t=this._newtonSolver.getX();t=g.CurveExtendOptions.correctFraction(this._extend,t),this.announceSolutionFraction(t)}return this._closestPoint}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,r,n){this.startCurvePrimitive(t),e<1&&(e=1);const s=1/e;for(let o=0;o<=e;o++){const e=i.Geometry.interpolate(r,o*s,n);t.fractionToPointAndDerivative(e,this._workRay),this.announceRay(e,this._workRay)}}announceCandidate(t,e,r){const i=this._spacePoint.distance(r);this._closestPoint&&i>this._closestPoint.a||(this._closestPoint=h.CurveLocationDetail.createCurveFractionPoint(t,e,r,this._closestPoint),this._closestPoint.a=i,void 0!==this._parentCurvePrimitive&&(this._closestPoint.curve=this._parentCurvePrimitive))}announceSegmentInterval(t,e,r,n,s,o){let a=this._spacePoint.fractionOfProjectionToLine(e,r,0);this._extend?(0!==s&&(a=Math.max(a,0)),1!==o&&(a=Math.min(a,1))):a=i.Geometry.clampToStartEnd(a,0,1),this._workPoint=e.interpolate(a,r);const c=i.Geometry.interpolate(s,a,o);this.announceCandidate(t,c,this._workPoint)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=i.Geometry.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e){this._functionB=e.dotProductToPoint(this._spacePoint),this._fractionB=t}announceSolutionFraction(t){this._curve&&this.announceCandidate(this._curve,t,this._curve.fractionToPoint(t))}evaluate(t){let e=this._curve;return this._parentCurvePrimitive&&(e=this._parentCurvePrimitive),!!e&&(this._workRay=e.fractionToPointAndDerivative(t,this._workRay),this.currentF=this._workRay.dotProductToPoint(this._spacePoint),!0)}announceRay(t,e){this.evaluateB(t,e),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB,this._fractionA=this._fractionB}announcePointTangent(t,e,r){this._workRay.set(t,r),this.announceRay(e,this._workRay)}}},"./lib/curve/CurveProcessor.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurvePrimitive.js");class RecursiveCurveProcessor{constructor(){}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){let r=0;for(const i of t.children)this.announceCurvePrimitive(i,r++)}announceLoop(t,e=-1){let r=0;for(const i of t.children)this.announceCurvePrimitive(i,r++)}announceParityRegion(t,e=-1){let r=0;for(const i of t.children)this.announceLoop(i,r++)}announceUnionRegion(t,e=-1){let r=0;for(const i of t.children)i.announceToCurveProcessor(this,r++)}announceBagOfCurves(t,e=-1){for(const r of t.children)r instanceof i.CurvePrimitive?this.announceCurvePrimitive(r):r.announceToCurveProcessor(this)}}e.RecursiveCurveProcessor=RecursiveCurveProcessor;e.RecursiveCurveProcessorWithStack=class RecursiveCurveProcessorWithStack extends RecursiveCurveProcessor{constructor(){super(),this._stack=[]}enter(t){this._stack.push(t)}leave(){return this._stack.pop()}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){this.enter(t),super.announcePath(t,e),this.leave()}announceLoop(t,e=-1){this.enter(t),super.announceLoop(t,e),this.leave()}announceParityRegion(t,e=-1){this.enter(t);let r=0;for(const i of t.children)this.announceLoop(i,r++);this.leave()}announceUnionRegion(t,e=-1){this.enter(t),super.announceUnionRegion(t,e),this.leave()}announceBagOfCurves(t,e=-1){this.enter(t);let r=0;for(const n of t.children)n instanceof i.CurvePrimitive?this.announceCurvePrimitive(n,r++):n.announceToCurveProcessor(this);this.leave()}}},"./lib/curve/CurveWireMomentsXYZ.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry4d/MomentData.js"),n=r("./lib/curve/CurvePrimitive.js"),s=r("./lib/curve/CurveCollection.js"),o=r("./lib/numerics/Quadrature.js"),a=r("./lib/Geometry.js");e.CurveWireMomentsXYZ=class CurveWireMomentsXYZ{constructor(t=5){this._activeMomentData=i.MomentData.create(),this._activeMomentData.needOrigin=!0,this._gaussMapper=new o.GaussMapper(t)}get momentData(){return this._activeMomentData}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,r,i){this.startCurvePrimitive(t),e<1&&(e=1);const n=1/e;let s,o;for(let c=1;c<=e;c++){const l=a.Geometry.interpolate(r,(c-1)*n,i),d=c===e?i:a.Geometry.interpolate(r,c*n,i),h=this._gaussMapper.mapXAndW(l,d);for(let e=0;e<h;e++){o=this._gaussMapper.gaussX[e];const r=t.fractionToPointAndDerivative(o);s=this._gaussMapper.gaussW[e]*r.direction.magnitude(),this._activeMomentData.accumulateScaledOuterProduct(r.origin,s)}}}announceSegmentInterval(t,e,r,i,n,s){this._activeMomentData.accumulateLineMomentsXYZ(e,r)}announcePointTangent(t,e,r){}visitLeaves(t){if(t instanceof n.CurvePrimitive)t.emitStrokableParts(this);else if(t instanceof s.CurveCollection&&void 0!==t.children)for(const e of t.children)this.visitLeaves(e)}}},"./lib/curve/GeometryQuery.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js"),n=r("./lib/geometry3d/Transform.js");e.GeometryQuery=class GeometryQuery{range(t,e){e&&e.setNull();const r=e||i.Range3d.createNull();return this.extendRange(r,t),r}tryTranslateInPlace(t,e=0,r=0){return this.tryTransformInPlace(n.Transform.createTranslationXYZ(t,e,r))}get children(){}isAlmostEqual(t){if(this.isSameGeometryClass(t)){const e=this.children,r=t.children;if(e&&r){if(e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(!e[t].isAlmostEqual(r[t]))return!1;return!0}return!e&&!r}return!1}}},"./lib/curve/LineSegment3d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/numerics/BezierPolynomials.js"),s=r("./lib/geometry3d/Point3dVector3d.js"),o=r("./lib/geometry3d/Ray3d.js"),a=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),c=r("./lib/curve/CurvePrimitive.js"),l=r("./lib/curve/CurveExtendMode.js"),d=r("./lib/curve/CurveLocationDetail.js"),h=r("./lib/curve/LineString3d.js");class LineSegment3d extends c.CurvePrimitive{constructor(t,e){super(),this.curvePrimitiveType="lineSegment",this._point0=t,this._point1=e}isSameGeometryClass(t){return t instanceof LineSegment3d}get point0Ref(){return this._point0}get point1Ref(){return this._point1}get isExtensibleFractionSpace(){return!0}setRefs(t,e){this._point0=t,this._point1=e}set(t,e){this._point0=t.clone(),this._point1=e.clone()}setFrom(t){this._point0.setFrom(t._point0),this._point1.setFrom(t._point1)}startPoint(t){return t?(t.setFrom(this._point0),t):this._point0.clone()}endPoint(t){return t?(t.setFrom(this._point1),t):this._point1.clone()}fractionToPointAndDerivative(t,e){return(e=e||o.Ray3d.createZero()).direction.setStartEnd(this._point0,this._point1),this._point0.interpolate(t,this._point1,e.origin),e}fractionToPointAnd2Derivatives(t,e){return(e=e||a.Plane3dByOriginAndVectors.createXYPlane()).vectorU.setStartEnd(this._point0,this._point1),e.vectorV.set(0,0,0),this._point0.interpolate(t,this._point1,e.origin),e}clone(){return LineSegment3d.create(this._point0,this._point1)}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(t,e,r){return r?(r.set(t,e),r):new LineSegment3d(t.clone(),e.clone())}static createCapture(t,e){return new LineSegment3d(t,e)}static createXYXY(t,e,r,i,n=0,o){return o?(o._point0.set(t,e,n),o._point1.set(r,i,n),o):new LineSegment3d(s.Point3d.create(t,e,n),s.Point3d.create(r,i,n))}static createXYZXYZ(t,e,r,i,n,o,a){return a?(a._point0.set(t,e,r),a._point1.set(i,n,o),a):new LineSegment3d(s.Point3d.create(t,e,r),s.Point3d.create(i,n,o))}fractionToPoint(t,e){return this._point0.interpolate(t,this._point1,e)}curveLength(){return this._point0.distance(this._point1)}curveLengthBetweenFractions(t,e){return Math.abs(e-t)*this._point0.distance(this._point1)}quickLength(){return this.curveLength()}closestPoint(t,e,r){let i=t.fractionOfProjectionToLine(this._point0,this._point1,0);return i=l.CurveExtendOptions.correctFraction(e,i),(r=d.CurveLocationDetail.create(this,r)).fraction=i,this._point0.interpolate(i,this._point1,r.point),r.vectorInCurveLocationDetail=void 0,r.a=r.point.distance(t),r}reverseInPlace(){const t=this._point0;this._point0=this._point1,this._point1=t}tryTransformInPlace(t){return this._point0=t.multiplyPoint3d(this._point0,this._point0),this._point1=t.multiplyPoint3d(this._point1,this._point1),!0}isInPlane(t){return i.Geometry.isSmallMetricDistance(t.altitude(this._point0))&&i.Geometry.isSmallMetricDistance(t.altitude(this._point1))}appendPlaneIntersectionPoints(t,e){const r=t.altitude(this._point0),i=t.altitude(this._point1),s=n.Order2Bezier.solveCoffs(r,i);let o=0;if(void 0!==s){o++;const t=d.CurveLocationDetail.createCurveFractionPoint(this,s,this.fractionToPoint(s));t.intervalRole=d.CurveIntervalRole.isolated,e.push(t)}return o}extendRange(t,e){e?(t.extendTransformedPoint(e,this._point0),t.extendTransformedPoint(e,this._point1)):(t.extendPoint(this._point0),t.extendPoint(this._point1))}setFromJSON(t){if(!t)return this._point0.set(0,0,0),void this._point1.set(1,0,0);t.startPoint&&t.endPoint?(this._point0.setFromJSON(t.startPoint),this._point1.setFromJSON(t.endPoint)):Array.isArray(t)&&t.length>1&&(this._point0.setFromJSON(t[0]),this._point1.setFromJSON(t[1]))}getFractionToDistanceScale(){return this.curveLength()}toJSON(){return[this._point0.toJSON(),this._point1.toJSON()]}static fromJSON(t){const e=new LineSegment3d(s.Point3d.createZero(),s.Point3d.create());return e.setFromJSON(t),e}isAlmostEqual(t){if(t instanceof LineSegment3d){const e=t;return this._point0.isAlmostEqual(e._point0)&&this._point1.isAlmostEqual(e._point1)}return!1}emitStrokes(t,e){const r=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,r,0,1)}emitStrokableParts(t,e){t.startCurvePrimitive(this);const r=this.computeStrokeCountForOptions(e);t.announceSegmentInterval(this,this._point0,this._point1,r,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e=1;return t&&(t.maxEdgeLength&&(e=t.applyMaxEdgeLength(e,this.curveLength())),e=t.applyMinStrokesPerPrimitive(e)),e}dispatchToGeometryHandler(t){return t.handleLineSegment3d(this)}announceClipIntervals(t,e){return t.announceClippedSegmentIntervals(0,1,this._point0,this._point1,e?(t,r)=>e(t,r,this):void 0)}clonePartialCurve(t,e){return h.LineString3d.create(this.fractionToPoint(t),this.fractionToPoint(e))}}e.LineSegment3d=LineSegment3d},"./lib/curve/LineString3d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Angle.js"),s=r("./lib/geometry3d/Point3dVector3d.js"),o=r("./lib/geometry3d/Transform.js"),a=r("./lib/geometry3d/Matrix3d.js"),c=r("./lib/geometry3d/Ray3d.js"),l=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),d=r("./lib/geometry3d/GrowableFloat64Array.js"),h=r("./lib/geometry3d/GrowableXYZArray.js"),u=r("./lib/geometry3d/GrowableXYArray.js"),f=r("./lib/curve/CurvePrimitive.js"),g=r("./lib/curve/Query/StrokeCountMap.js"),p=r("./lib/curve/CurveLocationDetail.js"),m=r("./lib/curve/LineSegment3d.js"),y=r("./lib/geometry3d/PointStreaming.js");function P(t,e,r,i,n,s,o){const a=t.length;if(i>0){for(let c=r;c+1<a;c++)if(t.vectorIndexIndex(c,c+1,o),e.crossProduct(o,o),o.normalizeInPlace())return s.addScaledInPlace(o,n),!0}else{r+1>=a&&(r=a-2);for(let i=r;i>=0;i--)if(t.vectorIndexIndex(i,i+1,o),o.crossProduct(e,o),o.normalizeInPlace())return s.addScaledInPlace(o,n),!0}return!1}class LineString3d extends f.CurvePrimitive{constructor(t){super(),this.curvePrimitiveType="lineString",this._points=t||new h.GrowableXYZArray}isSameGeometryClass(t){return t instanceof LineString3d}get isExtensibleFractionSpace(){return!0}get points(){return this._points.getPoint3dArray()}get packedPoints(){return this._points}get fractions(){return this._fractions}get packedDerivatives(){return this._derivatives}get packedUVParams(){return this._uvParams}get packedSurfaceNormals(){return this._surfaceNormals}get normalIndices(){return this._normalIndices}get paramIndices(){return this._uvIndices}get pointIndices(){return this._pointIndices}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(...t){const e=new LineString3d;return e.addPoints(t),e}static createCapture(t){return new LineString3d(t)}static createXY(t,e,r=!1){const n=new LineString3d,s=n._points;for(const i of t)s.pushXYZ(i.x,i.y,e);if(r&&t.length>1){const t=s.distanceIndexIndex(0,s.length-1);if(void 0!==t&&0!==t&&i.Geometry.isSameCoordinate(0,t)){s.pop();const t=s.front();s.push(t)}}return n}addPoints(...t){this._points.pushFrom(t)}addSteppedPoints(t,e,r,i){this._points.addSteppedPoints(t,e,r,i)}addPoint(t){this._points.push(t)}addPointXYZ(t,e,r=0){this._points.pushXYZ(t,e,r)}addFraction(t){this._fractions||(this._fractions=new d.GrowableFloat64Array),this._fractions.push(t)}ensureEmptyFractions(){const t=this.numPoints();return this._fractions?(this._fractions.clear(),this._fractions.ensureCapacity(t),this._fractions):(this._fractions=new d.GrowableFloat64Array(t),this._fractions)}ensureEmptyUVParams(){const t=this.numPoints();return this._uvParams?(this._uvParams.clear(),this._uvParams.ensureCapacity(t),this._uvParams):(this._uvParams=new u.GrowableXYArray(t),this._uvParams)}ensureEmptySurfaceNormals(){const t=this.numPoints();return this._surfaceNormals?(this._surfaceNormals.clear(),this._surfaceNormals.ensureCapacity(t),this._surfaceNormals):(this._surfaceNormals=new h.GrowableXYZArray(t),this._surfaceNormals)}ensureEmptyDerivatives(){const t=this.numPoints();return this._derivatives?(this._derivatives.clear(),this._derivatives.ensureCapacity(t),this._derivatives):(this._derivatives=new h.GrowableXYZArray(t),this._derivatives)}ensureEmptyNormalIndices(){const t=this.numPoints();return this._normalIndices?(this._normalIndices.clear(),this._normalIndices.ensureCapacity(t),this._normalIndices):(this._normalIndices=new d.GrowableFloat64Array(t),this._normalIndices)}ensureEmptyUVIndices(){const t=this.numPoints();return this._uvIndices?(this._uvIndices.clear(),this._uvIndices.ensureCapacity(t),this._uvIndices):(this._uvIndices=new d.GrowableFloat64Array(t),this._uvIndices)}ensureEmptyPointIndices(){const t=this.numPoints();return this._pointIndices?(this._pointIndices.clear(),this._pointIndices.ensureCapacity(t),this._pointIndices):(this._pointIndices=new d.GrowableFloat64Array(t),this._pointIndices)}addUVParam(t){this._uvParams||(this._uvParams=new u.GrowableXYArray),this._uvParams.pushXY(t.x,t.y)}addUVParamAsUV(t,e){this._uvParams||(this._uvParams=new u.GrowableXYArray),this._uvParams.pushXY(t,e)}addDerivative(t){this._derivatives||(this._derivatives=new h.GrowableXYZArray),this._derivatives.push(t)}addSurfaceNormal(t){this._surfaceNormals||(this._surfaceNormals=new h.GrowableXYZArray),this._surfaceNormals.push(t)}addClosurePoint(){const t=this._points.distanceIndexIndex(0,this._points.length-1);void 0===t||i.Geometry.isSameCoordinate(t,0)||this._points.pushWrap(1)}popPoint(){this._points.pop()}computeUVFromXYZTransform(t){this._uvParams=u.GrowableXYArray.createFromGrowableXYZArray(this._points,t)}static createRectangleXY(t,e,r,i=!0){const n=LineString3d.create(),s=t.x,o=t.x+e,a=t.y,c=t.y+r,l=t.z;return n.addPointXYZ(s,a,l),n.addPointXYZ(o,a,l),n.addPointXYZ(o,c,l),n.addPointXYZ(s,c,l),i&&n.addClosurePoint(),n}static createRegularPolygonXY(t,e,r,i=!0){e<3&&(e=3);const s=LineString3d.create(),o=i?0:-1,a=Math.PI/e;let c,l,d;i||(r/=Math.cos(a));for(let h=0;h<e;h++)d=(o+2*h)*a,c=n.Angle.cleanupTrigValue(Math.cos(d)),l=n.Angle.cleanupTrigValue(Math.sin(d)),s.addPointXYZ(t.x+r*c,t.y+r*l,t.z);return s.addClosurePoint(),s}setFrom(t){this._points=t._points.clone(this._points),t._derivatives?this._derivatives=t._derivatives.clone(this._derivatives):this._derivatives=void 0,t._fractions?this._fractions=t._fractions.clone(!1):this._fractions=void 0,t._surfaceNormals?this._surfaceNormals=t._surfaceNormals.clone(this._surfaceNormals):this._surfaceNormals=void 0,t._uvParams?this._uvParams=t._uvParams.clone():this._uvParams=void 0}static createPoints(t){const e=new LineString3d;let r;for(r of t)e._points.push(r);return e}static createIndexedPoints(t,e,r=!1){const i=new LineString3d;for(const n of e)i._points.push(t[n]);return r&&e.length>1&&i._points.push(t[e[0]]),i}static createFloat64Array(t){const e=new LineString3d;for(let r=0;r+3<=t.length;r+=3)e._points.push(s.Point3d.create(t[r],t[r+1],t[r+2]));return e}clone(){const t=new LineString3d;return t.setFrom(this),t}setFromJSON(t){if(this._points.clear(),Array.isArray(t)){let e;for(e of t)this._points.push(s.Point3d.fromJSON(e))}}toJSON(){const t=[];let e=0;for(;this._points.isIndexValid(e);)t.push(this._points.getPoint3dAtUncheckedPointIndex(e).toJSON()),e++;return t}static fromJSON(t){const e=new LineString3d;return e.setFromJSON(t),e}fractionToPoint(t,e){const r=this._points.length;if(0===r)return s.Point3d.createZero();if(1===r)return s.Point3d.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0),e);const i=1/(r-1);if(t<=i)return this._points.interpolate(0,t/i,1,e);if(t+i>=1)return this._points.interpolate(r-1,(1-t)/i,r-2,e);const n=Math.floor(t/i);return this._points.interpolate(n,(t-n*i)/i,n+1,e)}fractionToPointAndDerivative(t,e){e=e||c.Ray3d.createZero();const r=this._points.length;if(r<=1)return e.direction.setZero(),1===r?e.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0)):e.origin.setZero(),e;const i=1/(r-1);if(t<=i)return e=e||c.Ray3d.createZero(),this._points.interpolate(0,t/i,1,e.origin),this._points.vectorIndexIndex(0,1,e.direction),e.direction.scaleInPlace(1/i),e;if(t+i>=1)return e=e||c.Ray3d.createZero(),this._points.interpolate(r-2,1-(1-t)/i,r-1,e.origin),this._points.vectorIndexIndex(r-2,r-1,e.direction),e.direction.scaleInPlace(1/i),e;e=e||c.Ray3d.createZero();const n=Math.floor(t/i),s=(t-n*i)/i;return this._points.interpolate(n,s,n+1,e.origin),this._points.vectorIndexIndex(n,n+1,e.direction),e.direction.scaleInPlace(1/i),e}fractionToPointAnd2Derivatives(t,e){const r=this.fractionToPointAndDerivative(t);return e=l.Plane3dByOriginAndVectors.createCapture(r.origin,r.direction,s.Vector3d.createZero(),e)}segmentIndexAndLocalFractionToGlobalFraction(t,e){const r=this._points.length-1;return r<1?0:(t+e)/r}fractionToFrenetFrame(t,e){const r=this._points.length;if(r<=1)return 1===r?o.Transform.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0),e):o.Transform.createIdentity(e);if(2===r)return o.Transform.createRefs(this._points.interpolate(0,t,1),a.Matrix3d.createRigidHeadsUp(this._points.vectorIndexIndex(0,1),i.AxisOrder.XYZ));const n=r-1,c=1/n;let l=0,d=0;t<=c?(d=t/c,l=0):t+c>=1?(l=r-2,d=1-(1-t)/c):d=t*n-(l=Math.floor(t/c));const h=this._points.interpolate(l,d,l+1),u=this._points.vectorIndexIndex(l,l+1),f=s.Vector3d.create(),g=s.Vector3d.create();0===l?P(this._points,u,l+1,1,1,f,g):l+2>=r?P(this._points,u,l-1,-1,1,f,g):(P(this._points,u,l-1,-1,1-d,f,g),P(this._points,u,l+1,1,d,f,g));const p=a.Matrix3d.createRigidFromColumns(f,u,i.AxisOrder.ZXY);return p?o.Transform.createOriginAndMatrix(h,p,e):o.Transform.createTranslation(h,e)}startPoint(){return 0===this._points.length?s.Point3d.createZero():this._points.getPoint3dAtUncheckedPointIndex(0)}pointAt(t,e){if(this._points.isIndexValid(t))return this._points.getPoint3dAtUncheckedPointIndex(t,e)}vectorBetween(t,e,r){return this._points.vectorIndexIndex(t,e,r)}derivativeAt(t,e){if(this._derivatives&&this._derivatives.isIndexValid(t))return this._derivatives.getVector3dAtCheckedVectorIndex(t,e)}surfaceNormalAt(t,e){if(this._surfaceNormals&&this._surfaceNormals.isIndexValid(t))return this._surfaceNormals.getVector3dAtCheckedVectorIndex(t,e)}numPoints(){return this._points.length}endPoint(){return 0===this._points.length?s.Point3d.createZero():this._points.getPoint3dAtUncheckedPointIndex(this._points.length-1)}reverseInPlace(){if(this._points.length>=2){let t=0,e=this._points.length-1,r=this._points.getPoint3dAtUncheckedPointIndex(0);for(;t<e;)r=this._points.getPoint3dAtUncheckedPointIndex(t),this._points.setAtCheckedPointIndex(t,this._points.getPoint3dAtUncheckedPointIndex(e)),this._points.setAtCheckedPointIndex(e,r),t++,e--}}tryTransformInPlace(t){return this._points.multiplyTransformInPlace(t),this._derivatives&&this._derivatives.multiplyMatrix3dInPlace(t.matrix),this._surfaceNormals&&this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),!0}curveLength(){return this._points.sumLengths()}curveLengthBetweenFractions(t,e){const r=this._points.length-1;if(e===t||r<1)return 0;if(e<t)return this.curveLengthBetweenFractions(e,t);const i=t*r,n=e*r,s=Math.max(1,Math.ceil(i)),o=Math.min(Math.floor(n),r-1),a=s-i,c=n-o;if(s>o)return Math.abs(n-i)*this._points.distanceIndexIndex(s-1,s);{let t=a*this._points.distanceIndexIndex(s-1,s)+c*this._points.distanceIndexIndex(o,o+1);for(let e=s;e<o;e++)t+=this._points.distanceIndexIndex(e,e+1);return t}}moveSignedDistanceFromFraction(t,e,r,n){const s=this._points.length-1,o=t*s;let a=i.Geometry.restrictToInterval(Math.floor(o),0,s-1);const c=o-a,l=this._points.interpolate(a,c,a+1,LineString3d._workPointA),d=LineString3d._workPointB,h=new MoveByDistanceContext(l,t,e);if(e>0){for(;a<=s;)if(a++,this._points.getPoint3dAtCheckedPointIndex(a,d),h.announcePoint(d,a/s))return p.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,p.CurveSearchStatus.success,n);return r&&h.announceExtrapolation(this._points,s-1,s,(s-1)/s,1),p.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,h.distanceStatus(),n)}for(c<=0&&a--;a>=0;a--)if(this._points.getPoint3dAtCheckedPointIndex(a,d),h.announcePoint(d,a/s))return p.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,p.CurveSearchStatus.success,n);return r&&h.announceExtrapolation(this._points,1,0,1/s,0),p.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,-h.distance0,h.distanceStatus(),n)}quickLength(){return this.curveLength()}quickUnitNormal(t){let e=Math.floor(this._points.length/3);if(e<1&&(e=1),(t=this._points.crossProductIndexIndexIndex(0,e,e+e))&&t.normalizeInPlace())return t}closestPoint(t,e,r){r=p.CurveLocationDetail.create(this,r);const i=this._points.length;if(i>0){const n=i-1;if(r.setFP(1,this._points.getPoint3dAtUncheckedPointIndex(n),void 0),r.setDistanceTo(t),i>1){let s=0,o=0;const a=1/n;for(let c=1;c<i;c++)(s=t.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(c-1),this._points.getPoint3dAtUncheckedPointIndex(c)))<0?(!e||c>1)&&(s=0):s>1&&(!e||c<n)&&(s=1),this._points.getPoint3dAtUncheckedPointIndex(c-1).interpolate(s,this._points.getPoint3dAtUncheckedPointIndex(c),r.pointQ),(o=r.pointQ.distance(t))<r.a&&r.setFP((c-1+s)*a,r.pointQ,void 0,o)}}return r}isInPlane(t){return this._points.isCloseToPlane(t,i.Geometry.smallMetricDistance)}static pushVertexHit(t,e,r,i,n){const s=p.CurveLocationDetail.createCurveFractionPoint(r,i,n);t.push(s),0===e?s.setIntervalRole(p.CurveIntervalRole.isolatedAtVertex):1===e?(t[t.length-2].setIntervalRole(p.CurveIntervalRole.intervalStart),s.setIntervalRole(p.CurveIntervalRole.intervalEnd)):(t[t.length-2].setIntervalRole(p.CurveIntervalRole.intervalInterior),s.setIntervalRole(p.CurveIntervalRole.intervalEnd))}appendPlaneIntersectionPoints(t,e){if(this._points.length<1)return 0;const r=e.length,n=this._points.length,s=1===n?1:n-1,o=LineString3d._workPointA,a=LineString3d._workPointB,c=LineString3d._workPointC;this._points.getPoint3dAtUncheckedPointIndex(0,o);let l=0,d=0,h=0,u=0;for(let f=0;f<this._points.length;f++,o.setFrom(a),h=l)if(this._points.getPoint3dAtUncheckedPointIndex(f,a),0===(l=i.Geometry.correctSmallMetricDistance(t.altitude(a))))LineString3d.pushVertexHit(e,d++,this,f/s,a);else if(h*l<0){u=h/(h-l),o.interpolate(u,a,c);const t=p.CurveLocationDetail.createCurveFractionPoint(this,(f-1+u)/s,c);t.setIntervalRole(p.CurveIntervalRole.isolated),e.push(t),d=0}return e.length-r}extendRange(t,e){this._points.extendRange(t,e)}isAlmostEqual(t){return t instanceof LineString3d&&!!h.GrowableXYZArray.isAlmostEqual(this._points,t._points)}appendStrokePoint(t,e){const r=this._points.length;let n=!0;const s=void 0!==e&&void 0!==this._fractions;r>0&&(s&&i.Geometry.isSameCoordinate(e,this._fractions.back())&&(n=!1),t.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(r-1))&&(n=!1)),n&&(this._points.push(t),s&&this.addFraction(e))}appendFractionToPoint(t,e){if(this._derivatives){const r=t.fractionToPointAndDerivative(e,LineString3d._workRay);this._fractions&&this._fractions.push(e),this._points.push(r.origin),this._derivatives&&this._derivatives.push(r.direction)}else{const r=t.fractionToPoint(e,LineString3d._workPointA);this._fractions&&this._fractions.push(e),this._points.push(r)}}clear(){this._points.clear(),this._fractions&&this._fractions.clear(),this._derivatives&&this._derivatives.clear()}static createForStrokes(t=0,e){const r=LineString3d.create();return t>0&&r._points.ensureCapacity(t),e&&(e.needParams&&(r._fractions=new d.GrowableFloat64Array(t),r._uvParams=new u.GrowableXYArray(t)),e.needNormals&&(r._derivatives=new h.GrowableXYZArray(t),r._surfaceNormals=new h.GrowableXYZArray(t))),r}appendFractionalStrokePoints(t,e,r=0,i=1,n=!0){let s=1,o=e-1;if(n&&(s=0,o=e),e>=1){const n=(i-r)/e;for(let e=s;e<=o;e++)this.appendFractionToPoint(t,r+e*n)}}appendInterpolatedStrokePoints(t,e,r,i){if(i&&this.appendStrokePoint(e,0),t>1){const i=1/t;for(let n=1;n<t;n++){const t=n*i;this.appendStrokePoint(e.interpolate(t,r),t)}}i&&this.appendStrokePoint(r,1)}emitStrokes(t,e){const r=this._points.length,i=LineString3d._workPointA,n=LineString3d._workPointB;if(r>0)if(e&&e.hasMaxEdgeLength){t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));for(let s=1;s<r;s++){this._points.getPoint3dAtUncheckedPointIndex(s-1,i),this._points.getPoint3dAtUncheckedPointIndex(s,n);const r=e.applyMaxEdgeLength(1,i.distance(n));r>1&&t.appendInterpolatedStrokePoints(r,i,n,!1),t.appendStrokePoint(n)}}else for(let s=0;s<r;s++)t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(s))}emitStrokableParts(t,e){const r=this._points.length;if(t.startCurvePrimitive(this),r>1){const i=1/(r-1);if(e&&e.hasMaxEdgeLength)for(let n=1;n<r;n++){const r=e.applyMaxEdgeLength(1,this._points.getPoint3dAtUncheckedPointIndex(n-1).distance(this._points.getPoint3dAtUncheckedPointIndex(n)));t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(n-1),this._points.getPoint3dAtUncheckedPointIndex(n),r,(n-1)*i,n*i)}else for(let e=1;e<r;e++)t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(e-1),this._points.getPoint3dAtUncheckedPointIndex(e),1,(e-1)*i,e*i)}t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){const e=this._points.length;let r=e-1;if(t&&t.hasMaxEdgeLength){r=0;for(let i=1;i<e;i++)r+=t.applyMaxEdgeLength(1,this._points.distanceIndexIndex(i-1,i))}return r}computeAndAttachRecursiveStrokeCounts(t,e){const r=this._points.length,i=void 0!==t&&t.hasMaxEdgeLength,n=g.StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let s=1;s<r;s++){const e=this._points.distanceIndexIndex(s-1,s),r=i?t.applyMaxEdgeLength(1,e):1;n.addToCountAndLength(r,e)}f.CurvePrimitive.installStrokeCountMap(this,n,e)}dispatchToGeometryHandler(t){return t.handleLineString3d(this)}announceClipIntervals(t,e){const r=this._points.length;if(r<2)return!1;let n=0,s=1;const o=(t,r)=>{e&&e(i.Geometry.interpolate(n,t,s),i.Geometry.interpolate(n,r,s),this)},a=LineString3d._workPointA,c=LineString3d._workPointB;this._points.getPoint3dAtUncheckedPointIndex(0,a);let l=!1;for(let i=1;i<r;i++,a.setFrom(c),n=s)this._points.getPoint3dAtUncheckedPointIndex(i,c),s=i/(r-1),t.announceClippedSegmentIntervals(0,1,a,c,o)&&(l=!0);return l}addResolvedPoint(t,e,r){const i=this._points.length;if(0!==i){if(1===i)return this._points.getPoint3dAtUncheckedPointIndex(0,LineString3d._indexPoint),void r.push(LineString3d._indexPoint);t<0&&(t=0),t>=i&&(t=i-1,e+=1),this._points.interpolate(t,e,t+1,LineString3d._indexPoint),r.push(LineString3d._indexPoint)}}clonePartialCurve(t,e){if(e<t){const r=this.clonePartialCurve(e,t);return r&&r.reverseInPlace(),r}const r=this._points.length,n=r-1;if(r<2||t>=1||e<=0)return;t<0&&(t=0),e>1&&(e=1);const s=t*n,o=e*n,a=Math.floor(s),c=Math.floor(o),l=s-a,d=o-c,h=LineString3d.create();this.addResolvedPoint(a,l,h._points);for(let i=a+1;i<=c;i++)this._points.getPoint3dAtUncheckedPointIndex(i,LineString3d._workPointA),h._points.push(LineString3d._workPointA);return i.Geometry.isSmallRelative(d)||this.addResolvedPoint(c,d,h._points),h}getIndexedSegment(t){if(t>=0&&t+1<this._points.length)return m.LineSegment3d.create(this._points.getPoint3dAtCheckedPointIndex(t),this._points.getPoint3dAtCheckedPointIndex(t+1))}get isPhysicallyClosed(){return this._points.length>0&&i.Geometry.isSmallMetricDistance(this._points.distanceIndexIndex(0,this._points.length-1))}addMappedStrokesToLineString3D(t,e){const r=e.numPoints(),i=void 0!==e._fractions,n=void 0!==e._derivatives,s=this._points,o=LineString3d._workPointA,a=LineString3d._workPointB,c=LineString3d._workPointC,l=s.length;if(t.primitive&&t.primitive===this&&t.componentData&&t.componentData.length+1===l){s.getPoint3dAtUncheckedPointIndex(0,o);for(let r=0;r+1<l;r++,o.setFromPoint3d(a)){s.getPoint3dAtUncheckedPointIndex(r+1,a);const l=t.componentData[r],d=l.numStroke,h=o.vectorTo(a);h.scale(d);for(let t=0;t<=d;t++){const r=t/d,s=l.fractionToA(r);e.addPoint(o.interpolate(r,a,c)),i&&e._fractions.push(s),n&&e._derivatives.push(h)}}}return e.numPoints()-r}static createArrayOfLineString3dFromVariantData(t){const e=new y.PointStreamGrowableXYZArrayCollector;y.VariantPointDataStream.streamXYZ(t,e);const r=e.claimArrayOfGrowableXYZArray(),i=[];if(void 0!==r)for(const n of r)i.push(LineString3d.createCapture(n));return i}static createArrayOfLineString3d(t){return this.createArrayOfLineString3dFromVariantData(t)}}e.LineString3d=LineString3d,LineString3d._workPointA=s.Point3d.create(),LineString3d._workPointB=s.Point3d.create(),LineString3d._workPointC=s.Point3d.create(),LineString3d._workRay=c.Ray3d.createXAxis(),LineString3d._indexPoint=s.Point3d.create();e.AnnotatedLineString3d=class AnnotatedLineString3d{};class MoveByDistanceContext{constructor(t,e,r){this.point0=t,this.distance0=0,this.targetDistance=Math.abs(r),this.fraction0=e}distanceStatus(){return i.Geometry.isSameCoordinate(this.distance0,this.targetDistance)?p.CurveSearchStatus.success:p.CurveSearchStatus.stoppedAtBoundary}announcePoint(t,e){const r=this.point0.distance(t),n=this.distance0+r;if(n<this.targetDistance&&!i.Geometry.isSameCoordinate(n,this.targetDistance))return this.point0.setFromPoint3d(t),this.distance0=n,this.fraction0=e,!1;const s=this.targetDistance-this.distance0,o=i.Geometry.safeDivideFraction(s,r,0);return this.point0.interpolate(o,t,this.point0),this.fraction0=i.Geometry.interpolate(this.fraction0,o,e),this.distance0=this.targetDistance,!0}announceExtrapolation(t,e,r,n,s){const o=this.targetDistance-this.distance0,a=t.distanceIndexIndex(e,r);if(!a)return!1;const c=i.Geometry.conditionalDivideFraction(o,a);return void 0!==c&&(t.interpolate(r,-c,e,this.point0),this.distance0=this.targetDistance,this.fraction0=i.Geometry.interpolate(s,-c,n),!0)}}},"./lib/curve/Loop.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/LineString3d.js"),n=r("./lib/curve/CurveCollection.js");class Loop extends n.CurveChain{constructor(){super(),this.curveCollectionType="loop",this.isInner=!1}isSameGeometryClass(t){return t instanceof Loop}static create(...t){const e=new Loop;for(const r of t)e.children.push(r);return e}static createArray(t){const e=new Loop;for(const r of t)e.children.push(r);return e}static createPolygon(t){const e=i.LineString3d.create(t);return e.addClosurePoint(),Loop.create(e)}cloneStroked(t){const e=i.LineString3d.create();for(const r of this.children)r.emitStrokes(e,t);return Loop.create(e)}dgnBoundaryType(){return 2}announceToCurveProcessor(t,e=-1){return t.announceLoop(this,e)}cloneEmptyPeer(){return new Loop}dispatchToGeometryHandler(t){return t.handleLoop(this)}}e.Loop=Loop},"./lib/curve/ParityRegion.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurveCollection.js"),n=r("./lib/curve/Loop.js");class ParityRegion extends i.CurveCollection{constructor(){super(),this.curveCollectionType="parityRegion",this._children=[]}isSameGeometryClass(t){return t instanceof ParityRegion}get children(){return this._children}addLoops(t){if(void 0===t);else if(t instanceof n.Loop)this.children.push(t);else if(Array.isArray(t))for(const e of t)e instanceof n.Loop?this.children.push(e):Array.isArray(e)&&this.addLoops(e)}static createLoops(t){if(t instanceof n.Loop)return t;const e=new ParityRegion;return e.addLoops(t),e}static create(...t){const e=new ParityRegion;for(const r of t)e.children.push(r);return e}dgnBoundaryType(){return 4}announceToCurveProcessor(t,e=-1){return t.announceParityRegion(this,e)}clone(){const t=new ParityRegion;let e;for(e of this.children){const r=e.clone();r instanceof n.Loop&&t.children.push(r)}return t}cloneStroked(t){const e=new ParityRegion;let r;for(r of this.children){const i=r.cloneStroked(t);i&&e.children.push(i)}return e}cloneEmptyPeer(){return new ParityRegion}tryAddChild(t){return!!(t&&t instanceof n.Loop)&&(this._children.push(t),!0)}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleParityRegion(this)}}e.ParityRegion=ParityRegion},"./lib/curve/Path.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurvePrimitive.js"),n=r("./lib/curve/LineString3d.js"),s=r("./lib/curve/CurveCollection.js"),o=r("./lib/geometry3d/Point3dVector3d.js");class Path extends s.CurveChain{constructor(){super(),this.curveCollectionType="path"}isSameGeometryClass(t){return t instanceof Path}announceToCurveProcessor(t,e=-1){return t.announcePath(this,e)}static create(...t){const e=new Path;for(const r of t)r instanceof i.CurvePrimitive?e.children.push(r):Array.isArray(r)&&r.length>0&&r[0]instanceof o.Point3d&&e.children.push(n.LineString3d.create(r));return e}static createArray(t){const e=new Path;for(const r of t)e.children.push(r);return e}cloneStroked(t){const e=n.LineString3d.create();for(const r of this.children)r.emitStrokes(e,t);return Path.create(e)}dgnBoundaryType(){return 1}cloneEmptyPeer(){return new Path}dispatchToGeometryHandler(t){return t.handlePath(this)}}e.Path=Path},"./lib/curve/PointString3d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/PointHelpers.js"),o=r("./lib/curve/GeometryQuery.js");class PointString3d extends o.GeometryQuery{constructor(){super(),this.geometryCategory="pointCollection",this._points=[]}isSameGeometryClass(t){return t instanceof PointString3d}get points(){return this._points}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static flattenArray(t){return t.reduce((t,e)=>t.concat(Array.isArray(e)?PointString3d.flattenArray(e):e),[])}static create(...t){const e=new PointString3d;return e.addPoints(t),e}addPoints(...t){const e=PointString3d.flattenArray(t);for(const r of e)r instanceof n.Point3d&&this._points.push(r)}addPoint(t){this._points.push(t)}popPoint(){this._points.pop()}setFrom(t){this._points=s.Point3dArray.clonePoint3dArray(t._points)}static createPoints(t){const e=new PointString3d;return e._points=s.Point3dArray.clonePoint3dArray(t),e}static createFloat64Array(t){const e=new PointString3d;for(let r=0;r+3<=t.length;r+=3)e._points.push(n.Point3d.create(t[r],t[r+1],t[r+2]));return e}clone(){const t=new PointString3d;return t.setFrom(this),t}setFromJSON(t){if(this._points.length=0,Array.isArray(t)){let e;for(e of t)this._points.push(n.Point3d.fromJSON(e))}}toJSON(){const t=[];for(const e of this._points)t.push(e.toJSON());return t}static fromJSON(t){const e=new PointString3d;return e.setFromJSON(t),e}pointAt(t,e){if(t>=0&&t<this._points.length)return e?(e.setFrom(this._points[t]),e):this._points[t].clone()}numPoints(){return this._points.length}reverseInPlace(){if(this._points.length>=2){let t=0,e=this._points.length-1;for(;t<e;){const r=this._points[t];this._points[e]=this._points[t],this._points[t]=r,t++,e--}}}tryTransformInPlace(t){return t.multiplyPoint3dArrayInPlace(this._points),!0}closestPoint(t){const e={index:-1,xyz:n.Point3d.create()},r=s.Point3dArray.closestPointIndex(this._points,t);return r>=0&&(e.index=r,e.xyz.setFrom(this._points[r])),e}isInPlane(t){return s.Point3dArray.isCloseToPlane(this._points,t,i.Geometry.smallMetricDistance)}extendRange(t,e){t.extendArray(this._points,e)}isAlmostEqual(t){return t instanceof PointString3d&&s.Point3dArray.isAlmostEqual(this._points,t._points)}clear(){this._points.length=0}dispatchToGeometryHandler(t){return t.handlePointString3d(this)}}e.PointString3d=PointString3d},"./lib/curve/PolygonOffsetContext.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/curve/CurvePrimitive.js"),s=r("./lib/curve/LineSegment3d.js"),o=r("./lib/geometry3d/Ray3d.js"),a=r("./lib/curve/CurveLocationDetail.js"),c=r("./lib/curve/LineString3d.js"),l=r("./lib/curve/Path.js"),d=r("./lib/curve/Loop.js"),h=r("./lib/curve/Arc3d.js"),u=r("./lib/curve/CurveCurve.js"),f=r("./lib/Geometry.js"),g=r("./lib/geometry3d/AngleSweep.js"),p=r("./lib/curve/RegionOps.js");var m;!function(t){t[t.Unknown=0]="Unknown",t[t.Cap=1]="Cap",t[t.Extend=2]="Extend",t[t.Trim=-1]="Trim",t[t.JustGeometry=3]="JustGeometry",t[t.Gap=4]="Gap"}(m||(m={}));class JointOptions{constructor(t,e=180,r=90){this.minArcDegrees=180,this.maxChamferTurnDegrees=90,this.leftOffsetDistance=0,this.leftOffsetDistance=t,this.minArcDegrees=e,this.maxChamferTurnDegrees=r}static create(t){return t instanceof JointOptions?t:new JointOptions(t)}needArc(t){return Math.abs(t.degrees)>=this.minArcDegrees}numChamferPoints(t){const e=Math.abs(t.degrees),r=f.Geometry.clamp(this.maxChamferTurnDegrees,10,120);return e<=r?1:Math.ceil(e/r)}}e.JointOptions=JointOptions;class Joint{constructor(t,e,r){this.curve0=t,this.curve1=e,this.swingPoint=r,this.flexure=m.Unknown}static constructArc(t,e,r){if(void 0!==e&&f.Geometry.isSameCoordinate(t.origin.distance(e),r.origin.distance(e))){const n=t.direction.angleToXY(r.direction),s=i.Vector3d.createStartEnd(e,t.origin),o=s.rotate90CCWXY();return h.Arc3d.create(e,s,o,g.AngleSweep.createStartEndRadians(0,n.radians))}}shallowExtract(){return{curve0:this.curve0,curve1:this.curve1,fraction0:this.fraction0,fraction1:this.fraction1}}static link(t,e){t.nextJoint=e,e&&(e.previousJoint=t),t.curve1&&e&&!e.curve0?e.curve0=t.curve1:!t.curve1&&e&&e.curve0&&(t.curve1=e.curve0)}nextJointFraction0(t){return this.nextJoint&&void 0!==this.nextJoint.fraction0?this.nextJoint.fraction0:t}static addStrokes(t,e){e&&e.emitStrokes(t)}static addPoint(t,e){if(t.packedPoints.length>0){t.endPoint().isAlmostEqual(e)||t.packedPoints.push(e)}}static collectStrokesFromChain(t,e,r=100){let i=-2*r;Joint.visitJointsOnChain(t,t=>{if(this.addStrokes(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const r=t.fraction1,i=t.nextJointFraction0(1);let n;0===r&&1===i?n=t.curve1.clone():r<i&&(n=t.curve1.clonePartialCurve(r,i)),n&&(t.jointCurve||this.addPoint(e,n.startPoint())),this.addStrokes(e,n)}return i++<r},r)}static collectPrimitive(t,e){e&&t.push(e)}static collectCurvesFromChain(t,e,r=100){let i=-2*r;Joint.visitJointsOnChain(t,t=>{if(this.collectPrimitive(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const r=t.fraction1,i=t.nextJointFraction0(1);let n;0===r&&1===i?n=t.curve1.clone():r<i&&(n=t.curve1.clonePartialCurve(r,i)),this.collectPrimitive(e,n)}return i++<r},r)}static annotateChain(t,e,r=100){Joint.visitJointsOnChain(t,t=>(t.annotateJointMode(e),!0),r)}static visitJointsOnChain(t,e,r=100){let i=t;if(i){let n=0;for(;void 0!==i;){if(n++>=r+5)return!0;if(!e(i))return!1;if((i=i.nextJoint)===t)break}}return!0}annotateExtension(t){if(this.curve0&&this.curve1){const e=this.curve0.fractionToPointAndDerivative(1),r=this.curve1.fractionToPointAndDerivative(0),i=o.Ray3d.closestApproachRay3dRay3d(e,r);if(i.approachType===a.CurveCurveApproachType.Intersection&&(this.fraction0=1,this.fraction1=0,i.detailA.fraction>=0&&i.detailB.fraction<=0)){this.flexure=m.Extend;const n=e.getDirectionRef().angleToXY(r.getDirectionRef());if(t.needArc(n)){const t=Joint.constructArc(e,this.curve0.baseCurveEnd,r);if(t)return this.fraction0=1,this.fraction1=0,void(this.jointCurve=t)}const s=t.numChamferPoints(n);if(s<=1)return void(this.jointCurve=c.LineString3d.create(e.origin,i.detailA.point,r.origin));if(s>1){const t=2*s,i=n.radians/t,o=Joint.constructArc(e,this.curve0.baseCurveEnd,r);if(void 0!==o){const n=1/Math.cos(i),a=c.LineString3d.create();this.jointCurve=a,a.addPoint(e.origin);for(let e=0;e<s;e++){const r=(1+2*e)/t;a.addPoint(o.fractionAndRadialFractionToPoint(r,n))}return void a.addPoint(r.origin)}}}this.flexure=m.Gap,this.jointCurve=s.LineSegment3d.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0}}selectIntersectionIndexByFraction(t,e,r){let i=-1,n=Number.MAX_VALUE;for(let s=0;s<r.dataA.length;s++){const o=Math.abs(r.dataA[s].fraction-t)+Math.abs(r.dataB[s].fraction-e);o<n&&(n=o,i=s)}return i}annotateJointMode(t){if(this.curve0&&!this.curve1)this.flexure=m.Cap,this.fraction0=1;else if(this.curve1&&!this.curve0)this.flexure=m.Cap,this.fraction1=0;else if(this.curve0&&this.curve1){const e=this.curve0.fractionToPointAndDerivative(0),r=this.curve1.fractionToPointAndDerivative(0);if(this.curve0 instanceof s.LineSegment3d&&this.curve1 instanceof s.LineSegment3d)if(this.curve0.endPoint().isAlmostEqual(this.curve1.startPoint()))this.fraction0=1,this.fraction1=0,this.flexure=m.Trim;else{const i=o.Ray3d.closestApproachRay3dRay3d(e,r);i.approachType===a.CurveCurveApproachType.Intersection&&(this.fraction0=i.detailA.fraction,this.fraction1=i.detailB.fraction,this.fraction0>=1&&this.fraction1<=0?this.annotateExtension(t):this.fraction0<1&&this.fraction1>0?this.flexure=m.Trim:this.fraction0>1&&this.fraction1>1&&(this.flexure=m.Gap,this.jointCurve=s.LineSegment3d.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0))}else{const e=u.CurveCurve.intersectionXY(this.curve0,!1,this.curve1,!1),r=this.selectIntersectionIndexByFraction(1,0,e);r>=0?(this.flexure=m.Trim,this.fraction0=e.dataA[r].fraction,this.fraction1=e.dataB[r].fraction):this.annotateExtension(t)}}}static removeDegeneratePrimitives(t,e,r){let i=t,n=0;let s=0;if(i)for(;void 0!==i&&s++<r;){const r=i.nextJoint;if(i&&r&&i.previousJoint&&r.nextJoint&&void 0!==i.fraction1&&void 0!==r.fraction0){const s=i.fraction1,o=r.fraction0,a=r.fraction1,c=r.nextJoint.fraction0,l=s>=o||s>1;if(l&&(void 0!==a&&a>1||void 0!==a&&void 0!==c&&a>=c)){const t=r.nextJoint,n=new Joint(i.curve0,t.curve1,void 0);Joint.link(i.previousJoint,n),Joint.link(n,t.nextJoint),n.annotateJointMode(e),n.previousJoint.annotateJointMode(e),n.nextJoint&&n.nextJoint.annotateJointMode(e)}else if(l){const s=new Joint(i.curve0,r.curve1,void 0);if(Joint.link(i.previousJoint,s),Joint.link(s,r.nextJoint),s.annotateJointMode(e),s.previousJoint.annotateJointMode(e),s.nextJoint.annotateJointMode(e),n++,i===t&&(t=s),i=s,n>=1)return{newStart:t,numJointRemoved:n}}}if((i=i.nextJoint)===t)break}return{newStart:t,numJointRemoved:n}}}class PolygonWireOffsetContext{constructor(){}static createOffsetSegment(t,e,r){if(i.Vector3d.createStartEnd(t,e,this._unitAlong),this._unitAlong.normalizeInPlace()){this._unitAlong.rotate90CCWXY(this._unitPerp);const i=s.LineSegment3d.create(t.plusScaled(this._unitPerp,r,this._offsetA),e.plusScaled(this._unitPerp,r,this._offsetB));return CurveChainWireOffsetContext.applyBasePoints(i,t.clone(),e.clone()),i}}constructPolygonWireXYOffset(t,e,r){const i=JointOptions.create(r),n=t.length;let s,o=PolygonWireOffsetContext.createOffsetSegment(t[0],t[1],i.leftOffsetDistance),a=new Joint(void 0,o,t[0]),h=a;for(let c=1;c+1<n;c++){const e=PolygonWireOffsetContext.createOffsetSegment(t[c],t[c+1],i.leftOffsetDistance);s=new Joint(o,e,t[c]),Joint.link(h,s),h=s,o=e}e?Joint.link(h,a):(s=new Joint(o,void 0,t[n-1]),Joint.link(h,s)),Joint.annotateChain(a,i,n);for(let c=0;c++<5;){const t=Joint.removeDegeneratePrimitives(a,i,n);if(a=t.newStart,0===t.numJointRemoved)break}const u=c.LineString3d.create();if(Joint.collectStrokesFromChain(a,u,n),u.packedPoints.length>1)return u.packedPoints.front().isAlmostEqual(u.packedPoints.back())?d.Loop.create(u):l.Path.create(u)}}e.PolygonWireOffsetContext=PolygonWireOffsetContext,PolygonWireOffsetContext._unitAlong=i.Vector3d.create(),PolygonWireOffsetContext._unitPerp=i.Vector3d.create(),PolygonWireOffsetContext._offsetA=i.Point3d.create(),PolygonWireOffsetContext._offsetB=i.Point3d.create();class CurveChainWireOffsetContext{constructor(){}static createOffsetSegment(t,e,r){if(i.Vector3d.createStartEnd(t,e,this._unitAlong),this._unitAlong.normalizeInPlace())return this._unitAlong.rotate90CCWXY(this._unitPerp),s.LineSegment3d.create(t.plusScaled(this._unitPerp,r,this._offsetA),e.plusScaled(this._unitPerp,r,this._offsetB))}static applyBasePoints(t,e,r){return void 0!==t&&(void 0!==e&&(t.baseCurveStart=e),void 0!==r&&(t.baseCurveEnd=r)),t}static createSingleOffsetPrimitiveXY(t,e){const r=t.fractionToPoint(0),n=t.fractionToPoint(1);if(t instanceof s.LineSegment3d)return this.applyBasePoints(this.createOffsetSegment(r,n,e),r,n);if(t instanceof h.Arc3d){const r=t.cloneAtZ();if(r.isCircular){const i=r.sweep.sweepRadians*r.matrix.coffs[8]>=0?1:-1,n=r.matrix.columnXMagnitude(),s=n-i*e;if(s>=0){const e=s/n,i=r.matrix;return i.scaleColumnsInPlace(e,e,1),this.applyBasePoints(h.Arc3d.createRefs(r.center.clone(),i,r.sweep.clone()),t.startPoint(),t.endPoint())}}}else if(t instanceof c.LineString3d){const r=t.numPoints();if(r>1){const n=[],s=i.Point3d.create(),o=i.Point3d.create();t.packedPoints.getPoint3dAtUncheckedPointIndex(0,s);for(let i=1;i<r;i++){t.packedPoints.getPoint3dAtUncheckedPointIndex(i,o);const r=this.applyBasePoints(this.createOffsetSegment(s,o,e),s.clone(),o.clone());void 0!==r&&n.push(r),s.setFromPoint3d(o)}return n}}}static constructCurveXYOffset(t,e){const r=t instanceof d.Loop;if(void 0===e)return;const i=[];for(const d of t.children){const t=CurveChainWireOffsetContext.createSingleOffsetPrimitiveXY(d,e.leftOffsetDistance);if(void 0===t)return;if(t instanceof n.CurvePrimitive)i.push(t);else if(Array.isArray(t))for(const e of t)e instanceof n.CurvePrimitive&&i.push(e)}let s=i[0];const o=new Joint(void 0,s,s.fractionToPoint(0));let a,c=o;for(let n=1;n<i.length;n++){const t=i[n];a=new Joint(s,t,t.fractionToPoint(0)),Joint.link(c,a),c=a,s=t}t instanceof d.Loop&&Joint.link(c,o);const l=i.length;Joint.annotateChain(o,e,l);const h=[];return Joint.collectCurvesFromChain(o,h,l),p.RegionOps.createLoopPathOrBagOfCurves(h,r)}}e.CurveChainWireOffsetContext=CurveChainWireOffsetContext,CurveChainWireOffsetContext._unitAlong=i.Vector3d.create(),CurveChainWireOffsetContext._unitPerp=i.Vector3d.create(),CurveChainWireOffsetContext._offsetA=i.Point3d.create(),CurveChainWireOffsetContext._offsetB=i.Point3d.create()},"./lib/curve/Query/ConsolidateAdjacentPrimitivesContext.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurveCollection.js"),n=r("./lib/geometry3d/GeometryHandler.js"),s=r("./lib/curve/LineSegment3d.js"),o=r("./lib/curve/LineString3d.js"),a=r("./lib/geometry3d/PolylineOps.js"),c=r("./lib/curve/Arc3d.js"),l=r("./lib/curve/CurveFactory.js");e.ConsolidateAdjacentCurvePrimitivesContext=class ConsolidateAdjacentCurvePrimitivesContext extends n.NullGeometryHandler{constructor(t){super(),this._options=t||new i.ConsolidateAdjacentCurvePrimitivesOptions}handleCurveChain(t){const e=t.children.length,r=[];let i=0;for(let n=0;n<e;){const e=t.children[n];if(this._options.consolidateLinearGeometry&&(e instanceof s.LineSegment3d||e instanceof o.LineString3d)){r.length=0;let c=n;for(;c<t.children.length;c++){const e=t.children[c];if(e instanceof s.LineSegment3d)r.push(e.startPoint()),r.push(e.endPoint());else{if(!(e instanceof o.LineString3d))break;{const t=e.packedPoints;for(let e=0;e<t.length;e++)r.push(t.getPoint3dAtUncheckedPointIndex(e))}}}if(r.length>1){const e=a.PolylineOps.compressShortEdges(r,this._options.colinearPointTolerance),n=a.PolylineOps.compressByPerpendicularDistance(e,this._options.colinearPointTolerance);n.length<2?t.children[i++]=o.LineString3d.create(n[0]):2===n.length?t.children[i++]=s.LineSegment3d.create(n[0],n[1]):t.children[i++]=o.LineString3d.createPoints(n)}else t.children[i++]=e;n=c}else if(this._options.consolidateCompatibleArcs&&e instanceof c.Arc3d){for(;++n<t.children.length;){const r=t.children[n];if(!(r instanceof c.Arc3d))break;if(!l.CurveFactory.appendToArcInPlace(e,r))break}t.children[i++]=e}else t.children[i++]=e,n++}t.children.length=i}handlePath(t){return this.handleCurveChain(t)}handleLoop(t){return this.handleCurveChain(t)}}},"./lib/curve/Query/CurveSplitContext.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurvePrimitive.js"),n=r("./lib/Geometry.js"),s=r("./lib/curve/CurveCollection.js"),o=r("./lib/curve/CurveCurve.js"),a=r("./lib/curve/Path.js");class CutFractionDescriptor{constructor(t,e){this.fraction=t,this.otherCurveDetail=e}setFrom(t,e){e&&this.isSameFraction(t)&&(this.otherCurveDetail=t.otherCurveDetail?t.otherCurveDetail:this.otherCurveDetail),this.fraction=t.fraction}isSameFraction(t){return n.Geometry.isSmallAngleRadians(this.fraction-t.fraction)}set(t,e){this.fraction=t,this.otherCurveDetail=e}}class CurveSplitContext{static hasInteriorDetailAIntersections(t,e=n.Geometry.smallAngleRadians){if(0===t.length)return!1;for(const r of t)if(r.detailA.fraction>e||r.detailA.fraction<1-e)return!0;return!1}collectFragmentAndAdvanceCut(t,e,r,i){if(!e.isSameFraction(r)){const n=t.clonePartialCurve(e.fraction,r.fraction);void 0!==n&&(n.startCut=e.otherCurveDetail,n.endCut=r.otherCurveDetail,i.push(n))}e.setFrom(r,!0)}collectSinglePrimitiveFragments(t,e,r){if(void 0===e||!CurveSplitContext.hasInteriorDetailAIntersections(e)){const e=t.clone();return void(e&&r.push(e))}e.sort((t,e)=>t.detailA.fraction-e.detailA.fraction);const i=new CutFractionDescriptor(0,void 0),n=new CutFractionDescriptor(1,void 0);for(const s of e)n.set(s.detailA.fraction,s.detailB),this.collectFragmentAndAdvanceCut(t,i,n,r);n.set(1,void 0),this.collectFragmentAndAdvanceCut(t,i,n,r)}static cloneCurvesWithXYSplitFlags(t,e){const r=new CurveSplitContext;if(t instanceof i.CurvePrimitive){const i=[],n=o.CurveCurve.intersectionXYPairs(t,!1,e,!1);return r.collectSinglePrimitiveFragments(t,n,i),1===i.length?i[0]:a.Path.createArray(i)}if(t instanceof s.CurveChain){const i=[];for(const n of t.children){const t=o.CurveCurve.intersectionXYPairs(n,!1,e,!1);r.collectSinglePrimitiveFragments(n,t,i)}return a.Path.createArray(i)}}}e.CurveSplitContext=CurveSplitContext},"./lib/curve/Query/CylindricalRange.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/GeometryHandler.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/curve/LineString3d.js"),o=r("./lib/curve/StrokeOptions.js");class CylindricalRangeQuery extends i.RecurseToCurvesGeometryHandler{constructor(t){super(),this._localPoint=n.Point3d.create(),this._worldPoint=n.Point3d.create(),this._perpVector=n.Vector3d.createZero(),this._maxDistance=0,this._localToWorld=t.toRigidZFrame()}announcePoint(t){this._localToWorld.multiplyInversePoint3d(t,this._localPoint);const e=this._localPoint.magnitudeXY();e>=this._maxDistance&&(this._maxDistance=e,this._perpVector.setFromPoint3d(this._localPoint),this._perpVector.z=0,this._localToWorld.matrix.multiplyXY(this._localPoint.x,this._localPoint.y,this._perpVector))}handleLineSegment3d(t){this.announcePoint(t.startPoint(this._worldPoint)),this.announcePoint(t.endPoint(this._worldPoint))}handleLineString3d(t){for(let e=0;e<t.numPoints();e++)t.pointAt(e,this._worldPoint),this.announcePoint(this._worldPoint)}handleArc3d(t){const e=o.StrokeOptions.applyAngleTol(void 0,3,t.sweep.sweepRadians,.1),r=1/e;for(let i=0;i<=e;i++)t.fractionToPoint(i*r,this._worldPoint),this.announcePoint(this._worldPoint)}static computeMaxVectorFromRay(t,e){const r=new CylindricalRangeQuery(t);return e.dispatchToGeometryHandler(r),r._perpVector.clone()}static buildRotationalNormalsInLineStrings(t,e,r){if(t instanceof s.LineString3d){const i=t.packedPoints,s=t.packedDerivatives,o=t.ensureEmptySurfaceNormals();if(s&&o){const s=n.Vector3d.create(),a=n.Vector3d.create(),c=n.Point3d.create(),l=i.length;for(let n=0;n<l;n++)i.getPoint3dAtUncheckedPointIndex(n,c),e.perpendicularPartOfVectorToTarget(c,s),s.isAlmostZero?e.direction.crossProduct(r,a):e.direction.crossProduct(s,a),t.packedDerivatives.getVector3dAtCheckedVectorIndex(n,s),s.crossProduct(a,a),a.normalizeInPlace(),o.push(a)}}else if(t.children){const i=t.children;for(const t of i)this.buildRotationalNormalsInLineStrings(t,e,r)}}}e.CylindricalRangeQuery=CylindricalRangeQuery},"./lib/curve/Query/InOutTests.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/Loop.js"),n=r("./lib/geometry3d/Plane3dByOriginAndUnitNormal.js"),s=r("./lib/geometry3d/Angle.js"),o=r("./lib/curve/CurveLocationDetail.js"),a=r("./lib/curve/CurvePrimitive.js"),c=r("./lib/curve/ParityRegion.js"),l=r("./lib/Geometry.js"),d=r("./lib/geometry3d/Point3dVector3d.js"),h=r("./lib/curve/UnionRegion.js");e.PointInOnOutContext=class PointInOnOutContext{static testPointInOnOutLoopXY(t,e,r){let i;const c=d.Point3d.create(e,r);for(let d=0;Math.abs(d)<6;d=-1.2313*(d+.3212897)){const h=(i=n.Plane3dByOriginAndUnitNormal.createXYAngle(e,r,s.Angle.createRadians(d))).getNormalRef(),u=[];for(const e of t.children)e instanceof a.CurvePrimitive&&e.appendPlaneIntersectionPoints(i,u);a.CurvePrimitive.snapAndRestrictDetails(u,!1,!0);let f,g,p=0,m=0,y=0;for(const t of u){if(t.intervalRole!==o.CurveIntervalRole.isolated&&void 0!==t.intervalRole&&y++,f=t.point.x-e,g=t.point.y-r,l.Geometry.isSameCoordinateXY(f,g,0,0))return 0;const i=l.Geometry.crossProductXYXY(h.x,h.y,f,g);if(c.isAlmostEqualXY(t.point))return 0;i<0?p++:i>0&&m++}if(0!==y)continue;const P=1&p;if(P===(1&m))return 1===P?1:-1}return-1}static testPointInOnOutParityRegionXY(t,e,r){let n=-1;for(const s of t.children)if(s instanceof i.Loop){const t=this.testPointInOnOutLoopXY(s,e,r);if(0===t)return 0;t>0&&(n=-n)}return n}static testPointInOnOutUnionRegionXY(t,e,r){for(const i of t.children){const t=this.testPointInOnOutRegionXY(i,e,r);if(t>=0)return t}return-1}static testPointInOnOutRegionXY(t,e,r){return t instanceof i.Loop?this.testPointInOnOutLoopXY(t,e,r):t instanceof c.ParityRegion?this.testPointInOnOutParityRegionXY(t,e,r):t instanceof h.UnionRegion?this.testPointInOnOutUnionRegionXY(t,e,r):-1}}},"./lib/curve/Query/StrokeCountChain.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/Query/StrokeCountMap.js"),n=r("./lib/curve/CurveCollection.js"),s=r("./lib/curve/ParityRegion.js"),o=r("./lib/curve/LineString3d.js"),a=r("./lib/curve/Loop.js"),c=r("./lib/geometry3d/Point3dVector3d.js"),l=r("./lib/Geometry.js");class StrokeCountMapMultipassVisitor{startSweeps(t,e,r){return!0}endSweeps(t,e,r){return!0}}e.StrokeCountMapMultipassVisitor=StrokeCountMapMultipassVisitor;class StrokeCountMapVisitorApplyMaxCount extends StrokeCountMapMultipassVisitor{constructor(){super(),this.myMap=i.StrokeCountMap.createWithComponentIndex()}startPass(t){return 0===t?(this.myMap.numStroke=0,!0):1===t}visit(t,e){return 0===t?(e.numStroke>this.myMap.numStroke&&(this.myMap.numStroke=e.numStroke),!0):1===t&&(e.numStroke=this.myMap.numStroke,!0)}endPass(t){return!0}}e.StrokeCountMapVisitorApplyMaxCount=StrokeCountMapVisitorApplyMaxCount;class StrokeCountMapVisitorApplyMaxCurveLength extends StrokeCountMapMultipassVisitor{constructor(){super(),this.maxCurveLength=0}startPass(t){return 0===t?(this.maxCurveLength=0,!0):1===t}visit(t,e){return 0===t?(this.maxCurveLength=l.Geometry.maxXY(e.curveLength,this.maxCurveLength),!0):1===t&&(e.a0=0,e.a1=this.maxCurveLength,!0)}endPass(t){return!0}}e.StrokeCountMapVisitorApplyMaxCurveLength=StrokeCountMapVisitorApplyMaxCurveLength;class StrokeCountChain{constructor(t,e){this.parent=t,this.maps=[],this.options=e}static createForCurveChain(t,e){const r=new StrokeCountChain(t,e);r.parent=t;for(const i of t.children)i.computeAndAttachRecursiveStrokeCounts(e),i.strokeData&&r.maps.push(i.strokeData);return r}getStrokes(){const t=o.LineString3d.create();this.options&&(this.options.needNormals||this.options.needParams)&&(t.ensureEmptyFractions(),t.ensureEmptyDerivatives(),t.ensureEmptyUVParams());for(const e of this.maps)e.primitive&&e.primitive.addMappedStrokesToLineString3D(e,t);return t}static applySummed01LimitsWithinArray(t,e){let r=e;for(const i of t)i.a0+=r,i.componentData?i.a1=this.applySummed01LimitsWithinArray(i.componentData,i.a0):i.a1+=r,r=i.a1;return r}applySummed01Limits(t){return StrokeCountChain.applySummed01LimitsWithinArray(this.maps,t)}}e.StrokeCountChain=StrokeCountChain;class StrokeCountSection{constructor(t){this.parent=t,this.chains=[]}static createForParityRegionOrChain(t,e){const r=new StrokeCountSection(t);if(t instanceof s.ParityRegion)for(const i of t.children){const t=StrokeCountChain.createForCurveChain(i,e);r.chains.push(t)}else t instanceof n.CurveChain&&r.chains.push(StrokeCountChain.createForCurveChain(t,e));return r}static areSectionsCompatible(t,e){if(t.length<2)return!0;const r=t[0].chains.length;for(let i=1;i<t.length;i++){if(t[i].chains.length!==r)return!1;for(let r=0;r<t[0].chains.length;r++){const n=t[0].chains[r].maps.length;if(t[i].chains[r].maps.length!==n)return!1;for(let s=0;s<n;s++)if(!t[0].chains[r].maps[s].isCompatibleComponentStructure(t[i].chains[r].maps[s],e))return!1}}return!0}static remapa0a1WithinEachChain(t){for(const e of t)for(const t of e.chains)t.applySummed01Limits(0)}static applyMultipassVisitorCallbackNoComponents(t,e,r,i,n){const s=t.length;if(!n.startSweeps(e,r,i))return!1;if(void 0===i)for(let o=0;n.startPass(o);o++){for(let i=0;i<s;i++)if(!n.visit(o,t[i].chains[e].maps[r]))return!1;if(!n.endPass(o))return!1}else for(let o=0;n.startPass(o);o++){for(let a=0;a<s;a++)if(!n.visit(o,t[a].chains[e].maps[r].componentData[i]))return!1;if(!n.endPass(o))return!1}return!!n.endSweeps(e,r,i)}static runMultiPassVisitorAtCorrespondingPrimitives(t,e){const r=t[0].chains.length;for(let i=0;i<r;i++){const r=t[0].chains[i].maps.length;for(let n=0;n<r;n++)if(t[0].chains[i].maps[n].componentData){const r=t[0].chains[i].maps[n].componentData.length;for(let s=0;s<r;s++)if(!this.applyMultipassVisitorCallbackNoComponents(t,i,n,s,e))return!1}else if(!this.applyMultipassVisitorCallbackNoComponents(t,i,n,void 0,e))return!1}return!0}static enforceStrokeCountCompatibility(t){if(t.length<2)return!0;if(!StrokeCountSection.areSectionsCompatible(t,!1))return!1;const e=new StrokeCountMapVisitorApplyMaxCount;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),!0}static enforceCompatibleDistanceSums(t){if(t.length<2)return!0;if(!StrokeCountSection.areSectionsCompatible(t,!1))return!1;const e=new StrokeCountMapVisitorApplyMaxCurveLength;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),this.remapa0a1WithinEachChain(t),!0}getStrokes(){if(1===this.chains.length)return this.chains[0].getStrokes();{const t=s.ParityRegion.create();for(const e of this.chains){const r=e.getStrokes();r instanceof o.LineString3d&&t.tryAddChild(a.Loop.create(r))}return t}}static extendDistanceRangeBetweenStrokes(t,e,r){if(!t.isSameGeometryClass(e))return!1;if(t instanceof o.LineString3d){if(!(e instanceof o.LineString3d))return!1;if(t.numPoints()===e.numPoints()){const i=t.numPoints(),n=c.Point3d.create(),s=c.Point3d.create(),o=t.packedPoints,a=e.packedPoints;for(let t=0;t<i;t++)o.getPoint3dAtCheckedPointIndex(t,n),a.getPoint3dAtCheckedPointIndex(t,s),r.extendX(n.distance(s));return!0}}else if(t instanceof s.ParityRegion){if(!(e instanceof s.ParityRegion))return!1;const i=t.children,n=e.children,o=i.length;if(o===n.length){for(let t=0;t<o;t++)if(!this.extendDistanceRangeBetweenStrokes(i[t],n[t],r))return!1;return!0}}else if(t instanceof n.CurveChain){if(!(e instanceof n.CurveChain))return!1;const i=t.children,s=e.children,o=i.length;if(o===s.length){for(let t=0;t<o;t++)if(!this.extendDistanceRangeBetweenStrokes(i[t],s[t],r))return!1;return!0}}return!1}}e.StrokeCountSection=StrokeCountSection},"./lib/curve/Query/StrokeCountMap.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js");class StrokeCountMap{constructor(t,e,r,i,n){this.numStroke=t,this.curveLength=e,this.a0=r,this.a1=i,this.componentData=n}static createWithCurvePrimitive(t,e,r,i,n,s){const o=new StrokeCountMap(e,r,i,n,s);return o.primitive=t,o}static createWithComponentIndex(t=0,e=0,r=0,i=0,n=0){const s=new StrokeCountMap(e,r,i,n);return s.componentIndex=t,s}static createWithCurvePrimitiveAndOptionalParent(t,e,r){const i=e?e.a1:0,n=new StrokeCountMap(0,0,i,i,r);return n.primitive=t,n}addToCountAndLength(t,e){const r=this.a1+e;this.componentData&&this.componentData.push(new StrokeCountMap(t,e,this.a1,r)),this.numStroke+=t,this.curveLength+=e,this.a1=r}isCompatibleComponentStructure(t,e){if(e&&this.numStroke!==t.numStroke)return!1;if(void 0===this.componentData&&void 0===t.componentData)return!0;if(this.componentData&&t.componentData){if(this.componentData.length!==t.componentData.length)return!1;const r=this.componentData.length;for(let i=0;i<r;i++)if(!this.componentData[i].isCompatibleComponentStructure(t.componentData[i],e))return!1;return!0}return!1}clone(){const t=new StrokeCountMap(this.numStroke,this.curveLength,this.a0,this.a1);if(this.componentData){t.componentData=[];for(const e of this.componentData)t.componentData.push(e.clone())}return t}fractionToA(t){return i.Geometry.interpolate(this.a0,t,this.a1)}}e.StrokeCountMap=StrokeCountMap},"./lib/curve/RegionMomentsXY.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry4d/MomentData.js"),n=r("./lib/geometry3d/GeometryHandler.js"),s=r("./lib/geometry3d/Point3dVector3d.js"),o=r("./lib/geometry3d/Angle.js"),a=r("./lib/curve/LineString3d.js"),c=r("./lib/curve/Loop.js"),l=r("./lib/curve/StrokeOptions.js");e.RegionMomentsXY=class RegionMomentsXY extends n.NullGeometryHandler{constructor(){super(...arguments),this._point0=s.Point3d.create(),this._point1=s.Point3d.create()}handleArc3d(t){const e=this._activeMomentData,r=t.sweep.sweepRadians,i=.5*r;let n=Math.sin(i),s=Math.cos(i),a=Math.sin(r);o.Angle.isFullCircleRadians(r)&&(n=0,s=-1,a=0);const c=2*n*n*n*s/(i-n*s),l=n*n*n,d=.5*(r-a),h=.25*d*(1+c)-l*l*4/(9*d),u=.25*d*(1-c/3),f=4*n*n*n/(3*(r-a)),g=t.sweep.fractionToRadians(.5),p=t.radiansToRotatedBasis(g),m=p.origin.plusScaled(p.vectorU,f);e.accumulateXYProductsInCentroidalFrame(h,0,u,d,m,p.vectorU,p.vectorV);const y=t.fractionToPoint(0),P=t.fractionToPoint(1);e.accumulateTriangleMomentsXY(void 0,y,P)}handleLineString3d(t){this._activeMomentData.accumulateTriangleToLineStringMomentsXY(void 0,t.packedPoints)}handleLineSegment3d(t){const e=this._activeMomentData;t.startPoint(this._point0),t.endPoint(this._point1),e.accumulateTriangleMomentsXY(void 0,this._point0,this._point1)}handleLoop(t){const e=this._activeMomentData=i.MomentData.create();e.needOrigin=!1;for(const r of t.children)r.dispatchToGeometryHandler(this);return this._activeMomentData=void 0,e}handleParityRegion(t){const e=[];let r,n=0;for(const i of t.children)if(i instanceof c.Loop){const t=this.handleLoop(i);if(t){e.push(t);const i=Math.abs(t.quantitySum);i>n&&(n=i,r=t)}}if(r){const t=i.MomentData.create(),n=r.signFactor(1);t.accumulateProducts(r,n);for(const i of e)if(i!==r){const e=i.signFactor(-1);t.accumulateProducts(i,e)}return t}}handleUnionRegion(t){const e=i.MomentData.create();for(const r of t.children){const t=r.dispatchToGeometryHandler(this);if(t){const r=t.signFactor(1);e.accumulateProducts(t,r)}}return e}getStrokeOptions(){if(this._strokeOptions)return this._strokeOptions;const t=l.StrokeOptions.createForCurves();return t.angleTol=o.Angle.createDegrees(5),this._strokeOptions=t,t}handleCurvePrimitive(t){const e=a.LineString3d.create(),r=this.getStrokeOptions();t.emitStrokes(e,r),this.handleLineString3d(e)}handleBSplineCurve3d(t){return this.handleCurvePrimitive(t)}handleBSplineCurve3dH(t){return this.handleCurvePrimitive(t)}handleTransitionSpiral(t){return this.handleCurvePrimitive(t)}}},"./lib/curve/RegionOps.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry4d/MomentData.js"),n=r("./lib/curve/RegionMomentsXY.js"),s=r("./lib/topology/Graph.js"),o=r("./lib/topology/Triangulation.js"),a=r("./lib/geometry3d/Point3dVector3d.js"),c=r("./lib/geometry3d/IndexedXYZCollection.js"),l=r("./lib/topology/RegularizeFace.js"),d=r("./lib/topology/Merging.js"),h=r("./lib/topology/HalfEdgeGraphSearch.js"),u=r("./lib/polyface/PolyfaceBuilder.js"),f=r("./lib/curve/PolygonOffsetContext.js"),g=r("./lib/curve/CurveCollection.js"),p=r("./lib/curve/CurveWireMomentsXYZ.js"),m=r("./lib/Geometry.js"),y=r("./lib/curve/CurvePrimitive.js"),P=r("./lib/curve/Loop.js"),x=r("./lib/curve/Path.js"),_=r("./lib/curve/Query/InOutTests.js"),v=r("./lib/curve/Query/CurveSplitContext.js"),S=r("./lib/curve/ChainCollectorContext.js"),C=r("./lib/curve/LineString3d.js"),A=r("./lib/geometry3d/Transform.js"),w=r("./lib/geometry3d/Point3dArrayCarrier.js"),b=r("./lib/geometry3d/PolylineCompressionByEdgeOffset.js"),I=r("./lib/geometry3d/GrowableXYZArray.js"),T=r("./lib/curve/Query/ConsolidateAdjacentPrimitivesContext.js");class RegionOpsFaceToFaceSearchCallbacks{startComponent(t){return!0}finishComponent(t){return!0}enterFace(t,e){return!0}leaveFace(t,e){return!0}}class RegionOpsBooleanSweepCallbacks extends RegionOpsFaceToFaceSearchCallbacks{constructor(t,e){super(),this._inComponent=[!1,!1,!1],this._exteriorMask=e,this._faceSelectFunction=t}startComponent(t){return t.setMaskAroundFace(this._exteriorMask),!0}enterFace(t,e){const r=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[r]=!this._inComponent[r]),this._faceSelectFunction(this._inComponent[1],this._inComponent[2])||e.setMaskAroundFace(this._exteriorMask),!0}leaveFace(t,e){const r=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[r]=!this._inComponent[r]),!0}}function M(t,e,r,i){const n=new s.HalfEdgeGraph,o=s.HalfEdgeMask.BOUNDARY_EDGE|s.HalfEdgeMask.PRIMARY_EDGE,a=RegionOps.addLoopsWithEdgeTagToGraph(n,t,o,1),c=RegionOps.addLoopsWithEdgeTagToGraph(n,e,o,2);if(i&&i("unmerged loops",n,"U"),a&&c){d.HalfEdgeGraphMerge.splitIntersectingEdges(n),i&&i("After splitIntersectingEdges",n,"U"),d.HalfEdgeGraphMerge.clusterAndMergeXYTheta(n),i&&i("After clusterAndMergeXYTheta",n,"M"),new l.RegularizationContext(n).regularizeGraph(!0,!0),i&&i("After regularize",n,"MR");const t=h.HalfEdgeGraphSearch.findMinimumAreaFace(n),e=s.HalfEdgeMask.EXTERIOR,o=n.grabMask(),a=n.grabMask(),c=e|o|a;return n.clearMask(c),function(t,e,r,i,n){if(e.isMaskSet(r))return;if(!n.startComponent(e))return;const s=[];e.setMaskAroundFace(r);let o=e;do{let t=o,e=o.edgeMate;if(!e.isMaskSet(r)){s.push(o),s.push(e);let a=e.faceSuccessor;if(e.setMaskAroundFace(r),n.enterFace(s,e))for(;;){if(!(e=a.edgeMate).isMaskSet(r)){if(e.setMaskAroundFace(r),!n.enterFace(s,e))return;s.push(a),s.push(e),a=e,t=e}if(a.setMask(i),(a=a.faceSuccessor)===t){if(n.leaveFace(s,a),s.length<=2)break;s.pop(),a=s[s.length-1],s.pop(),t=s[s.length-1]}if(a.isMaskSet(i))return}}o=o.faceSuccessor}while(o!==e);n.finishComponent(e)}(0,t,o,a,new RegionOpsBooleanSweepCallbacks(r,e)),i&&i("After faceToFaceSearchFromOuterLoop",n,"MRX"),n.dropMask(o),n.dropMask(a),u.PolyfaceBuilder.graphToPolyface(n)}}class RegionOps{static computeXYAreaMoments(t){const e=new n.RegionMomentsXY,r=t.dispatchToGeometryHandler(e);if(r instanceof i.MomentData)return r.shiftOriginAndSumsToCentroidOfSums(),r}static computeXYZWireMomentSums(t){const e=new p.CurveWireMomentsXYZ;e.visitLeaves(t);const r=e.momentData;return r.shiftOriginAndSumsToCentroidOfSums(),r}static addLoopsToGraph(t,e,r){if(e instanceof c.IndexedXYZCollection){const i=o.Triangulator.directCreateFaceLoopFromCoordinates(t,e);void 0!==i&&r(t,i)}else if(Array.isArray(e)&&e.length>0)if(a.Point3d.isXAndY(e[0])){const i=o.Triangulator.directCreateFaceLoopFromCoordinates(t,e);void 0!==i&&r(t,i)}else if(e[0]instanceof c.IndexedXYZCollection)for(const i of e){const e=o.Triangulator.directCreateFaceLoopFromCoordinates(t,i);void 0!==e&&r(t,e)}}static addLoopsWithEdgeTagToGraph(t,e,r,i){const n=[];if(this.addLoopsToGraph(t,e,(t,e)=>{e&&(n.push(e),e.setMaskAndEdgeTagAroundFace(r,i,!0))}),n.length>0)return n}static polygonXYAreaIntersectLoopsToPolyface(t,e){return M(t,e,(t,e)=>t&&e,this._graphCheckPointFunction)}static polygonXYAreaUnionLoopsToPolyface(t,e){return M(t,e,(t,e)=>t||e,this._graphCheckPointFunction)}static polygonXYAreaDifferenceLoopsToPolyface(t,e){return M(t,e,(t,e)=>t&&!e,this._graphCheckPointFunction)}static constructPolygonWireXYOffset(t,e,r){return(new f.PolygonWireOffsetContext).constructPolygonWireXYOffset(t,e,r)}static constructCurveXYOffset(t,e){const r=f.JointOptions.create(e);return f.CurveChainWireOffsetContext.constructCurveXYOffset(t,r)}static testPointInOnOutRegionXY(t,e,r){return _.PointInOnOutContext.testPointInOnOutRegionXY(t,e,r)}static createLoopPathOrBagOfCurves(t,e=!0){const r=t.length;if(0===r)return;let i,n=0;e&&(n=m.Geometry.maxXY(n,t[0].startPoint().distance(t[r-1].endPoint())));for(let s=0;s+1<r;s++)n=m.Geometry.maxXY(n,t[s].endPoint().distance(t[s+1].startPoint()));i=m.Geometry.isSmallMetricDistance(n)?e?P.Loop.create():x.Path.create():g.BagOfCurves.create();for(const s of t)i.tryAddChild(s);return i}static setCheckPointFunction(t){this._graphCheckPointFunction=t}static cloneCurvesWithXYSplitFlags(t,e){return v.CurveSplitContext.cloneCurvesWithXYSplitFlags(t,e)}static splitToPathsBetweenFlagBreaks(t,e){if(void 0===t)return;if(t instanceof y.CurvePrimitive)return t;const r=t.collectCurvePrimitives(),i=new S.ChainCollectorContext(e);for(const n of r)i.announceCurvePrimitive(n);return i.grabResult()}static splitPathsByRegionInOnOutXY(t,e){const r={insideParts:[],outsideParts:[],coincidentParts:[]},i=RegionOps.cloneCurvesWithXYSplitFlags(t,e),n=RegionOps.splitToPathsBetweenFlagBreaks(i,!0);if(n instanceof g.CurveCollection)for(const s of n.children){const t=g.CurveCollection.createCurveLocationDetailOnAnyCurvePrimitive(s);if(t){R(s,RegionOps.testPointInOnOutRegionXY(e,t.point.x,t.point.y),r.outsideParts,r.coincidentParts,r.insideParts)}}else if(n instanceof y.CurvePrimitive){const t=g.CurveCollection.createCurveLocationDetailOnAnyCurvePrimitive(n);if(t){R(n,RegionOps.testPointInOnOutRegionXY(e,t.point.x,t.point.y),r.outsideParts,r.coincidentParts,r.insideParts)}}return r}static rectangleEdgeTransform(t,e=!0){if(t instanceof C.LineString3d)return this.rectangleEdgeTransform(t.packedPoints);if(t instanceof c.IndexedXYZCollection){let r;if(e&&5===t.length){if(!m.Geometry.isSmallMetricDistance(t.distanceIndexIndex(0,4)))return;r=t}else if(e||4!==t.length){if(t.length<(e?5:4))return;r=I.GrowableXYZArray.create(t),b.PolylineCompressionContext.compressInPlaceByShortEdgeLength(r,m.Geometry.smallMetricDistance)}else r=t;const i=r.vectorIndexIndex(0,1),n=r.vectorIndexIndex(0,3),s=r.vectorIndexIndex(1,2),o=i.crossProduct(n);if(o.normalizeInPlace()&&s.isAlmostEqual(n)&&i.isPerpendicularTo(n))return A.Transform.createOriginAndMatrixColumns(r.getPoint3dAtUncheckedPointIndex(0),i,n,o)}else{if(Array.isArray(t))return this.rectangleEdgeTransform(new w.Point3dArrayCarrier(t),e);if(t instanceof P.Loop&&1===t.children.length&&t.children[0]instanceof C.LineString3d)return this.rectangleEdgeTransform(t.children[0].packedPoints,!0);if(t instanceof x.Path&&1===t.children.length&&t.children[0]instanceof C.LineString3d)return this.rectangleEdgeTransform(t.children[0].packedPoints,e);if(t instanceof g.CurveChain&&!t.checkForNonLinearPrimitives()){const e=t.getPackedStrokes();if(e)return this.rectangleEdgeTransform(e)}}}static consolidateAdjacentPrimitives(t,e){const r=new T.ConsolidateAdjacentCurvePrimitivesContext(e);t.dispatchToGeometryHandler(r)}}function R(t,e,r,i,n){e>0?n.push(t):e<0?r.push(t):i.push(t)}e.RegionOps=RegionOps},"./lib/curve/StrokeOptions.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Angle.js");class StrokeOptions{constructor(){this.shouldTriangulate=!1,this.defaultCircleStrokes=16}get needParams(){return void 0!==this._needParams&&this._needParams}set needParams(t){this._needParams=t}get needNormals(){return void 0!==this._needNormals&&this._needNormals}set needNormals(t){this._needNormals=t}set needTwoSided(t){this._needTwoSided=t}get needTwoSided(){return void 0!==this._needTwoSided&&this._needTwoSided}get hasMaxEdgeLength(){return void 0!==this.maxEdgeLength&&this.maxEdgeLength>0}applyMaxEdgeLength(t,e){return this.maxEdgeLength&&this.maxEdgeLength>0&&t*this.maxEdgeLength<e&&(t=i.Geometry.stepCount(this.maxEdgeLength,e,t)),t}applyAngleTol(t,e,r){return StrokeOptions.applyAngleTol(this,t,e,r)}static applyAngleTol(t,e,r,n){r=Math.abs(r);let s=n||Math.PI/8;return t&&t.angleTol&&t.angleTol.radians>0&&(s=t.angleTol.radians),e*s<r&&(e=i.Geometry.stepCount(s,r,e)),e}static applyMaxEdgeLength(t,e,r){return r<0&&(r=-r),e<1&&(e=1),t&&t.maxEdgeLength&&t.maxEdgeLength*e<r&&(e=i.Geometry.stepCount(t.maxEdgeLength,r,e)),e}applyTolerancesToArc(t,e=2*Math.PI){let r=1;return r=this.applyAngleTol(r,e,.25*Math.PI),r=this.applyMaxEdgeLength(r,e*t),r=this.applyChordTol(r,t,e),r=this.applyMinStrokesPerPrimitive(r)}applyChordTol(t,e,r){if(this.chordTol&&this.chordTol>0&&this.chordTol<e){const n=this.chordTol,s=2*Math.acos(1-n/e);t=i.Geometry.stepCount(s,r,t)}return t}applyChordTolToLengthAndRadians(t,e,r){if(this.chordTol&&this.chordTol>0){const n=i.Geometry.conditionalDivideFraction(e,r);if(void 0!==n)return this.applyChordTol(t,n,r)}return t}applyMinStrokesPerPrimitive(t){return void 0!==this.minStrokesPerPrimitive&&Number.isFinite(this.minStrokesPerPrimitive)&&this.minStrokesPerPrimitive>t&&(t=this.minStrokesPerPrimitive),t}static createForCurves(){const t=new StrokeOptions;return t.angleTol=n.Angle.createDegrees(15),t}static createForFacets(){const t=new StrokeOptions;return t.angleTol=n.Angle.createDegrees(22.5),t}}e.StrokeOptions=StrokeOptions},"./lib/curve/TransitionSpiral.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/AngleSweep.js"),s=r("./lib/geometry3d/Angle.js"),o=r("./lib/geometry3d/Point3dVector3d.js"),a=r("./lib/geometry3d/Segment1d.js"),c=r("./lib/geometry3d/Transform.js"),l=r("./lib/geometry3d/Matrix3d.js"),d=r("./lib/numerics/Quadrature.js"),h=r("./lib/curve/StrokeOptions.js"),u=r("./lib/curve/CurvePrimitive.js"),f=r("./lib/geometry3d/Ray3d.js"),g=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),p=r("./lib/curve/LineString3d.js");class TransitionConditionalProperties{constructor(t,e,r,i,n){this.radius0=t,this.radius1=e,this.bearing0=r,this.bearing1=i,this.curveLength=n}numDefinedProperties(){return i.Geometry.defined01(this.radius0)+i.Geometry.defined01(this.radius1)+i.Geometry.defined01(this.bearing0)+i.Geometry.defined01(this.bearing1)+i.Geometry.defined01(this.curveLength)}clone(){return new TransitionConditionalProperties(this.radius0,this.radius1,void 0===this.bearing0?void 0:this.bearing0.clone(),void 0===this.bearing1?void 0:this.bearing1.clone(),this.curveLength)}tryResolveAnySingleUnknown(){if(this.bearing0&&this.bearing1){const t=this.bearing1.radians-this.bearing0.radians;return void 0===this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1?(this.curveLength=TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,t),!0):void 0!==this.curveLength&&void 0===this.radius0&&void 0!==this.radius1?(this.radius0=TransitionSpiral3d.radius1LengthSweepRadiansToRadius0(this.radius1,this.curveLength,t),!0):void 0!==this.curveLength&&void 0!==this.radius0&&void 0===this.radius1&&(this.radius1=TransitionSpiral3d.radius0LengthSweepRadiansToRadius1(this.radius0,this.curveLength,t),!0)}return void 0!==this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1&&(this.bearing0?(this.bearing1=s.Angle.createRadians(this.bearing0.radians+TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0):!!this.bearing1&&(this.bearing0=s.Angle.createRadians(this.bearing1.radians-TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0))}almostEqualCoordinate(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&i.Geometry.isSameCoordinate(t,e)}almostEqualBearing(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqualNoPeriodShift(e)}isAlmostEqual(t){return!!this.almostEqualCoordinate(this.radius0,t.radius0)&&(!!this.almostEqualCoordinate(this.radius1,t.radius1)&&(!!this.almostEqualBearing(this.bearing0,t.bearing0)&&(!!this.almostEqualBearing(this.bearing1,t.bearing1)&&!!this.almostEqualCoordinate(this.curveLength,t.curveLength))))}applyScaleFactor(t){void 0!==this.radius0&&(this.radius0*=t),void 0!==this.radius1&&(this.radius1*=t),void 0!==this.curveLength&&(this.curveLength*=t)}}e.TransitionConditionalProperties=TransitionConditionalProperties;class TransitionSpiral3d extends u.CurvePrimitive{constructor(t,e,r,i,n,s,o){super(),this.curvePrimitiveType="transitionSpiral",this._spiralType=t,this.localToWorld=n,this.radius01=e,this.bearing01=r,this.localToWorld=n,this.activeFractionInterval=i,this._arcLength01=s,this._globalStrokes=p.LineString3d.create(),this._curvature01=a.Segment1d.create(0,1),this.refreshComputedProperties(),this._properties=o}static radiusToCurvature(t){return 0===t?0:1/t}static curvatureToRadius(t){return Math.abs(t)<i.Geometry.smallAngleRadians?0:1/t}static averageCurvature(t){return.5*(TransitionSpiral3d.radiusToCurvature(t.x0)+TransitionSpiral3d.radiusToCurvature(t.x1))}static averageCurvatureR0R1(t,e){return.5*(TransitionSpiral3d.radiusToCurvature(t)+TransitionSpiral3d.radiusToCurvature(e))}static radiusRadiusSweepRadiansToArcLength(t,e,r){return Math.abs(r/TransitionSpiral3d.averageCurvatureR0R1(t,e))}static radiusRadiusLengthToSweepRadians(t,e,r){return TransitionSpiral3d.averageCurvatureR0R1(t,e)*r}static radius0LengthSweepRadiansToRadius1(t,e,r){return TransitionSpiral3d.curvatureToRadius(2*r/e-TransitionSpiral3d.radiusToCurvature(t))}static radius1LengthSweepRadiansToRadius0(t,e,r){return TransitionSpiral3d.curvatureToRadius(2*r/e-TransitionSpiral3d.radiusToCurvature(t))}get activeStrokes(){return void 0!==this._activeStrokes?this._activeStrokes:this._globalStrokes}get originalProperties(){return this._properties}getSpiralType(){return void 0===this._spiralType?TransitionSpiral3d.defaultSpiralType:this._spiralType}globalFractionToBearingRadians(t){return this.bearing01.startRadians+t*this._arcLength01*(this._curvature01.x0+.5*t*(this._curvature01.x1-this._curvature01.x0))}globalFractionToCurvature(t){return this._curvature01.fractionToPoint(t)}fractionToBearingRadians(t){const e=this.activeFractionInterval.fractionToPoint(t);return this.bearing01.startRadians+e*this._arcLength01*(this._curvature01.x0+.5*e*(this._curvature01.x1-this._curvature01.x0))}fractionToCurvature(t){return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(t))}static initWorkSpace(){TransitionSpiral3d._gaussFraction=new Float64Array(5),TransitionSpiral3d._gaussWeight=new Float64Array(5),TransitionSpiral3d._gaussMapper=d.Quadrature.setupGauss5}fullSpiralIncrementalIntegral(t,e,r,i){const n=TransitionSpiral3d._gaussFraction,s=TransitionSpiral3d._gaussWeight,o=TransitionSpiral3d._gaussMapper(e,r,n,s),a=this._arcLength01;let c=0,d=0,h=0;for(let l=0;l<o;l++){const t=this.globalFractionToBearingRadians(n[l]);d+=(c=s[l]*a)*Math.cos(t),h+=c*Math.sin(t)}i?l.Matrix3d.xyzPlusMatrixTimesXYZ(t,this.localToWorld.matrix,{x:d,y:h,z:0},t):t.addXYZInPlace(d,h,0)}refreshComputedProperties(){this._curvature01=a.Segment1d.create(TransitionSpiral3d.radiusToCurvature(this.radius01.x0),TransitionSpiral3d.radiusToCurvature(this.radius01.x1)),this._globalStrokes.clear();const t=o.Point3d.create();this._globalStrokes.appendStrokePoint(t);for(let e=1;e<=16;e++){const r=1/16*(e-1),i=e*(1/16);this.fullSpiralIncrementalIntegral(t,r,i,!1),this._globalStrokes.appendStrokePoint(t)}if(this._globalStrokes.tryTransformInPlace(this.localToWorld),!this.activeFractionInterval.isExact01){void 0===this._activeStrokes&&(this._activeStrokes=p.LineString3d.create()),this._activeStrokes.clear();for(let t=0;t<=16;t++){const e=t*(1/16);this._activeStrokes.addPoint(this.fractionToPoint(e))}}}static createRadiusRadiusBearingBearing(t,e,r,i){const n=TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(t.x0,t.x1,e.sweepRadians);return new TransitionSpiral3d("clothoid",t.clone(),e.clone(),r.clone(),i.clone(),n,new TransitionConditionalProperties(t.x0,t.x1,e.startAngle.clone(),e.endAngle.clone(),void 0))}static create(t,e,r,i,s,o,c,l){const d=new TransitionConditionalProperties(e,r,i,s,o),h=d.clone();if(d.tryResolveAnySingleUnknown())return void 0===c&&(c=a.Segment1d.create(0,1)),new TransitionSpiral3d(t,a.Segment1d.create(d.radius0,d.radius1),n.AngleSweep.createStartEnd(d.bearing0,d.bearing1),c?c.clone():a.Segment1d.create(0,1),l,d.curveLength,h)}setFrom(t){return this.localToWorld.setFrom(t.localToWorld),this.radius01.setFrom(t.radius01),this._curvature01.setFrom(t._curvature01),this.bearing01.setFrom(t.bearing01),this.localToWorld.setFrom(t.localToWorld),this.activeFractionInterval.setFrom(t.activeFractionInterval),this._arcLength01=t._arcLength01,this}clone(){return TransitionSpiral3d.createRadiusRadiusBearingBearing(this.radius01,this.bearing01,this.activeFractionInterval,this.localToWorld)}tryTransformInPlace(t){const e=t.matrix.factorRigidWithSignedScale();if(void 0!==e){const r=t.multiplyTransformTransform(this.localToWorld),i=e.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);this.localToWorld=c.Transform.createOriginAndMatrix(r.origin,i),this._curvature01.x0/=e.scale,this._curvature01.x1/=e.scale,this.radius01.x0*=e.scale,this.radius01.x1*=e.scale,this._arcLength01*=e.scale,this.originalProperties&&this.originalProperties.applyScaleFactor(e.scale)}return this.refreshComputedProperties(),!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}startPoint(){return this.activeStrokes.startPoint()}endPoint(){return this.activeStrokes.endPoint()}isInPlane(t){return t.isPointInPlane(this.localToWorld.origin)&&i.Geometry.isSameCoordinate(0,this.localToWorld.matrix.dotColumnX(t.getNormalRef()))&&i.Geometry.isSameCoordinate(0,this.localToWorld.matrix.dotColumnY(t.getNormalRef()))}quickLength(){return this._arcLength01}curveLength(){return this._arcLength01}isSameGeometryClass(t){return t instanceof TransitionSpiral3d}emitStrokes(t,e){this.activeStrokes.emitStrokes(t,e)}emitStrokableParts(t,e){const r=this.computeStrokeCountForOptions(e),i=this.activeStrokes;t.startParentCurvePrimitive(this),r<=i.numPoints()?this.activeStrokes.emitStrokableParts(t,e):t.announceIntervalForUniformStepStrokes(this,r,0,1),t.endParentCurvePrimitive(this)}computeStrokeCountForOptions(t){let e=1;if(t){const r=Math.min(Math.abs(this.radius01.x0),Math.abs(this.radius01.x1));e=t.applyTolerancesToArc(r,this.bearing01.sweepRadians),e=t.applyMaxEdgeLength(e,this.curveLength()),e=t.applyMinStrokesPerPrimitive(e)}else e=h.StrokeOptions.applyAngleTol(void 0,4,this.bearing01.sweepRadians);return e}reverseInPlace(){this.activeFractionInterval.reverseInPlace(),void 0===this._activeStrokes&&(this._activeStrokes=this._globalStrokes.clone()),this._activeStrokes.reverseInPlace()}fractionToPoint(t,e){let r=this.activeFractionInterval.fractionToPoint(t);r=i.Geometry.clampToStartEnd(r,0,1);const n=this._globalStrokes.packedPoints.length-1,s=Math.trunc(r*n),o=s/n;return e=this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(s,e),this.fullSpiralIncrementalIntegral(e,o,r,!0),e}fractionToPointAndDerivative(t,e){const r=this.activeFractionInterval.fractionToPoint(t);e=e||f.Ray3d.createZero(),this.fractionToPoint(t,e.origin);const i=this.globalFractionToBearingRadians(r),n=this._arcLength01*this.activeFractionInterval.signedDelta();return this.localToWorld.matrix.multiplyXY(n*Math.cos(i),n*Math.sin(i),e.direction),e}fractionToFrenetFrame(t,e){const r=this.activeFractionInterval.fractionToPoint(t);(e=e||c.Transform.createIdentity()).origin.setFrom(this.fractionToPoint(t)),l.Matrix3d.createRigidFromMatrix3d(this.localToWorld.matrix,i.AxisOrder.XYZ,e.matrix);const n=this.globalFractionToBearingRadians(r),s=Math.cos(n),o=Math.sin(n);return e.matrix.applyGivensColumnOp(0,1,s,-o),e}fractionToPointAnd2Derivatives(t,e){const r=this.activeFractionInterval.fractionToPoint(t),i=this.fractionToPoint(t),n=this.globalFractionToBearingRadians(r),s=Math.cos(n),o=Math.sin(n),a=this.activeFractionInterval.signedDelta(),c=this._arcLength01*a,l=c*a,d=this.localToWorld.matrix.multiplyXY(c*s,c*o),h=this.localToWorld.matrix.multiplyXY(-l*o,l*s);return h.scaleInPlace(this.globalFractionToCurvature(r)),g.Plane3dByOriginAndVectors.createCapture(i,d,h,e)}dispatchToGeometryHandler(t){return t.handleTransitionSpiral(this)}extendRange(t,e){this.activeStrokes.extendRange(t,e)}isAlmostEqual(t){return t instanceof TransitionSpiral3d&&(this.radius01.isAlmostEqual(t.radius01)&&this.bearing01.isAlmostEqualAllowPeriodShift(t.bearing01)&&this.localToWorld.isAlmostEqual(t.localToWorld)&&i.Geometry.isSameCoordinate(this._arcLength01,t._arcLength01)&&this.activeFractionInterval.isAlmostEqual(t.activeFractionInterval)&&this._curvature01.isAlmostEqual(t._curvature01))}}e.TransitionSpiral3d=TransitionSpiral3d,TransitionSpiral3d.defaultSpiralType="clothoid",TransitionSpiral3d.initWorkSpace()},"./lib/curve/UnionRegion.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurveCollection.js"),n=r("./lib/curve/Loop.js"),s=r("./lib/curve/ParityRegion.js");class UnionRegion extends i.CurveCollection{constructor(){super(),this.curveCollectionType="unionRegion",this._children=[]}isSameGeometryClass(t){return t instanceof UnionRegion}get children(){return this._children}static create(...t){const e=new UnionRegion;for(const r of t)e.tryAddChild(r);return e}dgnBoundaryType(){return 5}announceToCurveProcessor(t,e=-1){return t.announceUnionRegion(this,e)}cloneStroked(t){const e=new UnionRegion;let r;for(r of this._children){const i=r.cloneStroked(t);i&&e.children.push(i)}return e}cloneEmptyPeer(){return new UnionRegion}tryAddChild(t){return!!(t&&t instanceof s.ParityRegion||t instanceof n.Loop)&&(this._children.push(t),!0)}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleUnionRegion(this)}}e.UnionRegion=UnionRegion},"./lib/geometry-core.js":function(t,e,r){"use strict";function i(t){for(var r in t)e.hasOwnProperty(r)||(e[r]=t[r])}Object.defineProperty(e,"__esModule",{value:!0}),i(r("./lib/geometry3d/Angle.js")),i(r("./lib/geometry3d/AngleSweep.js")),i(r("./lib/geometry3d/BarycentricTriangle.js")),i(r("./lib/geometry3d/BilinearPatch.js")),i(r("./lib/geometry3d/FrameBuilder.js")),i(r("./lib/geometry3d/FrustumAnimation.js")),i(r("./lib/geometry3d/GeometryHandler.js")),i(r("./lib/geometry3d/GrowableBlockedArray.js")),i(r("./lib/geometry3d/GrowableFloat64Array.js")),i(r("./lib/geometry3d/GrowableXYArray.js")),i(r("./lib/geometry3d/GrowableXYZArray.js")),i(r("./lib/geometry3d/IndexedCollectionInterval.js")),i(r("./lib/geometry3d/IndexedXYCollection.js")),i(r("./lib/geometry3d/IndexedXYZCollection.js")),i(r("./lib/geometry3d/Matrix3d.js")),i(r("./lib/geometry3d/OrderedRotationAngles.js")),i(r("./lib/geometry3d/Plane3dByOriginAndUnitNormal.js")),i(r("./lib/geometry3d/Plane3dByOriginAndVectors.js")),i(r("./lib/geometry3d/Point2dArrayCarrier.js")),i(r("./lib/geometry3d/Point2dVector2d.js")),i(r("./lib/geometry3d/Point3dVector3d.js")),i(r("./lib/geometry3d/PointHelpers.js")),i(r("./lib/geometry3d/Point3dArrayCarrier.js")),i(r("./lib/geometry3d/PolylineOps.js")),i(r("./lib/geometry3d/PolygonOps.js")),i(r("./lib/geometry3d/Range.js")),i(r("./lib/geometry3d/Ray3d.js")),i(r("./lib/geometry3d/Segment1d.js")),i(r("./lib/geometry3d/Transform.js")),i(r("./lib/geometry3d/YawPitchRollAngles.js")),i(r("./lib/Geometry.js")),i(r("./lib/Constant.js")),i(r("./lib/clipping/ClipPlane.js")),i(r("./lib/clipping/ConvexClipPlaneSet.js")),i(r("./lib/clipping/UnionOfConvexClipPlaneSets.js")),i(r("./lib/clipping/ClipPrimitive.js")),i(r("./lib/clipping/ClipVector.js")),i(r("./lib/clipping/ClipUtils.js")),i(r("./lib/numerics/ConvexPolygon2d.js")),i(r("./lib/geometry4d/PlaneByOriginAndVectors4d.js")),i(r("./lib/geometry4d/Point4d.js")),i(r("./lib/geometry4d/Matrix4d.js")),i(r("./lib/geometry4d/Map4d.js")),i(r("./lib/geometry4d/MomentData.js")),i(r("./lib/numerics/BezierPolynomials.js")),i(r("./lib/numerics/ClusterableArray.js")),i(r("./lib/numerics/Newton.js")),i(r("./lib/numerics/Complex.js")),i(r("./lib/numerics/ConvexPolygon2d.js")),i(r("./lib/numerics/Newton.js")),i(r("./lib/numerics/PascalCoefficients.js")),i(r("./lib/numerics/Polynomials.js")),i(r("./lib/numerics/Quadrature.js")),i(r("./lib/numerics/Range1dArray.js")),i(r("./lib/numerics/TriDiagonalSystem.js")),i(r("./lib/curve/Arc3d.js")),i(r("./lib/curve/ConstructCurveBetweenCurves.js")),i(r("./lib/curve/CoordinateXYZ.js")),i(r("./lib/curve/CurveChainWithDistanceIndex.js")),i(r("./lib/curve/CurveExtendMode.js")),i(r("./lib/curve/CurveCollection.js")),i(r("./lib/curve/CurveCurve.js")),i(r("./lib/curve/CurveCurveIntersectXY.js")),i(r("./lib/curve/CurveCurveIntersectXYZ.js")),i(r("./lib/curve/CurveLocationDetail.js")),i(r("./lib/curve/CurveFactory.js")),i(r("./lib/curve/CurvePrimitive.js")),i(r("./lib/curve/CurveProcessor.js")),i(r("./lib/curve/GeometryQuery.js")),i(r("./lib/curve/LineSegment3d.js")),i(r("./lib/curve/LineString3d.js")),i(r("./lib/curve/Loop.js")),i(r("./lib/curve/ParityRegion.js")),i(r("./lib/curve/Path.js")),i(r("./lib/curve/RegionMomentsXY.js")),i(r("./lib/curve/RegionOps.js")),i(r("./lib/curve/PolygonOffsetContext.js")),i(r("./lib/curve/PointString3d.js")),i(r("./lib/curve/StrokeOptions.js")),i(r("./lib/curve/TransitionSpiral.js")),i(r("./lib/curve/UnionRegion.js")),i(r("./lib/curve/Query/StrokeCountMap.js")),i(r("./lib/solid/Box.js")),i(r("./lib/solid/Cone.js")),i(r("./lib/solid/LinearSweep.js")),i(r("./lib/solid/RotationalSweep.js")),i(r("./lib/solid/RuledSweep.js")),i(r("./lib/solid/SolidPrimitive.js")),i(r("./lib/solid/Sphere.js")),i(r("./lib/solid/SweepContour.js")),i(r("./lib/solid/TorusPipe.js")),i(r("./lib/bspline/Bezier1dNd.js")),i(r("./lib/bspline/BezierCurveBase.js")),i(r("./lib/bspline/BezierCurve3d.js")),i(r("./lib/bspline/BezierCurve3dH.js")),i(r("./lib/bspline/BSplineCurve.js")),i(r("./lib/bspline/BSpline1dNd.js")),i(r("./lib/bspline/BSplineCurve3dH.js")),i(r("./lib/bspline/BSplineSurface.js")),i(r("./lib/bspline/KnotVector.js")),i(r("./lib/polyface/AuxData.js")),i(r("./lib/polyface/BoxTopology.js")),i(r("./lib/polyface/FacetFaceData.js")),i(r("./lib/polyface/Polyface.js")),i(r("./lib/polyface/PolyfaceBuilder.js")),i(r("./lib/polyface/PolyfaceData.js")),i(r("./lib/polyface/PolyfaceQuery.js")),i(r("./lib/polyface/PolyfaceClip.js")),i(r("./lib/topology/Graph.js")),i(r("./lib/topology/Triangulation.js")),i(r("./lib/serialization/IModelJsonSchema.js")),i(r("./lib/serialization/DeepCompare.js")),i(r("./lib/serialization/GeometrySamples.js")),"undefined"!==typeof window&&window&&(window.iModelJsVersions||(window.iModelJsVersions=new Map),window.iModelJsVersions.set("geometry-core","1.7.0"))},"./lib/geometry3d/Angle.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js");class Angle{constructor(t=0,e){this._radians=t,this._degrees=e}clone(){return new Angle(this._radians,this._degrees)}freeze(){Object.freeze(this)}static createDegrees(t){return new Angle(Angle.degreesToRadians(t),t)}static createRadians(t){return new Angle(t)}cloneScaled(t){return new Angle(this.radians*t)}setRadians(t){this._radians=t,this._degrees=void 0}setDegrees(t){this._radians=Angle.degreesToRadians(t),this._degrees=t}static create360(){return new Angle(2*Math.PI,360)}static createAtan2(t,e){return new Angle(Math.atan2(t,e))}setFrom(t){this._radians=t._radians,this._degrees=t._degrees}static fromJSON(t,e){const r=new Angle;return r.setFromJSON(t,e),r}setFromJSON(t,e){this._radians=e||0,t&&("number"===typeof t?this.setDegrees(t):"number"===typeof t.degrees?this.setDegrees(t.degrees):"number"===typeof t._degrees?this.setDegrees(t._degrees):"number"===typeof t.radians?this.setRadians(t.radians):"number"===typeof t._radians&&this.setRadians(t._radians))}toJSON(){return this.degrees}toJSONRadians(){return{radians:this.radians}}get radians(){return this._radians}get degrees(){return void 0!==this._degrees?this._degrees:Angle.radiansToDegrees(this._radians)}static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){if(t<0)return-Angle.radiansToDegrees(-t);const e=Math.PI;return t<=.25*e?180/e*t:t<.75*e?90+(t-.5*e)/e*180:t<=1.25*e?180+(t-e)/e*180:t<=1.75*e?270+(t-1.5*e)/e*180:360+(t-2*e)/e*180}cos(){return Math.cos(this._radians)}sin(){return Math.sin(this._radians)}tan(){return Math.tan(this._radians)}static isFullCircleRadians(t){return Math.abs(t)>=i.Geometry.fullCircleRadiansMinusSmallAngle}static isHalfCircleRadians(t){return Math.abs(Math.abs(t))-Math.PI<=i.Geometry.smallAngleRadians}get isFullCircle(){return Angle.isFullCircleRadians(this._radians)}get isHalfCircle(){return Angle.isHalfCircleRadians(this._radians)}static adjustDegrees0To360(t){if(t>=0){const e=360;return t<e?t:t-Math.floor(t/e)*e}return 360-Angle.adjustDegrees0To360(-t)}static adjustDegreesSigned180(t){if(Math.abs(t)<=180)return t;if(t>=0){const e=360;return t-(1+Math.floor((t-180)/e))*e}return-Angle.adjustDegreesSigned180(-t)}static adjustRadians0To2Pi(t){if(t>=0){const e=2*Math.PI;return t<e?t:t-Math.floor(t/e)*e}const e=Angle.adjustRadians0To2Pi(-t);return 2*Math.PI-e}static adjustRadiansMinusPiPlusPi(t){if(Math.abs(t)<=Math.PI)return t;if(t>=0){const e=2*Math.PI;return t-(1+Math.floor((t-Math.PI)/e))*e}return-Angle.adjustRadiansMinusPiPlusPi(-t)}static zero(){return new Angle(0)}get isExactZero(){return 0===this.radians}get isAlmostZero(){return Math.abs(this.radians)<i.Geometry.smallAngleRadians}static createDegreesAdjustPositive(t){return Angle.createDegrees(Angle.adjustDegrees0To360(t))}static createDegreesAdjustSigned180(t){return Angle.createDegrees(Angle.adjustDegreesSigned180(t))}static isAlmostEqualRadiansAllowPeriodShift(t,e){const r=Math.abs(t-e);if(r<=i.Geometry.smallAngleRadians)return!0;const n=2*Math.PI;if(Math.abs(r-n)<=i.Geometry.smallAngleRadians)return!0;const s=r-Math.round(r/n)*n;return Math.abs(s)<=i.Geometry.smallAngleRadians}isAlmostEqualAllowPeriodShift(t){return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians,t._radians)}isAlmostEqualNoPeriodShift(t){return Math.abs(this._radians-t._radians)<i.Geometry.smallAngleRadians}isAlmostEqual(t){return this.isAlmostEqualNoPeriodShift(t)}static isAlmostEqualRadiansNoPeriodShift(t,e){return Math.abs(t-e)<i.Geometry.smallAngleRadians}static isPerpendicularDotSet(t,e,r){return t>i.Geometry.smallMetricDistanceSquared&&e>i.Geometry.smallMetricDistanceSquared&&r*r<=i.Geometry.smallAngleRadiansSquared*t*e}static trigValuesToHalfAngleTrigValues(t,e){const r=i.Geometry.hypotenuseXY(t,e);if(r<i.Geometry.smallMetricDistance)return{c:1,s:0,radians:0};{let i=1,n=0;const s=t/r,o=e/r;return s>=0?n=o/(2*(i=Math.sqrt(.5*(1+s)))):i=o/(2*(n=o>0?Math.sqrt(.5*(1-s)):-Math.sqrt(.5*(1-s)))),{c:i,s:n,radians:Math.atan2(n,i)}}}static cleanupTrigValue(t,e=1e-15){const r=Math.abs(t);if(r<=e)return 0;let i=Math.abs(r-.5);return i<=e?t<0?-.5:.5:(i=Math.abs(r-1))<=e?t<0?-1:1:t}static dotProductsToHalfAngleTrigValues(t,e,r,n=!0){const s=t-e,o=2*r;return n&&Math.abs(o)<i.Geometry.smallAngleRadians*(Math.abs(t)+Math.abs(e))?{c:1,s:0,radians:0}:Angle.trigValuesToHalfAngleTrigValues(s,o)}static radiansBetweenVectorsXYZ(t,e,r,n,s,o){const a=t*n+e*s+r*o;return Math.atan2(i.Geometry.crossProductMagnitude(t,e,r,n,s,o),a)}addMultipleOf2PiInPlace(t){void 0!==this._degrees?(this._degrees+=360*t,this._radians=Angle.degreesToRadians(this._degrees)):this._radians+=t*Angle.pi2Radians}}e.Angle=Angle,Angle.piOver4Radians=.7853981633974483,Angle.piOver2Radians=1.5707963267948966,Angle.piRadians=3.141592653589793,Angle.pi2Radians=6.283185307179586,Angle.degreesPerRadian=45/Angle.piOver4Radians,Angle.radiansPerDegree=Angle.piOver4Radians/45,Angle.piOver12Radians=.26179938779914946},"./lib/geometry3d/AngleSweep.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Angle.js"),n=r("./lib/Geometry.js");class AngleSweep{constructor(t=0,e=0){this._radians0=t,this._radians1=e}get startDegrees(){return i.Angle.radiansToDegrees(this._radians0)}get endDegrees(){return i.Angle.radiansToDegrees(this._radians1)}get sweepDegrees(){return i.Angle.radiansToDegrees(this._radians1-this._radians0)}get startRadians(){return this._radians0}get endRadians(){return this._radians1}get sweepRadians(){return this._radians1-this._radians0}get startAngle(){return i.Angle.createRadians(this._radians0)}get endAngle(){return i.Angle.createRadians(this._radians1)}static createStartEndRadians(t=0,e=2*Math.PI,r){return(r=r||new AngleSweep).setStartEndRadians(t,e),r}cloneMinusRadians(t){return new AngleSweep(this._radians0-t,this._radians1-t)}static createStartEndDegrees(t=0,e=360,r){return AngleSweep.createStartEndRadians(i.Angle.degreesToRadians(t),i.Angle.degreesToRadians(e),r)}static createStartEnd(t,e,r){return(r=r||new AngleSweep).setStartEndRadians(t.radians,e.radians),r}static createStartSweep(t,e,r){return AngleSweep.createStartSweepRadians(t.radians,e.radians,r)}interpolate(t,e){return new AngleSweep(n.Geometry.interpolate(this._radians0,t,e._radians0),n.Geometry.interpolate(this._radians1,t,e._radians1))}static createStartSweepRadians(t=0,e=Math.PI,r){return(r=r||new AngleSweep).setStartEndRadians(t,t+e),r}static createStartSweepDegrees(t=0,e=360,r){return AngleSweep.createStartEndRadians(i.Angle.degreesToRadians(t),i.Angle.degreesToRadians(t+e),r)}setStartEndRadians(t=0,e=2*Math.PI){const r=e-t;i.Angle.isFullCircleRadians(r)&&(e=t+(r>0?2:-2)*Math.PI),this._radians0=t,this._radians1=e}setStartEndDegrees(t=0,e=360){this.setStartEndRadians(i.Angle.degreesToRadians(t),i.Angle.degreesToRadians(e))}setFrom(t){this._radians0=t._radians0,this._radians1=t._radians1}static create360(t){return new AngleSweep(t=t||0,t+2*Math.PI)}static createFullLatitude(){return AngleSweep.createStartEndRadians(-.5*Math.PI,.5*Math.PI)}reverseInPlace(){const t=this._radians0;this._radians0=this._radians1,this._radians1=t}capLatitudeInPlace(){const t=.5*Math.PI;this._radians0=n.Geometry.clampToStartEnd(this._radians0,-t,t),this._radians1=n.Geometry.clampToStartEnd(this._radians1,-t,t)}get isCCW(){return this._radians1>=this._radians0}get isFullCircle(){return i.Angle.isFullCircleRadians(this.sweepRadians)}get isFullLatitudeSweep(){const t=.5*Math.PI;return i.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0,-t)&&i.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1,t)}clone(){return new AngleSweep(this._radians0,this._radians1)}fractionToRadians(t){return t<.5?this._radians0+t*(this._radians1-this._radians0):this._radians1+(t-1)*(this._radians1-this._radians0)}fractionToAngle(t){return i.Angle.createRadians(this.fractionToRadians(t))}fractionPeriod(){return n.Geometry.safeDivideFraction(2*Math.PI,Math.abs(this._radians1-this._radians0),1)}angleToUnboundedFraction(t){return n.Geometry.safeDivideFraction(t.radians-this._radians0,this._radians1-this._radians0,1)}angleToPositivePeriodicFraction(t){return this.radiansToPositivePeriodicFraction(t.radians)}radiansArraytoPositivePeriodicFractions(t){const e=t.length;for(let r=0;r<e;r++)t.reassign(r,this.radiansToPositivePeriodicFraction(t.atUncheckedIndex(r)))}radiansToPositivePeriodicFraction(t){if(i.Angle.isAlmostEqualRadiansAllowPeriodShift(t,this._radians0))return 0;if(i.Angle.isAlmostEqualRadiansAllowPeriodShift(t,this._radians1))return 1;const e=this._radians1-this._radians0,r=t-this._radians0;if(e>0){const t=i.Angle.adjustRadians0To2Pi(r);return n.Geometry.safeDivideFraction(t,e,0)}const s=i.Angle.adjustRadians0To2Pi(-r);return n.Geometry.safeDivideFraction(s,-e,0)}angleToSignedPeriodicFraction(t){return this.radiansToSignedPeriodicFraction(t.radians)}radiansToSignedPeriodicFraction(t){if(i.Angle.isAlmostEqualRadiansAllowPeriodShift(t,this._radians0))return 0;if(i.Angle.isAlmostEqualRadiansAllowPeriodShift(t,this._radians1))return 1;const e=this._radians1-this._radians0,r=t-this._radians0-.5*e;if(e>0){const t=i.Angle.adjustRadiansMinusPiPlusPi(r);return.5+n.Geometry.safeDivideFraction(t,e,0)}const s=i.Angle.adjustRadiansMinusPiPlusPi(-r);return.5+n.Geometry.safeDivideFraction(s,-e,0)}isAngleInSweep(t){return this.isRadiansInSweep(t.radians)}isRadiansInSweep(t){return(t-this._radians0)*(t-this._radians1)<=0||this.radiansToPositivePeriodicFraction(t)<=1}setFromJSON(t){t?t instanceof AngleSweep?this.setFrom(t):n.Geometry.isNumberArray(t.degrees,2)?this.setStartEndDegrees(t.degrees[0],t.degrees[1]):n.Geometry.isNumberArray(t.radians,2)?this.setStartEndRadians(t.radians[0],t.radians[1]):n.Geometry.isNumberArray(t,2)&&this.setStartEndDegrees(t[0],t[1]):this.setStartEndRadians()}static fromJSON(t){const e=AngleSweep.create360();return e.setFromJSON(t),e}toJSON(){return[this.startDegrees,this.endDegrees]}isAlmostEqualAllowPeriodShift(t){return i.Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians0,t._radians0)&&i.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1-this._radians0,t._radians1-t._radians0)}isAlmostEqualNoPeriodShift(t){return i.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0,t._radians0)&&i.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1-this._radians0,t._radians1-t._radians0)}isAlmostEqual(t){return this.isAlmostEqualNoPeriodShift(t)}}e.AngleSweep=AngleSweep},"./lib/geometry3d/BarycentricTriangle.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/Geometry.js");class BarycentricTriangle{constructor(t,e,r){this.points=[],this.points.push(t),this.points.push(e),this.points.push(r)}static createXYZXYZXYZ(t,e,r,n,s,o,a,c,l,d){return d?(d.points[0].set(t,e,r),d.points[1].set(n,s,o),d.points[2].set(a,c,l),d):new this(i.Point3d.create(t,e,r),i.Point3d.create(n,s,o),i.Point3d.create(a,c,l))}static create(t,e,r,i){return i?(i.set(t,e,r),i):new this(t.clone(),e.clone(),r.clone())}clone(t){return BarycentricTriangle.create(this.points[0],this.points[1],this.points[2],t)}get aspectRatio(){return n.Geometry.safeDivideFraction(.5*this.points[0].crossProductToPointsMagnitude(this.points[1],this.points[2]),this.points[0].distanceSquared(this.points[1])+this.points[1].distanceSquared(this.points[2])+this.points[2].distanceSquared(this.points[0]),0)}get area(){return.5*this.points[0].crossProductToPointsMagnitude(this.points[1],this.points[2])}fractionToPoint(t,e,r,n){return i.Point3d.createAdd3Scaled(this.points[0],t,this.points[1],e,this.points[2],r,n)}setFrom(t){this.points[0].setFromPoint3d(t.points[0]),this.points[1].setFromPoint3d(t.points[1]),this.points[2].setFromPoint3d(t.points[2])}set(t,e,r){this.points[0].setFromPoint3d(t),this.points[1].setFromPoint3d(e),this.points[2].setFromPoint3d(r)}dotProductOfCrossProductsFromOrigin(t){return BarycentricTriangle._workVector0=this.points[0].crossProductToPoints(this.points[1],this.points[2],BarycentricTriangle._workVector0),BarycentricTriangle._workVector1=t.points[0].crossProductToPoints(t.points[1],t.points[2],BarycentricTriangle._workVector1),BarycentricTriangle._workVector0.dotProduct(BarycentricTriangle._workVector1)}centroid(t){return i.Point3d.create((this.points[0].x+this.points[1].x+this.points[2].x)/3,(this.points[0].y+this.points[1].y+this.points[2].y)/3,(this.points[0].z+this.points[1].z+this.points[2].z)/3,t)}isAlmostEqual(t){return this.points[0].isAlmostEqual(t.points[0])&&this.points[1].isAlmostEqual(t.points[1])&&this.points[2].isAlmostEqual(t.points[2])}}e.BarycentricTriangle=BarycentricTriangle},"./lib/geometry3d/BilinearPatch.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),s=r("./lib/Geometry.js"),o=r("./lib/numerics/Polynomials.js"),a=r("./lib/curve/CurveLocationDetail.js"),c=r("./lib/bspline/SurfaceLocationDetail.js");class BilinearPatch{constructor(t,e,r,i){this.point00=t,this.point10=e,this.point01=r,this.point11=i}static create(t,e,r,i){return new BilinearPatch(t.clone(),e.clone(),r.clone(),i.clone())}static createXYZ(t,e,r,n,s,o,a,c,l,d,h,u){return new BilinearPatch(i.Point3d.create(t,e,r),i.Point3d.create(n,s,o),i.Point3d.create(a,c,l),i.Point3d.create(d,h,u))}clone(){return new BilinearPatch(this.point00.clone(),this.point10.clone(),this.point01.clone(),this.point11.clone())}isAlmostEqual(t){return this.point00.isAlmostEqual(t.point00)&&this.point10.isAlmostEqual(t.point10)&&this.point01.isAlmostEqual(t.point01)&&this.point11.isAlmostEqual(t.point11)}tryTransformInPlace(t){return t.multiplyPoint3d(this.point00,this.point00),t.multiplyPoint3d(this.point10,this.point10),t.multiplyPoint3d(this.point01,this.point01),t.multiplyPoint3d(this.point11,this.point11),!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}extendRange(t,e){e?(t.extendTransformedPoint(e,this.point00),t.extendTransformedPoint(e,this.point10),t.extendTransformedPoint(e,this.point01),t.extendTransformedPoint(e,this.point11)):(t.extendPoint(this.point00),t.extendPoint(this.point10),t.extendPoint(this.point01),t.extendPoint(this.point11))}uvFractionToPoint(t,e,r){const n=(1-t)*(1-e),s=t*(1-e),o=(1-t)*e,a=t*e;return i.Point3d.create(n*this.point00.x+s*this.point10.x+o*this.point01.x+a*this.point11.x,n*this.point00.y+s*this.point10.y+o*this.point01.y+a*this.point11.y,n*this.point00.z+s*this.point10.z+o*this.point01.z+a*this.point11.z,r)}uvFractionToPointAndTangents(t,e,r){const i=1-t,s=1-e,o=i*s,a=t*s,c=i*e,l=t*e;return n.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(o*this.point00.x+a*this.point10.x+c*this.point01.x+l*this.point11.x,o*this.point00.y+a*this.point10.y+c*this.point01.y+l*this.point11.y,o*this.point00.z+a*this.point10.z+c*this.point01.z+l*this.point11.z,s*(this.point10.x-this.point00.x)+e*(this.point11.x-this.point01.x),s*(this.point10.y-this.point00.y)+e*(this.point11.y-this.point01.y),s*(this.point10.z-this.point00.z)+e*(this.point11.z-this.point01.z),i*(this.point01.x-this.point00.x)+t*(this.point11.x-this.point10.x),i*(this.point01.y-this.point00.y)+t*(this.point11.y-this.point10.y),i*(this.point01.z-this.point00.z)+t*(this.point11.z-this.point10.z),r)}static conditionalPivot(t,e,r,i){if(Math.abs(e[i][t])>Math.abs(e[r][t])){const t=e[r];e[r]=e[i],e[i]=t}}intersectRay(t){const e=this.point10.minus(this.point00),r=this.point01.minus(this.point00),i=this.point11.minus(this.point10);i.subtractInPlace(r);const n=[new Float64Array([-t.direction.x,this.point00.x-t.origin.x,e.x,r.x,i.x]),new Float64Array([-t.direction.y,this.point00.y-t.origin.y,e.y,r.y,i.y]),new Float64Array([-t.direction.z,this.point00.z-t.origin.z,e.z,r.z,i.z])];BilinearPatch.conditionalPivot(0,n,0,1),BilinearPatch.conditionalPivot(0,n,0,2),o.SmallSystem.eliminateFromPivot(n[0],0,n[1],-1),o.SmallSystem.eliminateFromPivot(n[0],0,n[2],-1);const s=o.SmallSystem.solveBilinearPair(n[1][1],n[1][2],n[1][3],n[1][4],n[2][1],n[2][2],n[2][3],n[2][4]);if(s){const e=[];for(const r of s){const i=-(n[0][1]+n[0][2]*r.x+(n[0][3]+n[0][4]*r.x)*r.y)/n[0][0],s=t.fractionToPoint(i);e.push(new c.CurveAndSurfaceLocationDetail(a.CurveLocationDetail.createRayFractionPoint(t,i,s),c.UVSurfaceLocationDetail.createSurfaceUVPoint(this,r,s)))}return e}}maxUEdgeLength(){return s.Geometry.maxXY(this.point00.distance(this.point10),this.point01.distance(this.point11))}maxVEdgeLength(){return s.Geometry.maxXY(this.point00.distance(this.point01),this.point10.distance(this.point11))}}e.BilinearPatch=BilinearPatch},"./lib/geometry3d/FrameBuilder.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/Transform.js"),o=r("./lib/geometry3d/Matrix3d.js"),a=r("./lib/curve/CurvePrimitive.js"),c=r("./lib/curve/CurveCollection.js"),l=r("./lib/bspline/BSplineCurve.js"),d=r("./lib/curve/Arc3d.js"),h=r("./lib/curve/LineSegment3d.js"),u=r("./lib/curve/LineString3d.js"),f=r("./lib/geometry3d/PointHelpers.js"),g=r("./lib/geometry3d/PolygonOps.js"),p=r("./lib/geometry3d/GrowableXYZArray.js");class FrameBuilder{constructor(){this.clear()}areStronglyIndependentVectors(t,e,r=i.Geometry.smallAngleRadians){if(void 0!==t&&void 0!==e){return t.smallerUnorientedRadiansTo(e)>r}return!1}clear(){this._origin=void 0,this._vector0=void 0,this._vector1=void 0,this._vector2=void 0}getValidatedFrame(t=!1){if(this._origin&&this._vector0&&this._vector1)if(t){if(this._vector2){const t=o.Matrix3d.createRigidFromColumns(this._vector0,this._vector1,i.AxisOrder.XYZ);if(t)return this._vector0.tripleProduct(this._vector1,this._vector2)<0&&t.scaleColumns(1,1,-1),s.Transform.createOriginAndMatrix(this._origin,t);const e=this._vector2;this._vector1=this._vector2=void 0,this.announceVector(e)}}else{const t=o.Matrix3d.createRigidFromColumns(this._vector0,this._vector1,i.AxisOrder.XYZ);if(t)return s.Transform.createOriginAndMatrix(this._origin,t);this._vector1=this._vector2=void 0}}applyDefaultUpVector(t){t&&this._vector0&&!this._vector1&&!t.isParallelTo(this._vector0)&&(this._vector1=t.crossProduct(this._vector0))}get hasOrigin(){return void 0!==this._origin}savedVectorCount(){return this._vector0?this._vector1?this._vector2?3:2:1:0}announcePoint(t){return this._origin?this._origin.isAlmostEqual(t)?this.savedVectorCount():this.announceVector(this._origin.vectorTo(t)):(this._origin=t.clone(),this.savedVectorCount())}announceVector(t){if(t.isAlmostZero)return this.savedVectorCount();if(!this._vector0)return this._vector0=t.clone(this._vector0),1;if(!this._vector1)return this.areStronglyIndependentVectors(t,this._vector0,1e-5)?(this._vector1=t.clone(this._vector1),2):1;if(!this._vector2){const e=this._vector0.unitCrossProduct(this._vector1);return e&&!i.Geometry.isSameCoordinate(0,e.dotProduct(t))?(this._vector2=t.clone(this._vector2),3):2}return 3}announce(t){if(!(this.savedVectorCount()>1))if(t instanceof n.Point3d)this.announcePoint(t);else if(t instanceof n.Vector3d)this.announceVector(t);else if(Array.isArray(t))for(const e of t){if(this.savedVectorCount()>1)break;this.announce(e)}else if(t instanceof a.CurvePrimitive){if(t instanceof h.LineSegment3d)this.announcePoint(t.startPoint()),this.announcePoint(t.endPoint());else if(t instanceof d.Arc3d){const e=t.fractionToPointAndDerivative(0);this.announcePoint(e.origin),this.announceVector(e.direction),this.announceVector(t.matrix.columnZCrossVector(e.direction))}else if(t instanceof u.LineString3d){for(const e of t.points)if(this.announcePoint(e),this.savedVectorCount()>1)break}else if(t instanceof l.BSplineCurve3d){const e=n.Point3d.create();for(let r=0;this.savedVectorCount()<2&&t.getPolePoint3d(r,e)instanceof n.Point3d;r++)this.announcePoint(e)}}else if(t instanceof c.CurveCollection){if(t.children)for(const e of t.children)if(this.announce(e),this.savedVectorCount()>1)break}else if(t instanceof p.GrowableXYZArray){const e=n.Point3d.create();for(let r=0;this.savedVectorCount()<2&&t.getPoint3dAtCheckedPointIndex(r,e)instanceof n.Point3d;r++)this.announcePoint(e)}}static createRightHandedFrame(t,...e){const r=new FrameBuilder;for(const i of e){r.announce(i),r.applyDefaultUpVector(t);const e=r.getValidatedFrame(!1);if(void 0!==e)return t&&e.matrix.dotColumnZ(t)<0&&e.matrix.scaleColumnsInPlace(1,-1,-1),e}for(const i of e)if(i instanceof c.CurveCollection){const t=i.children;if(t)for(const e of t)if(e instanceof a.CurvePrimitive){const t=e.fractionToFrenetFrame(0);if(t)return t}}}static createRightHandedLocalToWorld(...t){const e=new FrameBuilder;for(const r of t){e.announce(r);const t=e.getValidatedFrame(!1);if(void 0!==t)return t}}static createFrameToDistantPoints(t){if(t.length>2){const e=t[0].clone(),r=n.Vector3d.create();f.Point3dArray.indexOfMostDistantPoint(t,t[0],r);const a=n.Vector3d.create();f.Point3dArray.indexOfPointWithMaxCrossProductMagnitude(t,e,r,a);const c=o.Matrix3d.createRigidFromColumns(r,a,i.AxisOrder.XYZ);if(c)return s.Transform.createRefs(e,c)}}static createFrameWithCCWPolygon(t){if(t.length>2){const e=g.PolygonOps.centroidAreaNormal(t);if(e)return e.toRigidZFrame()}}static createLocalToWorldTransformInRange(t,e=i.AxisScaleSelect.NonUniformRangeContainment,r=0,n=0,a=0,c=1){if(t.isNull)return s.Transform.createIdentity();let l=1,d=1,h=1;return e===i.AxisScaleSelect.LongestRangeDirection?l=d=h=i.Geometry.correctSmallMetricDistance(t.maxLength(),c):e===i.AxisScaleSelect.NonUniformRangeContainment&&(l=i.Geometry.correctSmallMetricDistance(t.xLength(),c)*i.Geometry.maxAbsDiff(r,0,1),d=i.Geometry.correctSmallMetricDistance(t.yLength(),c)*i.Geometry.maxAbsDiff(n,0,1),h=i.Geometry.correctSmallMetricDistance(t.zLength(),c)*i.Geometry.maxAbsDiff(a,0,1)),s.Transform.createRefs(t.fractionToPoint(r,n,a),o.Matrix3d.createScale(l,d,h))}}e.FrameBuilder=FrameBuilder},"./lib/geometry3d/FrustumAnimation.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Transform.js"),s=r("./lib/geometry3d/PointHelpers.js"),o=r("./lib/geometry3d/Matrix3d.js"),a=r("./lib/Geometry.js");class SmoothTransformBetweenFrusta{constructor(t,e,r,i,n,s){this._localCornerA=e,this._localCornerB=i,this._localToWorldA=t,this._localToWorldB=r,this._rotationAxis=n,this._rotationAngle=s}get localToWorldA(){return this._localToWorldA}get localToWorldB(){return this._localToWorldB}static create(t,e,r=!0){const c=s.Point3dArray.evaluateTrilinearDerivativeTransform(t,.5,.5,.5),l=s.Point3dArray.evaluateTrilinearDerivativeTransform(e,.5,.5,.5),d=n.Transform.createOriginAndMatrix(c.origin,o.Matrix3d.createRigidFromMatrix3d(c.matrix,a.AxisOrder.ZXY)),h=n.Transform.createOriginAndMatrix(l.origin,o.Matrix3d.createRigidFromMatrix3d(l.matrix,a.AxisOrder.ZXY));if(d.matrix.computeCachedInverse(!0)&&h.matrix.computeCachedInverse(!0)){const o=h.matrix.multiplyMatrixMatrixInverse(d.matrix).getAxisAndAngleOfRotation(),u=d.multiplyInversePoint3dArray(t),f=h.multiplyInversePoint3dArray(e);if(r&&s.Point3dArray.isAlmostEqual(u,f)&&!o.angle.isAlmostZero){const r=i.Vector3d.createStartEnd(c.origin,l.origin),s=c.getOrigin().interpolate(.5,l.getOrigin()),u=o.axis.unitCrossProduct(r);if(u){const i=.5*r.magnitude(),c=a.Geometry.conditionalDivideFraction(i,Math.tan(.5*o.angle.radians));if(void 0!==c){const r=s.plusScaled(u,c),i=n.Transform.createOriginAndMatrix(r,d.matrix),a=n.Transform.createOriginAndMatrix(r,h.matrix),l=i.multiplyInversePoint3dArray(t),f=a.multiplyInversePoint3dArray(e);return new SmoothTransformBetweenFrusta(i,l,a,f,o.axis,o.angle)}}}return new SmoothTransformBetweenFrusta(d,u,h,f,o.axis,o.angle)}}interpolateLocalCorners(t,e){(e=e||[]).length=0;const r=this._localCornerA.length;for(let i=0;i<r;i++)e.push(this._localCornerA[i].interpolate(t,this._localCornerB[i]));return e}fractionToWorldCorners(t,e){const r=this.interpolateLocalCorners(t,e),i=o.Matrix3d.createRotationAroundVector(this._rotationAxis,this._rotationAngle.cloneScaled(t)),s=this._localToWorldA.matrix,a=i.multiplyMatrixMatrix(s),c=this._localToWorldA.getOrigin().interpolate(t,this._localToWorldB.origin);return n.Transform.createOriginAndMatrix(c,a).multiplyPoint3dArray(r,r),r}}e.SmoothTransformBetweenFrusta=SmoothTransformBetweenFrusta},"./lib/geometry3d/GeometryHandler.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class GeometryHandler{handleCurveCollection(t){}handlePath(t){return this.handleCurveCollection(t)}handleLoop(t){return this.handleCurveCollection(t)}handleParityRegion(t){return this.handleCurveCollection(t)}handleUnionRegion(t){return this.handleCurveCollection(t)}handleBagOfCurves(t){return this.handleCurveCollection(t)}}e.GeometryHandler=GeometryHandler;e.NullGeometryHandler=class NullGeometryHandler extends GeometryHandler{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleCurveCollection(t){}handleBSplineCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handlePath(t){}handleLoop(t){}handleParityRegion(t){}handleUnionRegion(t){}handleBagOfCurves(t){}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}};e.RecurseToCurvesGeometryHandler=class RecurseToCurvesGeometryHandler extends GeometryHandler{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleBSplineCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handleChildren(t){const e=t.children;if(e)for(const r of e)r.dispatchToGeometryHandler(this)}handleCurveCollection(t){return this.handleChildren(t)}handlePath(t){return this.handleChildren(t)}handleLoop(t){return this.handleChildren(t)}handleParityRegion(t){return this.handleChildren(t)}handleUnionRegion(t){return this.handleChildren(t)}handleBagOfCurves(t){return this.handleChildren(t)}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}},"./lib/geometry3d/GrowableBlockedArray.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class GrowableBlockedArray{constructor(t,e=8){this._data=new Float64Array(e*t),this._inUse=0,this._blockSize=t}get numBlocks(){return this._inUse}get numPerBlock(){return this._blockSize}getWithinBlock(t,e){return this._data[t*this._blockSize+e]}clear(){this._inUse=0}blockCapacity(){return this._data.length/this._blockSize}ensureBlockCapacity(t){if(t>this.blockCapacity()){const e=new Float64Array(t*this._blockSize);for(let t=0;t<this._data.length;t++)e[t]=this._data[t];this._data=e}}addBlock(t){const e=this.newBlockIndex();let r=t.length;r>this._blockSize&&(r=this._blockSize);for(let i=0;i<r;i++)this._data[e+i]=t[i]}newBlockIndex(){const t=this._blockSize*this._inUse;t+1>this._data.length&&this.ensureBlockCapacity(1+2*this._inUse),this._inUse++;for(let e=t;e<t+this._blockSize;e++)this._data[e]=0;return t}popBlock(){this._inUse>0&&this._inUse--}blockIndexToDoubleIndex(t){return this._blockSize*t}checkedComponent(t,e){if(!(t>=this._inUse||t<0||e<0||e>=this._blockSize))return this._data[this._blockSize*t+e]}component(t,e){return this._data[this._blockSize*t+e]}static compareLexicalBlock(t,e,r,i){let n=0,s=0;for(let o=0;o<e;o++){if((n=t[r+o])>(s=t[i+o]))return 1;if(n<s)return-1}return r-i}sortIndicesLexical(t=GrowableBlockedArray.compareLexicalBlock){const e=this._inUse,r=new Uint32Array(e),i=this._data,n=this._blockSize;for(let s=0;s<e;s++)r[s]=s;return r.sort((e,r)=>t(i,n,e*n,r*n)),r}distanceBetweenBlocks(t,e){let r=0,i=this.blockIndexToDoubleIndex(t),n=this.blockIndexToDoubleIndex(e),s=0;const o=this._data;for(let a=0;a<this._blockSize;a++)r+=(s=o[i++]-o[n++])*s;return Math.sqrt(r)}distanceBetweenSubBlocks(t,e,r,i){let n=0;const s=this.blockIndexToDoubleIndex(t),o=this.blockIndexToDoubleIndex(e);let a=0;const c=this._data;for(let l=r;l<i;l++)n+=(a=c[s+l]-c[o+l])*a;return Math.sqrt(n)}}e.GrowableBlockedArray=GrowableBlockedArray},"./lib/geometry3d/GrowableFloat64Array.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class GrowableFloat64Array{constructor(t=8){this._data=new Float64Array(t),this._inUse=0}static create(t){const e=new GrowableFloat64Array(t.length);for(const r of t)e.push(r);return e}static compare(t,e){return t-e}clone(t=!1){const e=this._inUse,r=this._data,i=new GrowableFloat64Array(t?this.capacity():e);for(let n=0;n<e;n++)i.push(r[n]);return i}get length(){return this._inUse}setAtUncheckedIndex(t,e){this._data[t]=e}move(t,e){this._data[e]=this._data[t]}swap(t,e){const r=this._data[t];this._data[t]=this._data[e],this._data[e]=r}push(t){if(this._inUse+1<=this._data.length)this._data[this._inUse]=t,this._inUse++;else{const e=new Float64Array(4+2*this._inUse);for(let t=0;t<this._inUse;t++)e[t]=this._data[t];this._data=e,this._data[this._inUse]=t,this._inUse++}}pushBlockCopy(t,e){const r=this._inUse+e;this.ensureCapacity(r);const i=t+e;for(let n=t;n<i;n++)this._data[this._inUse++]=this._data[n]}clear(){for(;this._inUse>0;)this.pop()}capacity(){return this._data.length}ensureCapacity(t){if(t>this.capacity()){const e=this._inUse,r=new Float64Array(t);for(let t=0;t<e;t++)r[t]=this._data[t];this._data=r}}resize(t,e=0){if(t<=this._inUse)return void(this._inUse=t);const r=this._inUse;this.ensureCapacity(t);for(let i=r;i<t;i++)this._data[i]=e;this._inUse=t}pop(){this._inUse>0&&this._inUse--}atUncheckedIndex(t){return this._data[t]}front(){return this._data[0]}back(){return this._data[this._inUse-1]}reassign(t,e){this._data[t]=e}sort(t=GrowableFloat64Array.compare){for(let e=0;e<this._inUse;e++)for(let r=e+1;r<this._inUse;r++){const i=this._data[e],n=this._data[r];t(i,n)>0&&(this._data[e]=n,this._data[r]=i)}}restrictToInterval(t,e){const r=this._data,i=r.length;let n=0,s=0;for(let o=0;o<i;o++)(s=r[o])>=t&&s<=e&&(r[n++]=s);this._inUse=n}compressAdjacentDuplicates(t=0){const e=this._data,r=this._inUse;if(0===r)return;let i,n=1,s=e[0];for(let o=1;o<r;o++)i=e[o],Math.abs(i-s)>t&&(e[n++]=i,s=i);this._inUse=n}}e.GrowableFloat64Array=GrowableFloat64Array},"./lib/geometry3d/GrowableXYArray.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point2dVector2d.js"),s=r("./lib/geometry3d/IndexedXYCollection.js"),o=r("./lib/geometry3d/GrowableXYZArray.js"),a=r("./lib/geometry3d/Point3dVector3d.js"),c=r("./lib/geometry3d/PointStreaming.js");class GrowableXYArray extends s.IndexedXYCollection{constructor(t=8){super(),this._data=new Float64Array(2*t),this._xyInUse=0,this._xyzCapacity=t}get length(){return this._xyInUse}set length(t){let e=this.length;if(t<e)this._xyInUse=t;else if(t>e)for(this.ensureCapacity(t);e++<t;)this.pushXY(0,0)}get float64Length(){return 2*this._xyInUse}float64Data(){return this._data}ensureCapacity(t){if(t>this._xyzCapacity){const e=new Float64Array(2*t),r=2*this.length;for(let t=0;t<r;t++)e[t]=this._data[t];this._data=e,this._xyzCapacity=t}}resize(t){if(t<this.length)this._xyInUse=t>=0?t:0;else if(t>this._xyzCapacity){const e=new Float64Array(2*t);for(let t=0;t<this._data.length;t+=2)e[t]=this._data[t],e[t+1]=this._data[t+1],e[t+2]=this._data[t+2];this._data=e,this._xyzCapacity=t,this._xyInUse=t}}clone(){const t=new GrowableXYArray(this.length),e=2*this.length,r=t._data,i=this._data;for(let n=0;n<e;n++)r[n]=i[n];return t._xyInUse=this.length,t}static create(t){const e=new GrowableXYArray(t.length);return t instanceof o.GrowableXYZArray?e.pushAllXYAndZ(t):e.pushAll(t),e}static createArrayOfGrowableXYZArray(t){const e=new c.PointStreamGrowableXYZArrayCollector;return c.VariantPointDataStream.streamXYZ(t,e),e.claimArrayOfGrowableXYZArray()}push(t){this.pushXY(t.x,t.y)}pushAll(t){for(const e of t)this.push(e)}pushAllXYAndZ(t){if(t instanceof o.GrowableXYZArray){const e=t.float64Data(),r=3*t.length;for(let t=0;t+2<r;t+=3)this.pushXY(e[t],e[t+1])}else for(const e of t)this.pushXY(e.x,e.y)}pushWrap(t){if(this._xyInUse>0){let e;for(let r=0;r<t;r++)e=2*r,this.pushXY(this._data[e],this._data[e+1])}}pushXY(t,e){const r=2*this._xyInUse;r>=this._data.length&&this.ensureCapacity(0===this.length?4:2*this.length),this._data[r]=t,this._data[r+1]=e,this._xyInUse++}pop(){this._xyInUse>0&&this._xyInUse--}isIndexValid(t){return!(t>=this._xyInUse||t<0)}clear(){this._xyInUse=0}getPoint2dAtUncheckedPointIndex(t,e){const r=2*t;return n.Point2d.create(this._data[r],this._data[r+1],e)}getXAtUncheckedPointIndex(t){return this._data[2*t]}getYAtUncheckedPointIndex(t){return this._data[2*t+1]}getPoint2dArray(){const t=2*this._xyInUse,e=[],r=this._data;for(let i=0;i<t;i+=2)e.push(n.Point2d.create(r[i],r[i+1]));return e}getPoint2dAtCheckedPointIndex(t,e){const r=2*t;if(this.isIndexValid(t))return n.Point2d.create(this._data[r],this._data[r+1],e)}getVector2dAtCheckedVectorIndex(t,e){const r=2*t;if(this.isIndexValid(t))return n.Vector2d.create(this._data[r],this._data[r+1],e)}transferFromGrowableXYArray(t,e,r){if(this.isIndexValid(t)&&e.isIndexValid(r)){const i=2*t,n=2*r;return this._data[i]=e._data[n],this._data[i+1]=e._data[n+1],this._data[i+2]=e._data[n+2],!0}return!1}pushFromGrowableXYArray(t,e){if(void 0===e){const e=this.length,r=t.length;this.ensureCapacity(e+r);const i=2*e,n=2*r;for(let s=0;s<n;s++)this._data[i+s]=t._data[s];return this._xyInUse+=r,r}if(t.isIndexValid(e)){const r=2*e;return this.pushXY(t._data[r],t._data[r+1]),1}return 0}pushInterpolatedFromGrowableXYArray(t,e,r,n){if(t.isIndexValid(e)&&t.isIndexValid(n)){const s=t._data;e*=3,n*=3,this.pushXY(i.Geometry.interpolate(s[e],r,s[n]),i.Geometry.interpolate(s[e+1],r,s[n+1]))}}static createFromGrowableXYZArray(t,e,r){const i=t.float64Data(),n=t.length,s=3*n;let o,a,c;if(r||(r=new GrowableXYArray(n)),r.clear(),e)for(let l=0;l<s;l+=3)o=i[l],a=i[l+1],c=i[l+2],r.pushXY(e.multiplyComponentXYZ(0,o,a,c),e.multiplyComponentXYZ(1,o,a,c));else for(let l=0;l<s;l+=3)o=i[l],a=i[l+1],r.pushXY(o,a);return r}front(t){if(0!==this._xyInUse)return this.getPoint2dAtUncheckedPointIndex(0,t)}back(t){if(!(this._xyInUse<1))return this.getPoint2dAtUncheckedPointIndex(this._xyInUse-1,t)}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;const r=2*t;return this._data[r]=e.x,this._data[r+1]=e.y,!0}setXYZAtCheckedPointIndex(t,e,r){if(!this.isIndexValid(t))return!1;const i=2*t;return this._data[i]=e,this._data[i+1]=r,!0}getPoint3dArray(t=0){const e=[],r=this._data,i=this.length;for(let n=0;n<i;n++)e.push(a.Point3d.create(r[2*n],r[2*n+1],t));return e}multiplyTransformInPlace(t){const e=this._data,r=this.float64Length,i=t.matrix.coffs,n=t.origin,s=n.x,o=n.y;let a=0,c=0;for(let l=0;l+2<=r;l+=2)a=e[l],c=e[l+1],e[l]=i[0]*a+i[1]*c+s,e[l+1]=i[3]*a+i[4]*c+o}multiplyMatrix3dInPlace(t){const e=this._data,r=this.float64Length,i=t.coffs;let n=0,s=0;for(let o=0;o+2<=r;o+=2)n=e[o],s=e[o+1],e[o]=i[0]*n+i[1]*s,e[o+1]=i[3]*n+i[4]*s}tryTransformInverseInPlace(t){const e=this._data,r=this.float64Length,i=t.matrix;i.computeCachedInverse(!0);const n=i.inverseCoffs;if(!n)return!1;const s=t.origin,o=s.x,a=s.y;let c=0,l=0;for(let d=0;d+2<=r;d+=2)c=e[d]-o,l=e[d+1]-a,e[d]=n[0]*c+n[1]*l,e[d+1]=n[3]*c+n[4]*l,e[d+2]=n[6]*c+n[7]*l;return!0}extendRange(t,e){const r=this.float64Length,i=this._data;if(e)for(let n=0;n+2<=r;n+=2)t.extendTransformedXY(e,i[n],i[n+1]);else for(let n=0;n+2<=r;n+=2)t.extendXY(i[n],i[n+1])}sumLengths(){let t=0;const e=2*(this._xyInUse-1),r=this._data;for(let n=0;n<e;n+=2)t+=i.Geometry.hypotenuseXY(r[n+2]-r[n],r[n+3]-r[n+1]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let r=0;r<e;r++)this._data[r]=this._data[r]*t}}interpolate(t,e,r,i){if(this.isIndexValid(t)&&this.isIndexValid(r)){const s=1-e,o=this._data;return t*=2,r*=2,n.Point2d.create(s*o[t]+e*o[r],s*o[t+1]+e*o[r+1],i)}}areaXY(){let t=0;const e=2*this._xyInUse;if(e>4){const r=this._data[e-2],n=this._data[e-1];let s=this._data[0]-r,o=this._data[1]-n,a=0,c=0;for(let l=2;l<e;l+=2,s=a,o=c)a=this._data[l]-r,c=this._data[l+1]-n,t+=i.Geometry.crossProductXYXY(s,o,a,c)}return.5*t}vectorIndexIndex(t,e,r){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const i=this._data;return t*=2,e*=2,n.Vector2d.create(i[e]-i[t],i[e+1]-i[t+1],r)}vectorXAndYIndex(t,e,r){if(this.isIndexValid(e)){const i=this._data;return e*=2,n.Vector2d.create(i[e]-t.x,i[e+1]-t.y,r)}}crossProductIndexIndexIndex(t,e,r){const n=2*t,s=2*e,o=2*r,a=this._data;if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(r))return i.Geometry.crossProductXYXY(a[s]-a[n],a[s+1]-a[n+1],a[o]-a[n],a[o+1]-a[n+1])}crossProductXAndYIndexIndex(t,e,r){const n=2*e,s=2*r,o=this._data;if(this.isIndexValid(e)&&this.isIndexValid(r))return i.Geometry.crossProductXYXY(o[n]-t.x,o[n+1]-t.y,o[s]-t.x,o[s+1]-t.y)}distance(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const r=2*t,n=2*e;return i.Geometry.hypotenuseXY(this._data[n]-this._data[r],this._data[n+1]-this._data[r+1])}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const r=2*t;return i.Geometry.hypotenuseXY(e.x-this._data[r],e.y-this._data[r+1])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(!t.getPoint2dAtUncheckedPointIndex(r).isAlmostEqual(e.getPoint2dAtUncheckedPointIndex(r)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyInUse,e=new Uint32Array(t);for(let r=0;r<t;r++)e[r]=r;return e.sort((t,e)=>this.compareLexicalBlock(t,e)),e}compareLexicalBlock(t,e){let r=0,i=0;for(let n=0;n<2;n++){if((r=this._data[2*t+n])>(i=this._data[2*e+n]))return 1;if(r<i)return-1}return t-e}component(t,e){return this._data[2*t+e]}isAlmostEqual(t,e=i.Geometry.smallMetricDistance){const r=this._xyInUse;if(t._xyInUse!==r)return!1;const n=this._data,s=t._data;for(let i=0;i<2*r;i++)if(Math.abs(n[i]-s[i])>e)return!1;return!0}}e.GrowableXYArray=GrowableXYArray},"./lib/geometry3d/GrowableXYZArray.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/Range.js"),o=r("./lib/geometry3d/Transform.js"),a=r("./lib/geometry3d/IndexedXYZCollection.js"),c=r("./lib/geometry3d/Point2dVector2d.js");class GrowableXYZArray extends a.IndexedReadWriteXYZCollection{constructor(t=8){super(),this._data=new Float64Array(3*t),this._xyzInUse=0,this._xyzCapacity=t}get length(){return this._xyzInUse}set length(t){let e=this.length;if(t<e)this._xyzInUse=t;else if(t>e)for(this.ensureCapacity(t);e++<t;)this.pushXYZ(0,0,0)}get float64Length(){return 3*this._xyzInUse}float64Data(){return this._data}ensureCapacity(t){if(t>this._xyzCapacity){const e=new Float64Array(3*t),r=3*this.length;for(let t=0;t<r;t++)e[t]=this._data[t];this._data=e,this._xyzCapacity=t}}resize(t){if(t<this.length)this._xyzInUse=t>=0?t:0;else if(t>this._xyzCapacity){const e=new Float64Array(3*t);for(let t=0;t<this._data.length;t+=3)e[t]=this._data[t],e[t+1]=this._data[t+1],e[t+2]=this._data[t+2];this._data=e,this._xyzCapacity=t,this._xyzInUse=t}}clone(t){const e=3*this.length;t?(t.clear(),t.ensureCapacity(this.length)):t=new GrowableXYZArray(this.length);const r=t._data,i=this._data;for(let n=0;n<e;n++)r[n]=i[n];return t._xyzInUse=this.length,t}static create(t,e){return e?e.clear():e=new GrowableXYZArray(t.length),e.pushFrom(t),e}push(t){this.pushXYZ(t.x,t.y,t.z)}pushAll(t){for(const e of t)this.push(e)}pushFrom(t){if(t instanceof n.Point3d)this.pushXYZ(t.x,t.y,t.z);else if(t instanceof GrowableXYZArray)this.pushFromGrowableXYZArray(t);else if(t instanceof c.Point2d)this.pushXYZ(t.x,t.y,0);else if(i.Geometry.isNumberArray(t,4)){const e=t.length;for(let r=0;r+2<e;r+=3)this.pushXYZ(t[r],t[r+1],t[r+2])}else if(i.Geometry.isNumberArray(t,3))this.pushXYZ(t[0],t[1],t[2]);else if(i.Geometry.isNumberArray(t,2))this.pushXYZ(t[0],t[1],0);else if(Array.isArray(t))for(const e of t)this.pushFrom(e);else if(n.Point3d.isXYAndZ(t))this.pushXYZ(t.x,t.y,t.z);else if(n.Point3d.isXAndY(t))this.pushXYZ(t.x,t.y,0);else if(t instanceof Float64Array){const e=t.length;for(let r=0;r+2<e;r+=3)this.pushXYZ(t[r],t[r+1],t[r+2])}else if(t instanceof a.IndexedXYZCollection)for(let e=0;e<t.length;e++)this.pushXYZ(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e))}pushWrap(t){if(this._xyzInUse>0){let e;for(let r=0;r<t;r++)e=3*r,this.pushXYZ(this._data[e],this._data[e+1],this._data[e+2])}}pushXYZ(t,e,r){const i=3*this._xyzInUse;i>=this._data.length&&this.ensureCapacity(0===this.length?4:2*this.length),this._data[i]=t,this._data[i+1]=e,this._data[i+2]=r,this._xyzInUse++}moveIndexToIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){let r=3*t,i=3*e;this._data[i++]=this._data[r++],this._data[i++]=this._data[r++],this._data[i]=this._data[r]}}pop(){this._xyzInUse>0&&this._xyzInUse--}isIndexValid(t){return!(t>=this._xyzInUse||t<0)}clear(){this._xyzInUse=0}getPoint3dAtUncheckedPointIndex(t,e){const r=3*t;return n.Point3d.create(this._data[r],this._data[r+1],this._data[r+2],e)}getPoint2dAtUncheckedPointIndex(t,e){const r=3*t;return c.Point2d.create(this._data[r],this._data[r+1],e)}getPoint3dAtCheckedPointIndex(t,e){const r=3*t;if(this.isIndexValid(t))return e||(e=n.Point3d.create()),e.x=this._data[r],e.y=this._data[r+1],e.z=this._data[r+2],e}getXAtUncheckedPointIndex(t){const e=3*t;return this._data[e]}getYAtUncheckedPointIndex(t){const e=3*t;return this._data[e+1]}getZAtUncheckedPointIndex(t){const e=3*t;return this._data[e+2]}getPoint2dAtCheckedPointIndex(t,e){const r=3*t;if(this.isIndexValid(t))return e||(e=c.Point2d.create()),e.x=this._data[r],e.y=this._data[r+1],e}getVector3dAtCheckedVectorIndex(t,e){const r=3*t;if(t>=0&&t<this._xyzInUse)return e||(e=n.Vector3d.create()),e.x=this._data[r],e.y=this._data[r+1],e.z=this._data[r+2],e}transferFromGrowableXYZArray(t,e,r){if(this.isIndexValid(t)&&e.isIndexValid(r)){const i=3*t,n=3*r;return this._data[i]=e._data[n],this._data[i+1]=e._data[n+1],this._data[i+2]=e._data[n+2],!0}return!1}pushFromGrowableXYZArray(t,e){if(void 0===e){const e=t.length;this.ensureCapacity(this.length+e);const r=3*t.length,i=3*this._xyzInUse;for(let n=0;n<r;n++)this._data[i+n]=t._data[n];return this._xyzInUse+=e,e}if(t.isIndexValid(e)){const r=3*e;return this.pushXYZ(t._data[r],t._data[r+1],t._data[r+2]),1}return 0}front(t){if(0!==this._xyzInUse)return this.getPoint3dAtUncheckedPointIndex(0,t)}back(t){if(!(this._xyzInUse<1))return this.getPoint3dAtUncheckedPointIndex(this._xyzInUse-1,t)}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;let r=3*t;return this._data[r++]=e.x,this._data[r++]=e.y,this._data[r]=e.z,!0}setXYZAtCheckedPointIndex(t,e,r,i){if(!this.isIndexValid(t))return!1;let n=3*t;return this._data[n++]=e,this._data[n++]=r,this._data[n]=i,!0}getPoint3dArray(){const t=[],e=this._data,r=this.length;for(let i=0;i<r;i++)t.push(n.Point3d.create(e[3*i],e[3*i+1],e[3*i+2]));return t}multiplyTransformInPlace(t){const e=this._data,r=this.float64Length,i=t.matrix.coffs,n=t.origin,s=n.x,o=n.y,a=n.z;let c=0,l=0,d=0;for(let h=0;h+2<=r;h+=3)c=e[h],l=e[h+1],d=e[h+2],e[h]=i[0]*c+i[1]*l+i[2]*d+s,e[h+1]=i[3]*c+i[4]*l+i[5]*d+o,e[h+2]=i[6]*c+i[7]*l+i[8]*d+a}reverseInPlace(){const t=this.length;let e,r,i;const n=this._data;for(let s=0,o=t-1;s<o;s++,o--)r=3*o,i=n[e=3*s],n[e]=n[r],n[r]=i,r++,i=n[++e],n[e]=n[r],n[r]=i,r++,i=n[++e],n[e]=n[r],n[r]=i}multiplyMatrix3dInPlace(t){const e=this._data,r=this.float64Length,i=t.coffs;let n=0,s=0,o=0;for(let a=0;a+2<=r;a+=3)n=e[a],s=e[a+1],o=e[a+2],e[a]=i[0]*n+i[1]*s+i[2]*o,e[a+1]=i[3]*n+i[4]*s+i[5]*o,e[a+2]=i[6]*n+i[7]*s+i[8]*o}multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t){const e=this._data,r=this.float64Length;if(!t.computeCachedInverse(!0))return!1;const i=t.inverseCoffs;let n,s,o,a,c,l=0,d=0,h=0,u=0;for(let f=0;f+2<=r;f+=3)l=e[f],d=e[f+1],h=e[f+2],(c=(n=i[0]*l+i[3]*d+i[6]*h)*n+(s=i[1]*l+i[4]*d+i[7]*h)*s+(o=i[2]*l+i[5]*d+i[8]*h)*o)<1e-15?(n=l,s=d,o=h,u++):Math.abs(c-1)>1e-15&&(n*=a=1/Math.sqrt(c),s*=a,o*=a),e[f]=n,e[f+1]=s,e[f+2]=o;return 0===u}tryTransformInverseInPlace(t){const e=this._data,r=this.float64Length,i=t.matrix;i.computeCachedInverse(!0);const n=i.inverseCoffs;if(!n)return!1;const s=t.origin,o=s.x,a=s.y,c=s.z;let l=0,d=0,h=0;for(let u=0;u+3<=r;u+=3)l=e[u]-o,d=e[u+1]-a,h=e[u+2]-c,e[u]=n[0]*l+n[1]*d+n[2]*h,e[u+1]=n[3]*l+n[4]*d+n[5]*h,e[u+2]=n[6]*l+n[7]*d+n[8]*h;return!0}extendRange(t,e){const r=this.float64Length,i=this._data;if(e)for(let n=0;n+3<=r;n+=3)t.extendTransformedXYZ(e,i[n],i[n+1],i[n+2]);else for(let n=0;n+3<=r;n+=3)t.extendXYZ(i[n],i[n+1],i[n+2])}getRange(t){const e=s.Range3d.createNull();return this.extendRange(e,t),e}setRange(t,e){t.setNull(),this.extendRange(t,e)}sumLengths(){let t=0;const e=3*(this._xyzInUse-1),r=this._data;for(let n=0;n<e;n+=3)t+=i.Geometry.hypotenuseXYZ(r[n+3]-r[n],r[n+4]-r[n+1],r[n+5]-r[n+2]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let r=0;r<e;r++)this._data[r]=this._data[r]*t}}isCloseToPlane(t,e=i.Geometry.smallMetricDistance){const r=3*this._xyzInUse,n=this._data;for(let i=0;i<r;i+=3)if(Math.abs(t.altitudeXYZ(n[i],n[i+1],n[i+2]))>e)return!1;return!0}interpolate(t,e,r,i){if(this.isIndexValid(t)&&this.isIndexValid(r)){const s=1-e,o=this._data;return t*=3,r*=3,n.Point3d.create(s*o[t]+e*o[r],s*o[t+1]+e*o[r+1],s*o[t+2]+e*o[r+2],i)}}pushInterpolatedFromGrowableXYZArray(t,e,r,i){if(t.isIndexValid(e)&&t.isIndexValid(i)){const n=1-r,s=t._data;e*=3,i*=3,this.pushXYZ(n*s[e]+r*s[i],n*s[e+1]+r*s[i+1],n*s[e+2]+r*s[i+2])}}areaXY(){let t=0;const e=3*this._xyzInUse;if(e>6){const r=this._data[e-3],n=this._data[e-2];let s=this._data[0]-r,o=this._data[1]-n,a=0,c=0;for(let l=3;l<e;l+=3,s=a,o=c)a=this._data[l]-r,c=this._data[l+1]-n,t+=i.Geometry.crossProductXYXY(s,o,a,c)}return.5*t}vectorIndexIndex(t,e,r){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;r||(r=n.Vector3d.create());const i=this._data;return t*=3,e*=3,r.x=i[e]-i[t],r.y=i[e+1]-i[t+1],r.z=i[e+2]-i[t+2],r}vectorXYAndZIndex(t,e,r){if(this.isIndexValid(e)){const i=this._data;return e*=3,n.Vector3d.create(i[e]-t.x,i[e+1]-t.y,i[e+2]-t.z,r)}}crossProductIndexIndexIndex(t,e,r,n){const s=3*t,o=3*e,a=3*r,c=this._data;if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(r))return i.Geometry.crossProductXYZXYZ(c[o]-c[s],c[o+1]-c[s+1],c[o+2]-c[s+2],c[a]-c[s],c[a+1]-c[s+1],c[a+2]-c[s+2],n)}evaluateUncheckedIndexDotProductXYZ(t,e,r,i){const n=3*t,s=this._data;return s[n]*e+s[n+1]*r+s[n+2]*i}evaluateUncheckedIndexPlaneAltitude(t,e){const r=3*t,i=this._data;return e.altitudeXYZ(i[r],i[r+1],i[r+2])}accumulateCrossProductIndexIndexIndex(t,e,r,i){const n=3*t,s=3*e,o=3*r,a=this._data;this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(r)&&i.addCrossProductToTargetsInPlace(a[n],a[n+1],a[n+2],a[s],a[s+1],a[s+2],a[o],a[o+1],a[o+2])}accumulateScaledXYZ(t,e,r){const i=3*t,n=this._data;this.isIndexValid(t)&&(r.x+=e*n[i],r.y+=e*n[i+1],r.z+=e*n[i+2])}crossProductXYAndZIndexIndex(t,e,r,n){const s=3*e,o=3*r,a=this._data;if(this.isIndexValid(e)&&this.isIndexValid(r))return i.Geometry.crossProductXYZXYZ(a[s]-t.x,a[s+1]-t.y,a[s+2]-t.z,a[o]-t.x,a[o+1]-t.y,a[o+2]-t.z,n)}distance(t,e){if(t>=0&&t<this._xyzInUse&&e>=0&&e<=this._xyzInUse){const r=3*t,n=3*e;return i.Geometry.hypotenuseXYZ(this._data[n]-this._data[r],this._data[n+1]-this._data[r+1],this._data[n+2]-this._data[r+2])}}distanceIndexToPoint(t,e){if(t>=0&&t<this._xyzInUse){const r=3*t;return i.Geometry.hypotenuseXYZ(e.x-this._data[r],e.y-this._data[r+1],e.z-this._data[r+2])}}distanceSquaredIndexIndex(t,e){if(t>=0&&t<this._xyzInUse&&e>=0&&e<=this._xyzInUse){const r=3*t,n=3*e;return i.Geometry.hypotenuseSquaredXYZ(this._data[n]-this._data[r],this._data[n+1]-this._data[r+1],this._data[n+2]-this._data[r+2])}}distanceIndexIndex(t,e){if(t>=0&&t<this._xyzInUse&&e>=0&&e<=this._xyzInUse){const r=3*t,n=3*e;return i.Geometry.hypotenuseXYZ(this._data[n]-this._data[r],this._data[n+1]-this._data[r+1],this._data[n+2]-this._data[r+2])}}static distanceBetweenPointsIn2Arrays(t,e,r,n){if(e>=0&&e<t._xyzInUse&&n>=0&&n<=r._xyzInUse){const s=3*e,o=3*n;return i.Geometry.hypotenuseXYZ(r._data[o]-t._data[s],r._data[o+1]-t._data[s+1],r._data[o+2]-t._data[s+2])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(!t.getPoint3dAtUncheckedPointIndex(r).isAlmostEqual(e.getPoint3dAtUncheckedPointIndex(r)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyzInUse,e=new Uint32Array(t);for(let r=0;r<t;r++)e[r]=r;return e.sort((t,e)=>this.compareLexicalBlock(t,e)),e}compareLexicalBlock(t,e){let r=0,i=0;for(let n=0;n<3;n++){if((r=this._data[3*t+n])>(i=this._data[3*e+n]))return 1;if(r<i)return-1}return t-e}component(t,e){return this._data[3*t+e]}addSteppedPoints(t,e,r,i){const n=t._data;let s=3*e;const o=3*t.length;let a=0;for(;s>=0&&s+2<o&&a<i;)this.pushXYZ(n[s],n[s+1],n[s+2]),s+=3*r,a++}static distanceRangeBetweenCorrespondingPoints(t,e){const r=t._data,n=e._data,o=Math.min(t.length,e.length);let a,c=0;const l=s.Range1d.createNull();for(;c<o;)a=3*c,l.extendX(i.Geometry.hypotenuseXYZ(r[a]-n[a],r[a+1]-n[a+1],r[a+2]-n[a+2])),c++;return l}fillLocalXYTriangleFrame(t,e,r,i){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(r)){let n=3*t;const s=this._data,a=s[n++],c=s[n++],l=s[n++];n=3*e;const d=s[n++]-a,h=s[n++]-c,u=s[n++]-l;n=3*r;const f=s[n++]-a,g=s[n++]-c,p=s[n++]-l;return(i=o.Transform.createRowValues(d,f,0,a,h,g,0,c,u,p,1,l,i)).computeCachedInverse()?i:void 0}}mapComponent(t,e){const r=this._data.length;let i;for(let n=0;n+2<r;n+=3)i=e(this._data[n],this._data[n+1],this._data[n+2]),this._data[n+t]=i}}e.GrowableXYZArray=GrowableXYZArray},"./lib/geometry3d/IndexedCollectionInterval.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class IndexedCollectionInterval{constructor(t,e,r){this.points=t,this.begin=e,this.end=r}static createComplete(t){return new this(t,0,t.length)}static createBeginEnd(t,e,r){return new this(t,e,r)}static createBeginLength(t,e,r){return new this(t,e,e+r)}advanceBegin(){return this.begin++,this.begin<this.end}advanceEnd(){return this.end++,this.end>this.points.length&&(this.end=this.points.length),this.begin<this.end}localIndexToParentIndex(t){if(t>=0){const e=this.begin+t;if(e<this.points.length)return e}}get isValidSubset(){return 0===this.length||void 0!==this.localIndexToParentIndex(0)&&void 0!==this.localIndexToParentIndex(this.length-1)}restrictEnd(){this.end>this.points.length&&(this.end=this.points.length)}get isNonEmpty(){return this.begin<this.end}advanceToTail(t){return this.begin=t.end-1,this.isNonEmpty}advanceToHead(t){return this.begin=t.begin,this.isNonEmpty}setFrom(t,e,r){this.points=t.points,this.begin=void 0===e?t.begin:e,this.end=void 0===r?t.end:r,this.restrictEnd()}get length(){return this.end>this.begin?this.end-this.begin:0}get isSingleton(){return this.begin+1===this.end}}e.IndexedCollectionInterval=IndexedCollectionInterval;e.IndexedXYZCollectionInterval=class IndexedXYZCollectionInterval extends IndexedCollectionInterval{}},"./lib/geometry3d/IndexedXYCollection.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.IndexedXYCollection=class IndexedXYCollection{}},"./lib/geometry3d/IndexedXYZCollection.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Range.js");class PointsIterator{constructor(t){this._curIndex=-1,this._collection=t}next(){return++this._curIndex>=this._collection.length?{done:!0}:{value:this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),done:!1}}[Symbol.iterator](){return this}}class IndexedXYZCollection{cyclicIndex(t){return t%this.length}getRange(){const t=n.Range3d.createNull(),e=this.length,r=i.Point3d.create();for(let i=0;i<e;i++)this.getPoint3dAtUncheckedPointIndex(i,r),t.extendPoint(r);return t}get points(){return new PointsIterator(this)}}e.IndexedXYZCollection=IndexedXYZCollection;e.IndexedReadWriteXYZCollection=class IndexedReadWriteXYZCollection extends IndexedXYZCollection{}},"./lib/geometry3d/Matrix3d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Angle.js"),s=r("./lib/geometry4d/Point4d.js"),o=r("./lib/geometry3d/Point2dVector2d.js"),a=r("./lib/geometry3d/Point3dVector3d.js"),c=r("./lib/geometry3d/Transform.js");class PackedMatrix3dOps{static loadMatrix(t,e,r,i,n,s,o,a,c,l){t[0]=e,t[1]=r,t[2]=i,t[3]=n,t[4]=s,t[5]=o,t[6]=a,t[7]=c,t[8]=l}static multiplyMatrixMatrix(t,e,r){return r||(r=new Float64Array(9)),PackedMatrix3dOps.loadMatrix(r,t[0]*e[0]+t[1]*e[3]+t[2]*e[6],t[0]*e[1]+t[1]*e[4]+t[2]*e[7],t[0]*e[2]+t[1]*e[5]+t[2]*e[8],t[3]*e[0]+t[4]*e[3]+t[5]*e[6],t[3]*e[1]+t[4]*e[4]+t[5]*e[7],t[3]*e[2]+t[4]*e[5]+t[5]*e[8],t[6]*e[0]+t[7]*e[3]+t[8]*e[6],t[6]*e[1]+t[7]*e[4]+t[8]*e[7],t[6]*e[2]+t[7]*e[5]+t[8]*e[8]),r}static multiplyMatrixMatrixTranspose(t,e,r){return r||(r=new Float64Array(9)),PackedMatrix3dOps.loadMatrix(r,t[0]*e[0]+t[1]*e[1]+t[2]*e[2],t[0]*e[3]+t[1]*e[4]+t[2]*e[5],t[0]*e[6]+t[1]*e[7]+t[2]*e[8],t[3]*e[0]+t[4]*e[1]+t[5]*e[2],t[3]*e[3]+t[4]*e[4]+t[5]*e[5],t[3]*e[6]+t[4]*e[7]+t[5]*e[8],t[6]*e[0]+t[7]*e[1]+t[8]*e[2],t[6]*e[3]+t[7]*e[4]+t[8]*e[5],t[6]*e[6]+t[7]*e[7]+t[8]*e[8]),r}static multiplyMatrixTransposeMatrix(t,e,r){return r||(r=new Float64Array(9)),PackedMatrix3dOps.loadMatrix(r,t[0]*e[0]+t[3]*e[3]+t[6]*e[6],t[0]*e[1]+t[3]*e[4]+t[6]*e[7],t[0]*e[2]+t[3]*e[5]+t[6]*e[8],t[1]*e[0]+t[4]*e[3]+t[7]*e[6],t[1]*e[1]+t[4]*e[4]+t[7]*e[7],t[1]*e[2]+t[4]*e[5]+t[7]*e[8],t[2]*e[0]+t[5]*e[3]+t[8]*e[6],t[2]*e[1]+t[5]*e[4]+t[8]*e[7],t[2]*e[2]+t[5]*e[5]+t[8]*e[8]),r}static transposeInPlace(t){let e=t[1];t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e}static copyTransposed(t,e){return e===t?PackedMatrix3dOps.transposeInPlace(t):(e||(e=new Float64Array(9)),e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8]),e}}var l;!function(t){t[t.unknown=0]="unknown",t[t.inverseStored=1]="inverseStored",t[t.singular=2]="singular"}(l=e.InverseMatrixState||(e.InverseMatrixState={}));class Matrix3d{constructor(t){this.coffs=t||new Float64Array(9),this.inverseCoffs=void 0,this.inverseState=l.unknown}static get identity(){return void 0===this._identity&&(this._identity=Matrix3d.createIdentity(),this._identity.freeze()),this._identity}freeze(){this.computeCachedInverse(!0),Object.freeze(this)}toJSON(){return[[this.coffs[0],this.coffs[1],this.coffs[2]],[this.coffs[3],this.coffs[4],this.coffs[5]],[this.coffs[6],this.coffs[7],this.coffs[8]]]}setFromJSON(t){if(this.inverseCoffs=void 0,t)if(Array.isArray(t)){if(i.Geometry.isArrayOfNumberArray(t,3,3)){const e=t;this.setRowValues(e[0][0],e[0][1],e[0][2],e[1][0],e[1][1],e[1][2],e[2][0],e[2][1],e[2][2])}else if(9===t.length){const e=t;this.setRowValues(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}else if(4===t.length){const e=t;this.setRowValues(e[0],e[1],0,e[2],e[3],0,0,0,1)}}else t instanceof Matrix3d&&this.setFrom(t);else this.setRowValues(0,0,0,0,0,0,0,0,0)}static fromJSON(t){const e=Matrix3d.createIdentity();return e.setFromJSON(t),e}isAlmostEqual(t,e){return e?i.Geometry.isDistanceWithinTol(this.maxDiff(t),e):i.Geometry.isSmallMetricDistance(this.maxDiff(t))}isExactEqual(t){return 0===this.maxDiff(t)}get isXY(){return 0===this.coffs[2]&&0===this.coffs[5]&&0===this.coffs[6]&&0===this.coffs[7]&&1===this.coffs[8]}static _create(t){return t||new Matrix3d}static createRowValues(t,e,r,i,n,s,o,a,c,d){return(d=d||new Matrix3d).inverseState=l.unknown,d.coffs[0]=t,d.coffs[1]=e,d.coffs[2]=r,d.coffs[3]=i,d.coffs[4]=n,d.coffs[5]=s,d.coffs[6]=o,d.coffs[7]=a,d.coffs[8]=c,d}static createCapture(t,e){const r=new Matrix3d(t);return e?(r.inverseCoffs=e,r.inverseState=l.inverseStored):r.inverseState=l.unknown,r}static createColumnsInAxisOrder(t,e,r,n,s){return s||(s=new Matrix3d),t===i.AxisOrder.YZX?s.setColumns(n,e,r):t===i.AxisOrder.ZXY?s.setColumns(r,n,e):t===i.AxisOrder.XZY?s.setColumns(e,n,r):t===i.AxisOrder.YXZ?s.setColumns(r,e,n):t===i.AxisOrder.ZYX?s.setColumns(n,r,e):s.setColumns(e,r,n),s}setRowValues(t,e,r,i,n,s,o,a,c){this.coffs[0]=t,this.coffs[1]=e,this.coffs[2]=r,this.coffs[3]=i,this.coffs[4]=n,this.coffs[5]=s,this.coffs[6]=o,this.coffs[7]=a,this.coffs[8]=c,this.inverseState=l.unknown}setIdentity(){this.setRowValues(1,0,0,0,1,0,0,0,1),this.setupInverseTranspose()}setZero(){this.setRowValues(0,0,0,0,0,0,0,0,0),this.inverseState=l.singular}setFrom(t){for(let e=0;e<9;e++)this.coffs[e]=t.coffs[e];this.inverseState=l.unknown}clone(t){return(t=t||new Matrix3d).setFrom(this),t}static createZero(){const t=new Matrix3d;return t.inverseState=l.singular,t}static createIdentity(t){return(t=t||new Matrix3d).setIdentity(),t}static createUniformScale(t){return Matrix3d.createScale(t,t,t)}static createRigidHeadsUp(t,e=i.AxisOrder.ZXY,r){const n=Matrix3d.createPerpendicularVectorFavorXYPlane(t),s=Matrix3d.createRigidFromColumns(t,n,e,r);return s?(s.setupInverseTranspose(),s):Matrix3d.createIdentity(r)}static createPerpendicularVectorFavorXYPlane(t,e){const r=t.magnitude()/64;return Math.abs(t.x)<r&&Math.abs(t.y)<r?a.Vector3d.createCrossProduct(t.x,t.y,t.z,0,-1,0,e):a.Vector3d.createCrossProduct(0,0,1,t.x,t.y,t.z,e)}static createPerpendicularVectorFavorPlaneContainingZ(t,e){return e=Matrix3d.createPerpendicularVectorFavorXYPlane(t,e),t.crossProduct(e,e)}static createScale(t,e,r,i){return i?i.setZero():i=new Matrix3d,i.coffs[0]=t,i.coffs[4]=e,i.coffs[8]=r,0===t||0===e||0===r?i.inverseState=l.singular:(i.inverseState=l.inverseStored,i.inverseCoffs=Float64Array.from([1/t,0,0,0,1/e,0,0,0,1/r])),i}static createRotationAroundVector(t,e,r){const i=e.cos(),n=e.sin(),s=1-i,o=t.normalize();if(o){const t=Matrix3d.createRowValues(o.x*o.x*s+i,o.x*o.y*s-n*o.z,o.x*o.z*s+n*o.y,o.y*o.x*s+n*o.z,o.y*o.y*s+i,o.y*o.z*s-n*o.x,o.z*o.x*s-n*o.y,o.z*o.y*s+n*o.x,o.z*o.z*s+i,r);return t.setupInverseTranspose(),t}}static createRotationAroundAxisIndex(t,e,r){const n=e.cos(),s=e.sin();let o;return(o=t===i.AxisIndex.X?Matrix3d.createRowValues(1,0,0,0,n,-s,0,s,n,r):t===i.AxisIndex.Y?Matrix3d.createRowValues(n,0,s,0,1,0,-s,0,n,r):Matrix3d.createRowValues(n,-s,0,s,n,0,0,0,1,r)).setupInverseTranspose(),o}static createViewedAxes(t,e,r=0,i=0){const s=t.crossProduct(e);if(s.normalizeInPlace()){const o=Matrix3d.createColumns(t,e,s);if(0!==r){let t=Math.sqrt(.5),e=r<0?-t:t;if(1!==Math.abs(r)){const i=n.Angle.degreesToRadians(45*r);t=Math.cos(i),e=Math.sin(i)}o.applyGivensColumnOp(2,0,t,e)}if(0!==i){const t=i*Math.atan(Math.sqrt(.5)),e=Math.cos(t),r=Math.sin(t);o.applyGivensColumnOp(1,2,e,-r)}return o}}static createStandardWorldToView(t,e=!1,r){switch(t){case i.StandardViewIndex.Bottom:r=Matrix3d.createRowValues(1,0,0,0,-1,0,0,0,-1);break;case i.StandardViewIndex.Left:r=Matrix3d.createRowValues(0,-1,0,0,0,1,-1,0,0);break;case i.StandardViewIndex.Right:r=Matrix3d.createRowValues(0,1,0,0,0,1,1,0,0);break;case i.StandardViewIndex.Front:r=Matrix3d.createRowValues(1,0,0,0,0,1,0,-1,0);break;case i.StandardViewIndex.Back:r=Matrix3d.createRowValues(-1,0,0,0,0,1,0,1,0);break;case i.StandardViewIndex.Iso:r=Matrix3d.createRowValues(.707106781186548,-.7071067811865476,0,.408248290463863,.408248290463863,.816496580927726,-.577350269189626,-.5773502691896257,.5773502691896257);break;case i.StandardViewIndex.RightIso:r=Matrix3d.createRowValues(.707106781186548,.7071067811865476,0,-.408248290463863,.408248290463863,.816496580927726,.577350269189626,-.5773502691896257,.5773502691896257);break;case i.StandardViewIndex.Top:default:r=Matrix3d.createIdentity(r)}return e&&r.transposeInPlace(),r}getAxisAndAngleOfRotation(){const t=this.coffs[0]+this.coffs[4]+this.coffs[8],e=this.coffs[3]-this.coffs[1],r=this.coffs[7]-this.coffs[5],s=this.coffs[2]-this.coffs[6],o=(t-1)/2,c=i.Geometry.hypotenuseXYZ(e,r,s)/2,l=o*o+c*c-1;if(Math.abs(l)>i.Geometry.smallAngleRadians)return{axis:a.Vector3d.create(0,0,1),angle:n.Angle.createRadians(0),ok:!1};if(Math.abs(c)<i.Geometry.smallAngleRadians){if(o>0)return{axis:a.Vector3d.create(0,0,1),angle:n.Angle.createRadians(0),ok:!0};const t=this.coffs[0],e=this.coffs[4],r=this.coffs[8],s=n.Angle.createDegrees(180);if(i.Geometry.isAlmostEqualNumber(-1,e)&&i.Geometry.isAlmostEqualNumber(-1,r))return{axis:a.Vector3d.create(1,0,0),angle:s,ok:!0};if(i.Geometry.isAlmostEqualNumber(-1,t)&&i.Geometry.isAlmostEqualNumber(-1,r))return{axis:a.Vector3d.create(0,1,0),angle:s,ok:!0};if(i.Geometry.isAlmostEqualNumber(-1,t)&&i.Geometry.isAlmostEqualNumber(-1,e))return{axis:a.Vector3d.create(0,0,1),angle:s,ok:!0};const c=Matrix3d.createIdentity(),l=a.Vector3d.create(0,0,0);if(this.fastSymmetricEigenvalues(c,l)){for(let t=0;t<2;t++){const e=l.at(t);if(i.Geometry.isAlmostEqualNumber(1,e))return{axis:c.getColumn(t),angle:s,ok:!0}}return{axis:a.Vector3d.create(0,0,1),angle:n.Angle.createRadians(0),ok:!1}}return{axis:a.Vector3d.create(0,0,1),angle:n.Angle.createRadians(0),ok:!1}}const d=1/(2*c);return{axis:a.Vector3d.create(r*d,s*d,e*d),angle:n.Angle.createAtan2(c,o),ok:!0}}static createRotationVectorToVector(t,e,r){return this.createPartialRotationVectorToVector(t,1,e,r)}static createPartialRotationVectorToVector(t,e,r,s){let o=t.unitCrossProduct(r);return o?Matrix3d.createRotationAroundVector(o,n.Angle.createRadians(e*t.planarAngleTo(r,o).radians)):i.Geometry.isSmallMetricDistance(t.magnitude())||i.Geometry.isSmallMetricDistance(r.magnitude())?void 0:t.dotProduct(r)>0?Matrix3d.createIdentity(s):(o=Matrix3d.createPerpendicularVectorFavorPlaneContainingZ(t,o),Matrix3d.createRotationAroundVector(o,n.Angle.createRadians(e*Math.PI)))}static create90DegreeRotationAroundAxis(t){if(0===(t=i.Geometry.cyclic3dAxis(t))){const t=Matrix3d.createRowValues(1,0,0,0,0,-1,0,1,0);return t.setupInverseTranspose(),t}if(1===t){const t=Matrix3d.createRowValues(0,0,1,0,1,0,-1,0,0);return t.setupInverseTranspose(),t}{const t=Matrix3d.createRowValues(0,-1,0,1,0,0,0,0,1);return t.setupInverseTranspose(),t}}columnX(t){return a.Vector3d.create(this.coffs[0],this.coffs[3],this.coffs[6],t)}columnY(t){return a.Vector3d.create(this.coffs[1],this.coffs[4],this.coffs[7],t)}columnZ(t){return a.Vector3d.create(this.coffs[2],this.coffs[5],this.coffs[8],t)}columnXMagnitudeSquared(){return i.Geometry.hypotenuseSquaredXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitudeSquared(){return i.Geometry.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitudeSquared(){return i.Geometry.hypotenuseSquaredXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXMagnitude(){return i.Geometry.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitude(){return i.Geometry.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitude(){return i.Geometry.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXYCrossProductMagnitude(){return i.Geometry.crossProductMagnitude(this.coffs[0],this.coffs[3],this.coffs[6],this.coffs[1],this.coffs[4],this.coffs[7])}rowXMagnitude(){return i.Geometry.hypotenuseXYZ(this.coffs[0],this.coffs[1],this.coffs[2])}rowYMagnitude(){return i.Geometry.hypotenuseXYZ(this.coffs[3],this.coffs[4],this.coffs[5])}rowZMagnitude(){return i.Geometry.hypotenuseXYZ(this.coffs[6],this.coffs[7],this.coffs[8])}columnXDotColumnY(){return this.coffs[0]*this.coffs[1]+this.coffs[3]*this.coffs[4]+this.coffs[6]*this.coffs[7]}rowX(t){return a.Vector3d.create(this.coffs[0],this.coffs[1],this.coffs[2],t)}rowY(t){return a.Vector3d.create(this.coffs[3],this.coffs[4],this.coffs[5],t)}rowZ(t){return a.Vector3d.create(this.coffs[6],this.coffs[7],this.coffs[8],t)}dotColumnX(t){return t.x*this.coffs[0]+t.y*this.coffs[3]+t.z*this.coffs[6]}dotColumnY(t){return t.x*this.coffs[1]+t.y*this.coffs[4]+t.z*this.coffs[7]}dotColumnZ(t){return t.x*this.coffs[2]+t.y*this.coffs[5]+t.z*this.coffs[8]}dotRowX(t){return t.x*this.coffs[0]+t.y*this.coffs[1]+t.z*this.coffs[2]}dotRowY(t){return t.x*this.coffs[3]+t.y*this.coffs[4]+t.z*this.coffs[5]}dotRowZ(t){return t.x*this.coffs[6]+t.y*this.coffs[7]+t.z*this.coffs[8]}dotRowXXYZ(t,e,r){return t*this.coffs[0]+e*this.coffs[1]+r*this.coffs[2]}dotRowYXYZ(t,e,r){return t*this.coffs[3]+e*this.coffs[4]+r*this.coffs[5]}dotRowZXYZ(t,e,r){return t*this.coffs[6]+e*this.coffs[7]+r*this.coffs[8]}columnZCrossVector(t,e){return i.Geometry.crossProductXYZXYZ(this.coffs[2],this.coffs[5],this.coffs[8],t.x,t.y,t.z,e)}applyGivensRowOp(t,e,r,i){let n=3*t,s=3*e;const o=n+3;for(;n<o;n++,s++){const t=this.coffs[n],e=this.coffs[s];this.coffs[n]=t*r+e*i,this.coffs[s]=-t*i+e*r}}applyGivensColumnOp(t,e,r,i){const n=t+9;for(;t<n;t+=3,e+=3){const n=this.coffs[t],s=this.coffs[e];this.coffs[t]=n*r+s*i,this.coffs[e]=-n*i+s*r}}static createRigidViewAxesZTowardsEye(t,e,r,n){n=Matrix3d.createIdentity(n);const s=i.Geometry.hypotenuseXY(t,e);if(i.Geometry.isSmallMetricDistance(s))r<0&&n.scaleColumnsInPlace(1,-1,-1);else{const o=t/s,a=e/s;if(n.setRowValues(-a,0,o,o,0,a,0,1,0),0!==r){const o=i.Geometry.hypotenuseXYZ(t,e,r),a=r/o,c=s/o;n.applyGivensColumnOp(1,2,c,-a)}}return n}applyJacobiColumnRotation(t,e,r){const i=this.coffs[t]*this.coffs[t]+this.coffs[t+3]*this.coffs[t+3]+this.coffs[t+6]*this.coffs[t+6],s=this.coffs[e]*this.coffs[e]+this.coffs[e+3]*this.coffs[e+3]+this.coffs[e+6]*this.coffs[e+6],o=this.coffs[t]*this.coffs[e]+this.coffs[t+3]*this.coffs[e+3]+this.coffs[t+6]*this.coffs[e+6],a=n.Angle.trigValuesToHalfAngleTrigValues(i-s,2*o);return Math.abs(a.s)<2e-15?0:(this.applyGivensColumnOp(t,e,a.c,a.s),r.applyGivensRowOp(t,e,a.c,a.s),Math.abs(o))}factorPerpendicularColumns(t,e){t.setFrom(this),e.setIdentity();const r=1e-12*this.sumSquares();for(let i=0;i<7;i++){if(t.applyJacobiColumnRotation(0,1,e)+t.applyJacobiColumnRotation(0,2,e)+t.applyJacobiColumnRotation(1,2,e)<r)return!0}return!1}applySymmetricJacobi(t,e,r){const i=r.at(t,t),s=r.at(e,e),o=r.at(t,e);if(Math.abs(o)<1e-15*(i+s))return 0;const a=n.Angle.trigValuesToHalfAngleTrigValues(i-s,2*o);return Math.abs(a.s)<2e-15?0:(this.applyGivensColumnOp(t,e,a.c,a.s),r.applyGivensRowOp(t,e,a.c,a.s),r.applyGivensColumnOp(t,e,a.c,a.s),Math.abs(o))}symmetricEigenvalues(t,e){const r=this.clone();t.setIdentity(),r.coffs[3]=r.coffs[1],r.coffs[6]=r.coffs[2],r.coffs[7]=r.coffs[5];const i=1e-12*this.sumSquares();for(let n=0;n<7;n++){if(t.applySymmetricJacobi(0,1,r)+t.applySymmetricJacobi(0,2,r)+t.applySymmetricJacobi(1,2,r)<i)return e.set(r.at(0,0),r.at(1,1),r.at(2,2)),!0}return!1}applyFastSymmetricJacobiUpdate(t,e,r,i){const s=4*t,o=4*e,a=3*t+e,c=3*t+r,l=3*e+r,d=this.coffs[s],h=this.coffs[o],u=this.coffs[a],f=n.Angle.trigValuesToHalfAngleTrigValues(d-h,2*u);if(Math.abs(u)<1e-15*(d+h))return 0;const g=f.c,p=f.s,m=g*g,y=p*p,P=2*g*p;this.coffs[s]=m*d+P*u+y*h,this.coffs[o]=y*d-P*u+m*h,this.coffs[a]=0;const x=this.coffs[c],_=this.coffs[l];return this.coffs[c]=x*g+_*p,this.coffs[l]=-p*x+g*_,this.coffs[3*e+t]=0,this.coffs[3*r+t]=this.coffs[c],this.coffs[3*r+e]=this.coffs[l],i.applyGivensColumnOp(t,e,g,p),Math.abs(u)}fastSymmetricEigenvalues(t,e){const r=this.clone();t.setIdentity();const i=1e-12*this.sumSquares();for(let n=0;n<7;n++){if(r.applyFastSymmetricJacobiUpdate(0,1,2,t)+r.applyFastSymmetricJacobiUpdate(0,2,1,t)+r.applyFastSymmetricJacobiUpdate(1,2,0,t)<i)return e.set(r.at(0,0),r.at(1,1),r.at(2,2)),!0}return!1}static createColumns(t,e,r,i){return Matrix3d.createRowValues(t.x,e.x,r.x,t.y,e.y,r.y,t.z,e.z,r.z,i)}static createColumnsXYW(t,e,r,i,n,s,o){return Matrix3d.createRowValues(t.x,r.x,n.x,t.y,r.y,n.y,e,i,s,o)}setColumnsPoint4dXYZ(t,e,r){this.inverseState=l.unknown,this.setRowValues(t.x,e.x,r.x,t.y,e.y,r.y,t.z,e.z,r.z)}setColumn(t,e){const r=i.Geometry.cyclic3dAxis(t);this.inverseState=l.unknown,e?(this.coffs[r]=e.x,this.coffs[r+3]=e.y,this.coffs[r+6]=e.z):(this.coffs[r]=0,this.coffs[r+3]=0,this.coffs[r+6]=0)}setColumns(t,e,r){this.setColumn(0,t),this.setColumn(1,e),this.setColumn(2,r)}setRow(t,e){const r=3*i.Geometry.cyclic3dAxis(t);this.coffs[r]=e.x,this.coffs[r+1]=e.y,this.coffs[r+2]=e.z,this.inverseState=l.unknown}getColumn(t,e){const r=i.Geometry.cyclic3dAxis(t);return a.Vector3d.create(this.coffs[r],this.coffs[r+3],this.coffs[r+6],e)}getRow(t,e){const r=3*i.Geometry.cyclic3dAxis(t);return a.Vector3d.create(this.coffs[r],this.coffs[r+1],this.coffs[r+2],e)}static createShuffledColumns(t,e,r,n,s){const o=Matrix3d._create(s);return o.setColumn(i.Geometry.axisOrderToAxis(n,0),t),o.setColumn(i.Geometry.axisOrderToAxis(n,1),e),o.setColumn(i.Geometry.axisOrderToAxis(n,2),r),o}static createRows(t,e,r,i){return Matrix3d.createRowValues(t.x,t.y,t.z,e.x,e.y,e.z,r.x,r.y,r.z,i)}static createDirectionalScale(t,e,r){const i=t.normalize();if(i){const t=i.x,n=i.y,s=i.z,o=e-1;return Matrix3d.createRowValues(1+o*t*t,o*t*n,o*t*s,o*n*t,1+o*n*n,o*n*s,o*s*t,o*s*n,1+o*s*s,r)}return Matrix3d.createUniformScale(e)}multiplyVector(t,e){const r=t.x,i=t.y,n=t.z;return a.Vector3d.create(this.coffs[0]*r+this.coffs[1]*i+this.coffs[2]*n,this.coffs[3]*r+this.coffs[4]*i+this.coffs[5]*n,this.coffs[6]*r+this.coffs[7]*i+this.coffs[8]*n,e)}multiplyVectorArrayInPlace(t){for(const e of t)e.set(this.coffs[0]*e.x+this.coffs[1]*e.y+this.coffs[2]*e.z,this.coffs[3]*e.x+this.coffs[4]*e.y+this.coffs[5]*e.z,this.coffs[6]*e.x+this.coffs[7]*e.y+this.coffs[8]*e.z)}static xyzMinusMatrixTimesXYZ(t,e,r,i){const n=r.x,s=r.y,o=r.z;return a.Point3d.create(t.x-(e.coffs[0]*n+e.coffs[1]*s+e.coffs[2]*o),t.y-(e.coffs[3]*n+e.coffs[4]*s+e.coffs[5]*o),t.z-(e.coffs[6]*n+e.coffs[7]*s+e.coffs[8]*o),i)}static xyPlusMatrixTimesXY(t,e,r,i){const n=r.x,s=r.y;return o.Point2d.create(t.x+e.coffs[0]*n+e.coffs[1]*s,t.y+e.coffs[3]*n+e.coffs[4]*s,i)}static xyzPlusMatrixTimesXYZ(t,e,r,i){const n=r.x,s=r.y,o=r.z;return a.Point3d.create(t.x+e.coffs[0]*n+e.coffs[1]*s+e.coffs[2]*o,t.y+e.coffs[3]*n+e.coffs[4]*s+e.coffs[5]*o,t.z+e.coffs[6]*n+e.coffs[7]*s+e.coffs[8]*o,i)}static xyzPlusMatrixTimesXYZInPlace(t,e,r){const i=r.x,n=r.y,s=r.z;r.x=t.x+e.coffs[0]*i+e.coffs[1]*n+e.coffs[2]*s,r.y=t.y+e.coffs[3]*i+e.coffs[4]*n+e.coffs[5]*s,r.z=t.z+e.coffs[6]*i+e.coffs[7]*n+e.coffs[8]*s}static xyzPlusMatrixTimesCoordinates(t,e,r,i,n,s){return a.Point3d.create(t.x+e.coffs[0]*r+e.coffs[1]*i+e.coffs[2]*n,t.y+e.coffs[3]*r+e.coffs[4]*i+e.coffs[5]*n,t.z+e.coffs[6]*r+e.coffs[7]*i+e.coffs[8]*n,s)}static xyzPlusMatrixTimesWeightedCoordinates(t,e,r,i,n,o,a){return s.Point4d.create(o*t.x+e.coffs[0]*r+e.coffs[1]*i+e.coffs[2]*n,o*t.y+e.coffs[3]*r+e.coffs[4]*i+e.coffs[5]*n,o*t.z+e.coffs[6]*r+e.coffs[7]*i+e.coffs[8]*n,o,a)}static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(t,e,r,i,n,s,o){return o||(o=new Float64Array(4)),o[0]=s*t.x+e.coffs[0]*r+e.coffs[1]*i+e.coffs[2]*n,o[1]=s*t.y+e.coffs[3]*r+e.coffs[4]*i+e.coffs[5]*n,o[2]=s*t.z+e.coffs[6]*r+e.coffs[7]*i+e.coffs[8]*n,o[3]=s,o}static xyzPlusMatrixTimesCoordinatesToFloat64Array(t,e,r,i,n,s){return s||(s=new Float64Array(3)),s[0]=t.x+e.coffs[0]*r+e.coffs[1]*i+e.coffs[2]*n,s[1]=t.y+e.coffs[3]*r+e.coffs[4]*i+e.coffs[5]*n,s[2]=t.z+e.coffs[6]*r+e.coffs[7]*i+e.coffs[8]*n,s}multiplyTransposeVector(t,e){e=e||new a.Vector3d;const r=t.x,i=t.y,n=t.z;return e.x=this.coffs[0]*r+this.coffs[3]*i+this.coffs[6]*n,e.y=this.coffs[1]*r+this.coffs[4]*i+this.coffs[7]*n,e.z=this.coffs[2]*r+this.coffs[5]*i+this.coffs[8]*n,e}multiplyXYZ(t,e,r,i){return(i=i||new a.Vector3d).x=this.coffs[0]*t+this.coffs[1]*e+this.coffs[2]*r,i.y=this.coffs[3]*t+this.coffs[4]*e+this.coffs[5]*r,i.z=this.coffs[6]*t+this.coffs[7]*e+this.coffs[8]*r,i}multiplyXYZtoXYZ(t,e){const r=t.x,i=t.y,n=t.z;return e.x=this.coffs[0]*r+this.coffs[1]*i+this.coffs[2]*n,e.y=this.coffs[3]*r+this.coffs[4]*i+this.coffs[5]*n,e.z=this.coffs[6]*r+this.coffs[7]*i+this.coffs[8]*n,e}multiplyXY(t,e,r){return(r=r||new a.Vector3d).x=this.coffs[0]*t+this.coffs[1]*e,r.y=this.coffs[3]*t+this.coffs[4]*e,r.z=this.coffs[6]*t+this.coffs[7]*e,r}originPlusMatrixTimesXY(t,e,r,i){return a.Point3d.create(t.x+this.coffs[0]*e+this.coffs[1]*r,t.y+this.coffs[3]*e+this.coffs[4]*r,t.z+this.coffs[6]*e+this.coffs[7]*r,i)}multiplyVectorInPlace(t){const e=t.x,r=t.y,i=t.z,n=this.coffs;t.x=n[0]*e+n[1]*r+n[2]*i,t.y=n[3]*e+n[4]*r+n[5]*i,t.z=n[6]*e+n[7]*r+n[8]*i}multiplyTransposeVectorInPlace(t){const e=t.x,r=t.y,i=t.z,n=this.coffs;t.x=n[0]*e+n[3]*r+n[6]*i,t.y=n[1]*e+n[4]*r+n[7]*i,t.z=n[2]*e+n[5]*r+n[8]*i}multiplyTransposeXYZ(t,e,r,i){return(i=i||new a.Vector3d).x=this.coffs[0]*t+this.coffs[3]*e+this.coffs[6]*r,i.y=this.coffs[1]*t+this.coffs[4]*e+this.coffs[7]*r,i.z=this.coffs[2]*t+this.coffs[5]*e+this.coffs[8]*r,i}multiplyInverse(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const r=t.x,i=t.y,n=t.z;return a.Vector3d.create(this.inverseCoffs[0]*r+this.inverseCoffs[1]*i+this.inverseCoffs[2]*n,this.inverseCoffs[3]*r+this.inverseCoffs[4]*i+this.inverseCoffs[5]*n,this.inverseCoffs[6]*r+this.inverseCoffs[7]*i+this.inverseCoffs[8]*n,e)}}multiplyInverseTranspose(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const r=t.x,i=t.y,n=t.z;return a.Vector3d.create(this.inverseCoffs[0]*r+this.inverseCoffs[3]*i+this.inverseCoffs[6]*n,this.inverseCoffs[1]*r+this.inverseCoffs[4]*i+this.inverseCoffs[7]*n,this.inverseCoffs[2]*r+this.inverseCoffs[5]*i+this.inverseCoffs[8]*n,e)}}multiplyInverseXYZAsVector3d(t,e,r,i){if(this.computeCachedInverse(!0),this.inverseCoffs)return a.Vector3d.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*r,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*r,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*r,i)}multiplyInverseXYZAsPoint3d(t,e,r,i){if(this.computeCachedInverse(!0),this.inverseCoffs)return a.Point3d.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*r,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*r,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*r,i)}multiplyMatrixMatrix(t,e){return e=e||new Matrix3d,PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs,t.coffs,e.coffs),e}multiplyMatrixMatrixInverse(t,e){if(t.computeCachedInverse(!0))return e=e||new Matrix3d,PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs,t.inverseCoffs,e.coffs),e}multiplyMatrixMatrixTranspose(t,e){return e=e||new Matrix3d,PackedMatrix3dOps.multiplyMatrixMatrixTranspose(this.coffs,t.coffs,e.coffs),e}multiplyMatrixTransposeMatrix(t,e){return e=e||new Matrix3d,PackedMatrix3dOps.multiplyMatrixTransposeMatrix(this.coffs,t.coffs,e.coffs),e}multiplyMatrixTransform(t,e){return e?(this.multiplyXYZtoXYZ(t.origin,e.origin),this.multiplyMatrixMatrix(t.matrix,e.matrix),e):c.Transform.createRefs(this.multiplyXYZ(t.origin.x,t.origin.y,t.origin.z),this.multiplyMatrixMatrix(t.matrix))}transpose(t){return t||(t=new Matrix3d),PackedMatrix3dOps.copyTransposed(this.coffs,t.coffs),void 0!==this.inverseCoffs?(t.inverseState=l.inverseStored,t.inverseCoffs=PackedMatrix3dOps.copyTransposed(this.inverseCoffs,t.inverseCoffs)):(t.inverseState=this.inverseState,t.inverseCoffs=void 0),t}transposeInPlace(){PackedMatrix3dOps.transposeInPlace(this.coffs),this.inverseCoffs&&PackedMatrix3dOps.transposeInPlace(this.inverseCoffs)}inverse(t){if(this.computeCachedInverse(!0),this.inverseState===l.inverseStored&&this.inverseCoffs)return Matrix3d.createRowValues(this.inverseCoffs[0],this.inverseCoffs[1],this.inverseCoffs[2],this.inverseCoffs[3],this.inverseCoffs[4],this.inverseCoffs[5],this.inverseCoffs[6],this.inverseCoffs[7],this.inverseCoffs[8],t)}setupInverseTranspose(){const t=this.coffs;this.inverseState=l.inverseStored,this.inverseCoffs=Float64Array.from([t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]])}static indexedRowCrossProduct(t,e,r,i,n){i[n]=t[e+1]*t[r+2]-t[e+2]*t[r+1],i[n+3]=t[e+2]*t[r]-t[e]*t[r+2],i[n+6]=t[e]*t[r+1]-t[e+1]*t[r]}indexedColumnCrossProductInPlace(t,e,r){const i=this.coffs;i[r]=i[t+3]*i[e+6]-i[t+6]*i[e+3],i[r+3]=i[t+6]*i[e]-i[t]*i[e+6],i[r+6]=i[t]*i[e+3]-i[t+3]*i[e]}axisOrderCrossProductsInPlace(t){switch(t){case i.AxisOrder.XYZ:this.indexedColumnCrossProductInPlace(0,1,2),this.indexedColumnCrossProductInPlace(2,0,1);break;case i.AxisOrder.YZX:this.indexedColumnCrossProductInPlace(1,2,0),this.indexedColumnCrossProductInPlace(0,1,2);break;case i.AxisOrder.ZXY:this.indexedColumnCrossProductInPlace(2,0,1),this.indexedColumnCrossProductInPlace(1,2,0);break;case i.AxisOrder.XZY:this.indexedColumnCrossProductInPlace(0,2,1),this.indexedColumnCrossProductInPlace(1,0,2);break;case i.AxisOrder.YXZ:this.indexedColumnCrossProductInPlace(1,0,2),this.indexedColumnCrossProductInPlace(2,1,0);break;case i.AxisOrder.ZYX:this.indexedColumnCrossProductInPlace(2,1,0),this.indexedColumnCrossProductInPlace(0,2,1)}}normalizeColumnsInPlace(t){const e=this.columnXMagnitude(),r=this.columnYMagnitude(),n=this.columnZMagnitude();return t&&t.set(e,r,n),!(i.Geometry.isSmallMetricDistance(e)||i.Geometry.isSmallMetricDistance(r)||i.Geometry.isSmallMetricDistance(n))&&(this.scaleColumns(1/e,1/r,1/n,this),!0)}normalizeRowsInPlace(t){const e=this.rowXMagnitude(),r=this.rowYMagnitude(),n=this.rowZMagnitude();return t&&t.set(e,r,n),!(i.Geometry.isSmallMetricDistance(e)||i.Geometry.isSmallMetricDistance(r)||i.Geometry.isSmallMetricDistance(n))&&(this.scaleRows(1/e,1/r,1/n,this),!0)}static rowColumnDot(t,e,r,i){return t[e]*r[i]+t[e+1]*r[i+3]+t[e+2]*r[i+6]}isSingular(){return!this.computeCachedInverse(!0)}markSingular(){this.inverseState=l.singular}computeCachedInverse(t){if(t&&Matrix3d.useCachedInverse&&this.inverseState!==l.unknown)return Matrix3d.numUseCache++,this.inverseState===l.inverseStored;this.inverseState=l.unknown,void 0===this.inverseCoffs&&(this.inverseCoffs=new Float64Array(9));const e=this.coffs,r=this.inverseCoffs;Matrix3d.indexedRowCrossProduct(e,3,6,r,0),Matrix3d.indexedRowCrossProduct(e,6,0,r,1),Matrix3d.indexedRowCrossProduct(e,0,3,r,2),Matrix3d.numComputeCache++;const i=Matrix3d.rowColumnDot(e,0,r,0);if(0===i)return this.inverseState=l.singular,this.inverseCoffs=void 0,!1;const n=1/i;for(let s=0;s<9;s++)r[s]*=n;return this.inverseState=l.inverseStored,!0}static flatIndexOf(t,e){return 3*i.Geometry.cyclic3dAxis(t)+i.Geometry.cyclic3dAxis(e)}indexedColumnWithWeight(t,e,r){return t=i.Geometry.cyclic3dAxis(t),s.Point4d.create(this.coffs[t],this.coffs[t+3],this.coffs[t+6],e,r)}at(t,e){return this.coffs[Matrix3d.flatIndexOf(t,e)]}setAt(t,e,r){this.coffs[Matrix3d.flatIndexOf(t,e)]=r,this.inverseState=l.unknown}scaleColumns(t,e,r,i){return Matrix3d.createRowValues(this.coffs[0]*t,this.coffs[1]*e,this.coffs[2]*r,this.coffs[3]*t,this.coffs[4]*e,this.coffs[5]*r,this.coffs[6]*t,this.coffs[7]*e,this.coffs[8]*r,i)}scaleColumnsInPlace(t,e,r){if(this.coffs[0]*=t,this.coffs[1]*=e,this.coffs[2]*=r,this.coffs[3]*=t,this.coffs[4]*=e,this.coffs[5]*=r,this.coffs[6]*=t,this.coffs[7]*=e,this.coffs[8]*=r,this.inverseState===l.inverseStored&&void 0!==this.inverseCoffs){const n=i.Geometry.conditionalDivideFraction(1,t),s=i.Geometry.conditionalDivideFraction(1,e),o=i.Geometry.conditionalDivideFraction(1,r);void 0!==n&&void 0!==s&&void 0!==o?(this.inverseCoffs[0]*=n,this.inverseCoffs[1]*=n,this.inverseCoffs[2]*=n,this.inverseCoffs[3]*=s,this.inverseCoffs[4]*=s,this.inverseCoffs[5]*=s,this.inverseCoffs[6]*=o,this.inverseCoffs[7]*=o,this.inverseCoffs[8]*=o):this.inverseState=l.singular}}scaleRows(t,e,r,i){return Matrix3d.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*e,this.coffs[4]*e,this.coffs[5]*e,this.coffs[6]*r,this.coffs[7]*r,this.coffs[8]*r,i)}addScaledInPlace(t,e){for(let r=0;r<9;r++)this.coffs[r]+=e*t.coffs[r];this.inverseState=l.unknown}addScaledOuterProductInPlace(t,e,r){this.coffs[0]+=r*t.x*e.x,this.coffs[1]+=r*t.x*e.y,this.coffs[2]+=r*t.x*e.z,this.coffs[3]+=r*t.y*e.x,this.coffs[4]+=r*t.y*e.y,this.coffs[5]+=r*t.y*e.z,this.coffs[6]+=r*t.z*e.x,this.coffs[7]+=r*t.z*e.y,this.coffs[8]+=r*t.z*e.z,this.inverseState=l.unknown}scale(t,e){return Matrix3d.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*t,this.coffs[4]*t,this.coffs[5]*t,this.coffs[6]*t,this.coffs[7]*t,this.coffs[8]*t,e)}determinant(){return this.coffs[0]*this.coffs[4]*this.coffs[8]-this.coffs[0]*this.coffs[7]*this.coffs[5]+this.coffs[3]*this.coffs[7]*this.coffs[2]-this.coffs[3]*this.coffs[1]*this.coffs[8]+this.coffs[6]*this.coffs[1]*this.coffs[5]-this.coffs[6]*this.coffs[4]*this.coffs[2]}conditionNumber(){const t=this.determinant(),e=i.Geometry.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])+i.Geometry.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])+i.Geometry.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8]);return i.Geometry.safeDivideFraction(t,e,0)}sumSquares(){let t=0,e=0;for(t=0;t<9;t++)e+=this.coffs[t]*this.coffs[t];return e}sumDiagonalSquares(){let t=0,e=0;for(t=0;t<9;t+=4)e+=this.coffs[t]*this.coffs[t];return e}sumDiagonal(){return this.coffs[0]+this.coffs[4]+this.coffs[8]}maxAbs(){let t=0,e=0;for(t=0;t<9;t++)e=Math.max(e,Math.abs(this.coffs[t]));return e}maxDiff(t){let e=0,r=0;for(e=0;e<9;e++)r=Math.max(r,Math.abs(this.coffs[e]-t.coffs[e]));return r}get isIdentity(){return this.maxDiff(Matrix3d.identity)<i.Geometry.smallAngleRadians}get isDiagonal(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),r=Math.abs(t-e);return Math.sqrt(r)<=i.Geometry.smallAngleRadians*(1+Math.sqrt(t))}get isUpperTriangular(){const t=this.sumSquares(),e=i.Geometry.hypotenuseSquaredXYZ(this.coffs[3],this.coffs[6],this.coffs[7]);return Math.sqrt(e)<=i.Geometry.smallAngleRadians*(1+Math.sqrt(t))}sameDiagonalScale(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),r=Math.abs(t-e);if(Math.sqrt(r)<=i.Geometry.smallAngleRadians*(1+Math.sqrt(t))&&i.Geometry.isSameCoordinate(this.coffs[0],this.coffs[4])&&i.Geometry.isSameCoordinate(this.coffs[0],this.coffs[8]))return this.coffs[0]}sumSkewSquares(){return i.Geometry.hypotenuseSquaredXYZ(this.coffs[1]-this.coffs[3],this.coffs[2]-this.coffs[6],this.coffs[5]-this.coffs[7])}isRigid(t=!1){return this.testPerpendicularUnitRowsAndColumns()&&(t||this.determinant()>0)}factorRigidWithSignedScale(){const t=this.multiplyMatrixMatrixTranspose(this).sameDiagonalScale();if(void 0===t||t<=0)return;const e=this.determinant()>0?Math.sqrt(t):-Math.sqrt(t),r=1/e;return{rigidAxes:this.scaleColumns(r,r,r),scale:e}}get isSignedPermutation(){let t=0;for(let e=0;e<3;e++)for(let r=0;r<3;r++){const i=this.at(e,r);if(0===i);else{if(1!==i&&-1!==i)return!1;if(t++,0!==this.at(e+1,r))return!1;if(0!==this.at(e+2,r))return!1;if(0!==this.at(e,r+1))return!1;if(0!==this.at(e,r+2))return!1}}return 3===t}testPerpendicularUnitRowsAndColumns(){return this.multiplyMatrixMatrixTranspose(this).isIdentity}static createRigidFromColumns(t,e,r,i){const n=t.normalize();if(n){const s=n.unitCrossProduct(e);if(s){const e=s.unitCrossProduct(t);if(e){const t=Matrix3d.createShuffledColumns(n,e,s,r,i);return t.setupInverseTranspose(),t}}}}static createRigidFromMatrix3d(t,e=i.AxisOrder.XYZ,r){if((r=t.clone(r)).axisOrderCrossProductsInPlace(e),r.normalizeColumnsInPlace())return r}static computeQuatTerm(t,e,r,i){let n;return i>.5?(n=.5*Math.sqrt(i),e*t<0&&(n=-n)):n=t*r,n}static createFromQuaternion(t){const e=t.x*t.x,r=t.y*t.y,i=t.z*t.z,n=t.w*t.w,s=e+r+i+n;if(0===s)return Matrix3d.createIdentity();{const o=1/s;return Matrix3d.createRowValues(o*(n+e-r-i),2*o*(t.w*t.z+t.x*t.y),2*o*(t.x*t.z-t.w*t.y),2*o*(t.x*t.y-t.w*t.z),o*(n-e+r-i),2*o*(t.w*t.x+t.y*t.z),2*o*(t.x*t.z+t.w*t.y),2*o*(t.y*t.z-t.w*t.x),o*(n-e-r+i))}}toQuaternion(){const t=s.Point4d.createZero(),e=[[this.coffs[0],this.coffs[3],this.coffs[6]],[this.coffs[1],this.coffs[4],this.coffs[7]],[this.coffs[2],this.coffs[5],this.coffs[8]]],r=e[0][0],i=e[1][1],n=e[2][2],o=[];let a,c,l;for(o[0]=1+r-i-n,o[1]=1-r+i-n,o[2]=1-r-i+n,o[3]=1+r+i+n,c=0,l=1;l<4;l++)o[l]>o[c]&&(c=l);return 0===c?(t.x=.5*Math.sqrt(o[0]),a=1/(4*t.x),t.y=Matrix3d.computeQuatTerm(e[0][1]+e[1][0],t.x,a,o[1]),t.z=Matrix3d.computeQuatTerm(e[0][2]+e[2][0],t.x,a,o[2]),t.w=Matrix3d.computeQuatTerm(e[2][1]-e[1][2],t.x,a,o[3])):1===c?(t.y=.5*Math.sqrt(o[1]),a=1/(4*t.y),t.x=Matrix3d.computeQuatTerm(e[0][1]+e[1][0],t.y,a,o[0]),t.z=Matrix3d.computeQuatTerm(e[1][2]+e[2][1],t.y,a,o[2]),t.w=Matrix3d.computeQuatTerm(e[0][2]-e[2][0],t.y,a,o[3])):2===c?(t.z=.5*Math.sqrt(o[2]),a=1/(4*t.z),t.x=Matrix3d.computeQuatTerm(e[0][2]+e[2][0],t.z,a,o[0]),t.y=Matrix3d.computeQuatTerm(e[1][2]+e[2][1],t.z,a,o[1]),t.w=Matrix3d.computeQuatTerm(e[1][0]-e[0][1],t.z,a,o[3])):(t.w=.5*Math.sqrt(o[3]),a=1/(4*t.w),t.x=Matrix3d.computeQuatTerm(e[2][1]-e[1][2],t.w,a,o[0]),t.y=Matrix3d.computeQuatTerm(e[0][2]-e[2][0],t.w,a,o[1]),t.z=Matrix3d.computeQuatTerm(e[1][0]-e[0][1],t.w,a,o[2])),t}}e.Matrix3d=Matrix3d,Matrix3d.useCachedInverse=!0,Matrix3d.numUseCache=0,Matrix3d.numComputeCache=0},"./lib/geometry3d/OrderedRotationAngles.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Angle.js"),s=r("./lib/geometry3d/Matrix3d.js");class OrderedRotationAngles{constructor(t,e,r,i){this._x=t,this._y=e,this._z=r,this._order=i}get order(){return this._order}get xAngle(){return this._x.clone()}get yAngle(){return this._y.clone()}get zAngle(){return this._z.clone()}get xDegrees(){return this._x.degrees}get xRadians(){return this._x.radians}get yDegrees(){return this._y.degrees}get yRadians(){return this._y.radians}get zDegrees(){return this._z.degrees}get zRadians(){return this._z.radians}static get treatVectorsAsColumns(){return OrderedRotationAngles._sTreatVectorsAsColumns}static set treatVectorsAsColumns(t){OrderedRotationAngles._sTreatVectorsAsColumns=t}static createAngles(t,e,r,i,n){return n?(n._x.setFrom(t),n._y.setFrom(e),n._z.setFrom(r),n._order=i,n):new OrderedRotationAngles(t.clone(),e.clone(),r.clone(),i)}static createRadians(t,e,r,i,s){return s?(s._x.setRadians(t),s._y.setRadians(e),s._z.setRadians(r),s._order=i,s):new OrderedRotationAngles(n.Angle.createRadians(t),n.Angle.createRadians(e),n.Angle.createRadians(r),i)}static createDegrees(t,e,r,i,s){return s?(s._x.setDegrees(t),s._y.setDegrees(e),s._z.setDegrees(r),s._order=i,s):new OrderedRotationAngles(n.Angle.createDegrees(t),n.Angle.createDegrees(e),n.Angle.createDegrees(r),i)}static createFromMatrix3d(t,e,r){let n,s,o,a=t.coffs[0],c=t.coffs[3],l=t.coffs[6],d=t.coffs[1],h=t.coffs[4],u=t.coffs[7],f=t.coffs[2],g=t.coffs[5],p=t.coffs[8];switch(OrderedRotationAngles.treatVectorsAsColumns&&(a=t.coffs[0],c=t.coffs[1],l=t.coffs[2],d=t.coffs[3],h=t.coffs[4],u=t.coffs[5],f=t.coffs[6],g=t.coffs[7],p=t.coffs[8]),e){case i.AxisOrder.XYZ:s=Math.asin(Math.max(-1,Math.min(1,l))),Math.abs(l)<.99999?(n=Math.atan2(-u,p),o=Math.atan2(-c,a)):(n=Math.atan2(g,h),o=0);break;case i.AxisOrder.YXZ:n=Math.asin(-Math.max(-1,Math.min(1,u))),Math.abs(u)<.99999?(s=Math.atan2(l,p),o=Math.atan2(d,h)):(s=Math.atan2(-f,a),o=0);break;case i.AxisOrder.ZXY:n=Math.asin(Math.max(-1,Math.min(1,g))),Math.abs(g)<.99999?(s=Math.atan2(-f,p),o=Math.atan2(-c,h)):(s=0,o=Math.atan2(d,a));break;case i.AxisOrder.ZYX:s=-Math.asin(Math.max(-1,Math.min(1,f))),Math.abs(f)<.99999?(n=Math.atan2(g,p),o=Math.atan2(d,a)):(n=0,o=Math.atan2(-c,h));break;case i.AxisOrder.YZX:o=Math.asin(Math.max(-1,Math.min(1,d))),Math.abs(d)<.99999?(n=Math.atan2(-u,h),s=Math.atan2(-f,a)):(n=0,s=Math.atan2(l,p));break;case i.AxisOrder.XZY:o=-Math.asin(Math.max(-1,Math.min(1,c))),Math.abs(c)<.99999?(n=Math.atan2(g,h),s=Math.atan2(l,a)):(n=Math.atan2(-u,p),s=0);break;default:n=s=o=0}return OrderedRotationAngles.treatVectorsAsColumns?OrderedRotationAngles.createRadians(-n,-s,-o,e,r):OrderedRotationAngles.createRadians(n,s,o,e,r)}toMatrix3d(t){const e=void 0!==t?t:new s.Matrix3d,r=this.order,n=this.xAngle,o=this.yAngle,a=this.zAngle,c=n.cos();let l=n.sin();const d=o.cos();let h=o.sin();const u=a.cos();let f=a.sin();if(OrderedRotationAngles.treatVectorsAsColumns&&(l=-l,h=-h,f=-f),r===i.AxisOrder.XYZ){const t=c*u,r=c*f,i=l*u,n=l*f;e.setRowValues(d*u,r+i*h,n-t*h,-d*f,t-n*h,i+r*h,h,-l*d,c*d)}else if(r===i.AxisOrder.YXZ){const t=d*u,r=d*f,i=h*u,n=h*f;e.setRowValues(t+n*l,c*f,r*l-i,i*l-r,c*u,n+t*l,c*h,-l,c*d)}else if(r===i.AxisOrder.ZXY){const t=d*u,r=d*f,i=h*u,n=h*f;e.setRowValues(t-n*l,r+i*l,-c*h,-c*f,c*u,l,i+r*l,n-t*l,c*d)}else if(r===i.AxisOrder.ZYX){const t=c*u,r=c*f,i=l*u,n=l*f;e.setRowValues(d*u,d*f,-h,i*h-r,n*h+t,l*d,t*h+n,r*h-i,c*d)}else if(r===i.AxisOrder.YZX){const t=c*d,r=c*h,i=l*d,n=l*h;e.setRowValues(d*u,f,-h*u,n-t*f,c*u,r*f+i,i*f+r,-l*u,t-n*f)}else if(r===i.AxisOrder.XZY){const t=c*d,r=c*h,i=l*d,n=l*h;e.setRowValues(d*u,t*f+n,i*f-r,-f,c*u,l*u,h*u,r*f-i,n*f+t)}return OrderedRotationAngles.treatVectorsAsColumns&&e.transposeInPlace(),e}}e.OrderedRotationAngles=OrderedRotationAngles,OrderedRotationAngles._sTreatVectorsAsColumns=!1},"./lib/geometry3d/Plane3dByOriginAndUnitNormal.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Transform.js"),s=r("./lib/Geometry.js"),o=r("./lib/geometry3d/Matrix3d.js");class Plane3dByOriginAndUnitNormal{constructor(t,e){this._origin=t,this._normal=e}static _create(t,e,r,n,s,o){return new Plane3dByOriginAndUnitNormal(i.Point3d.create(t,e,r),i.Vector3d.create(n,s,o))}static createXYPlane(t){return t?Plane3dByOriginAndUnitNormal._create(t.x,t.y,t.z,0,0,1):Plane3dByOriginAndUnitNormal._create(0,0,0,0,0,1)}static createYZPlane(t){return t?Plane3dByOriginAndUnitNormal._create(t.x,t.y,t.z,1,0,0):Plane3dByOriginAndUnitNormal._create(0,0,0,1,0,0)}static createZXPlane(t){return t?Plane3dByOriginAndUnitNormal._create(t.x,t.y,t.z,0,1,0):Plane3dByOriginAndUnitNormal._create(0,0,0,0,1,0)}static create(t,e,r){const i=e.normalize();if(i)return r?(r.set(t,i),r):new Plane3dByOriginAndUnitNormal(t.clone(),i)}static createXYZUVW(t,e,r,n,o,a,c){const l=s.Geometry.hypotenuseXYZ(n,o,a);if(!(l<s.Geometry.smallMetricDistance))return c?(c._origin.set(t,e,r),c._normal.set(n/l,o/l,a/l),c):new Plane3dByOriginAndUnitNormal(i.Point3d.create(t,e,r),i.Vector3d.create(n/l,o/l,a/l))}static createXYAngle(t,e,r,n){return n?(n._origin.set(t,e,0),n._normal.set(r.cos(),r.sin(),0),n):new Plane3dByOriginAndUnitNormal(i.Point3d.create(t,e,0),i.Vector3d.create(r.cos(),r.sin()))}static createPointPointVectorInPlane(t,e,r){const i=r.crossProductStartEnd(t,e);if(i.tryNormalizeInPlace())return new Plane3dByOriginAndUnitNormal(t,i)}isAlmostEqual(t){return this._origin.isAlmostEqual(t._origin)&&this._normal.isAlmostEqual(t._normal)}setFromJSON(t){t?(this._origin.setFromJSON(t.origin),this._normal.setFromJSON(t.normal)):(this._origin.set(0,0,0),this._normal.set(0,0,1))}toJSON(){return{origin:this._origin.toJSON(),normal:this._normal.toJSON()}}static fromJSON(t){const e=Plane3dByOriginAndUnitNormal.createXYPlane();return e.setFromJSON(t),e}getOriginRef(){return this._origin}getNormalRef(){return this._normal}getLocalToWorld(){const t=o.Matrix3d.createRigidHeadsUp(this._normal,s.AxisOrder.ZXY);return n.Transform.createRefs(this._origin.clone(),t)}getProjectionToPlane(){const t=o.Matrix3d.createIdentity();return t.addScaledOuterProductInPlace(this._normal,this._normal,-1),t.markSingular(),n.Transform.createFixedPointAndMatrix(this._origin,t)}set(t,e){this._origin.setFrom(t),this._normal.setFrom(e)}clone(t){return t?(t.set(this._origin,this._normal),t):new Plane3dByOriginAndUnitNormal(this._origin.clone(),this._normal.clone())}cloneTransformed(t){const e=this.clone();if(t.multiplyPoint3d(e._origin,e._origin),void 0!==t.matrix.multiplyInverseTranspose(e._normal,e._normal)&&e._normal.normalizeInPlace())return e}setFrom(t){this.set(t._origin,t._normal)}altitude(t){return this._normal.dotProductStartEnd(this._origin,t)}weightedAltitude(t){return this._normal.dotProductStart3dEnd4d(this._origin,t)}altitudeToPoint(t,e){return this._origin.plusScaled(this._normal,t,e)}velocityXYZ(t,e,r){return this._normal.dotProductXYZ(t,e,r)}velocity(t){return this._normal.dotProduct(t)}altitudeXYZ(t,e,r){return this._normal.dotProductStartEndXYZ(this._origin,t,e,r)}altitudeXYZW(t,e,r,i){return this._normal.dotProductStartEndXYZW(this._origin,t,e,r,i)}projectPointToPlane(t,e){return t.plusScaled(this._normal,-this._normal.dotProductStartEnd(this._origin,t),e)}isPointInPlane(t){return s.Geometry.isSmallMetricDistance(this.altitude(t))}}e.Plane3dByOriginAndUnitNormal=Plane3dByOriginAndUnitNormal},"./lib/geometry3d/Plane3dByOriginAndVectors.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/Geometry.js");class Plane3dByOriginAndVectors{constructor(t,e,r){this.origin=t,this.vectorU=e,this.vectorV=r}static createOriginAndVectors(t,e,r,i){return i?(i.origin.setFrom(t),i.vectorU.setFrom(e),i.vectorV.setFrom(r),i):new Plane3dByOriginAndVectors(t.clone(),e.clone(),r.clone())}static createFromTransformColumnsXYAndLengths(t,e,r,i){return i?(i.origin.setFrom(t.getOrigin()),t.matrix.columnX(i.vectorU),t.matrix.columnY(i.vectorV)):i=new Plane3dByOriginAndVectors(t.getOrigin(),t.matrix.columnX(),t.matrix.columnY()),void 0!==e&&i.vectorU.scaleToLength(e,i.vectorU),void 0!==r&&i.vectorV.scaleToLength(r,i.vectorV),i}static createCapture(t,e,r,i){return i?(i.origin=t,i.vectorU=e,i.vectorV=r,i):new Plane3dByOriginAndVectors(t,e,r)}setOriginAndVectorsXYZ(t,e,r,i,n,s,o,a,c){return this.origin.set(t,e,r),this.vectorU.set(i,n,s),this.vectorV.set(o,a,c),this}setOriginAndVectors(t,e,r){return this.origin.setFrom(t),this.vectorU.setFrom(e),this.vectorV.setFrom(r),this}static createOriginAndVectorsXYZ(t,e,r,n,s,o,a,c,l,d){return d?d.setOriginAndVectorsXYZ(t,e,r,n,s,o,a,c,l):new Plane3dByOriginAndVectors(i.Point3d.create(t,e,r),i.Vector3d.create(n,s,o),i.Vector3d.create(a,c,l))}static createOriginAndTargets(t,e,r,i){return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,r.x-t.x,r.y-t.y,r.z-t.z,i)}static createXYPlane(t){return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(0,0,0,1,0,0,0,1,0,t)}static createOriginAndVectorsArrays(t,e,r,i){return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(t[0],t[1],t[2],e[0],e[1],e[2],r[0],r[1],r[2],i)}static createOriginAndVectorsWeightedArrays(t,e,r,s){const o=t[3];if(s=Plane3dByOriginAndVectors.createXYPlane(s),n.Geometry.isSmallMetricDistance(o))return s;const a=1/o,c=e[3]*a*a,l=r[3]*a*a;return s.origin.set(t[0]*a,t[1]*a,t[2]*a),i.Vector3d.createAdd2ScaledXYZ(e[0],e[1],e[2],a,t[0],t[1],t[2],-c,s.vectorU),i.Vector3d.createAdd2ScaledXYZ(r[0],r[1],r[2],a,t[0],t[1],t[2],-l,s.vectorV),s}fractionToPoint(t,e,r){return this.origin.plus2Scaled(this.vectorU,t,this.vectorV,e,r)}fractionToVector(t,e,r){return i.Vector3d.createAdd2Scaled(this.vectorU,t,this.vectorV,e,r)}setFromJSON(t){t&&t.origin&&t.vectorV?(this.origin.setFromJSON(t.origin),this.vectorU.setFromJSON(t.vectorU),this.vectorV.setFromJSON(t.vectorV)):(this.origin.set(0,0,0),this.vectorU.set(1,0,0),this.vectorV.set(0,1,0))}toJSON(){return{origin:this.origin.toJSON(),vectorU:this.vectorU.toJSON(),vectorV:this.vectorV.toJSON()}}static fromJSON(t){const e=Plane3dByOriginAndVectors.createXYPlane();return e.setFromJSON(t),e}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.vectorU.isAlmostEqual(t.vectorU)&&this.vectorV.isAlmostEqual(t.vectorV)}}e.Plane3dByOriginAndVectors=Plane3dByOriginAndVectors},"./lib/geometry3d/Point2dArrayCarrier.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/IndexedXYCollection.js");e.Point2dArrayCarrier=class Point2dArrayCarrier extends n.IndexedXYCollection{constructor(t){super(),this.data=t}isValidIndex(t){return t>=0&&t<this.data.length}getPoint2dAtCheckedPointIndex(t,e){if(this.isValidIndex(t)){const r=this.data[t];return i.Point2d.create(r.x,r.y,e)}}getVector2dAtCheckedVectorIndex(t,e){if(this.isValidIndex(t)){const r=this.data[t];return i.Vector2d.create(r.x,r.y,e)}}vectorIndexIndex(t,e,r){if(this.isValidIndex(t)&&this.isValidIndex(e))return i.Vector2d.createStartEnd(this.data[t],this.data[e],r)}vectorXAndYIndex(t,e,r){if(this.isValidIndex(e))return i.Vector2d.createStartEnd(t,this.data[e],r)}crossProductXAndYIndexIndex(t,e,r){if(this.isValidIndex(e)&&this.isValidIndex(r))return i.XY.crossProductToPoints(t,this.data[e],this.data[r])}crossProductIndexIndexIndex(t,e,r){if(this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(r))return i.XY.crossProductToPoints(this.data[t],this.data[e],this.data[r])}get length(){return this.data.length}}},"./lib/geometry3d/Point2dVector2d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Angle.js");class XY{constructor(t=0,e=0){this.x=t,this.y=e}set(t=0,e=0){this.x=t,this.y=e}setZero(){this.x=0,this.y=0}setFrom(t){t?(this.x=t.x,this.y=t.y):(this.x=0,this.y=0)}freeze(){Object.freeze(this)}isAlmostEqual(t,e){return i.Geometry.isSameCoordinate(this.x,t.x,e)&&i.Geometry.isSameCoordinate(this.y,t.y,e)}isAlmostEqualXY(t,e,r){return i.Geometry.isSameCoordinate(this.x,t,r)&&i.Geometry.isSameCoordinate(this.y,e,r)}toJSON(){return[this.x,this.y]}toJSONXY(){return{x:this.x,y:this.y}}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0):t?this.set(t.x||0,t.y||0):this.set(0,0)}distance(t){const e=t.x-this.x,r=t.y-this.y;return Math.sqrt(e*e+r*r)}distanceSquared(t){const e=t.x-this.x,r=t.y-this.y;return e*e+r*r}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))}get isAlmostZero(){return i.Geometry.isSmallMetricDistance(this.x)&&i.Geometry.isSmallMetricDistance(this.y)}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquared(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y}isAlmostEqualMetric(t){return this.maxDiff(t)<=i.Geometry.smallMetricDistance}vectorTo(t,e){return Vector2d.create(t.x-this.x,t.y-this.y,e)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}static crossProductToPoints(t,e,r){return i.Geometry.crossProductXYXY(e.x-t.x,e.y-t.y,r.x-t.x,r.y-t.y)}}e.XY=XY;class Point2d extends XY{constructor(t=0,e=0){super(t,e)}clone(){return new Point2d(this.x,this.y)}static create(t=0,e=0,r){return r?(r.x=t,r.y=e,r):new Point2d(t,e)}static fromJSON(t){const e=new Point2d;return e.setFromJSON(t),e}static createFrom(t,e){return t?Point2d.create(t.x,t.y,e):Point2d.create(0,0,e)}static createZero(t){return Point2d.create(0,0,t)}addForwardLeft(t,e,r){const i=r.x,n=r.y;return Point2d.create(this.x+t*i-e*n,this.y+t*n+e*i)}forwardLeftInterpolate(t,e,r){const i=r.x-this.x,n=r.y-this.y;return Point2d.create(this.x+t*i-e*n,this.y+t*n+e*i)}interpolate(t,e,r){if(t<=.5)return Point2d.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),r);const i=t-1;return Point2d.create(e.x+i*(e.x-this.x),e.y+i*(e.y-this.y),r)}interpolateXY(t,e,r,n){return Point2d.create(i.Geometry.interpolate(this.x,t,r.x),i.Geometry.interpolate(this.y,e,r.y),n)}minus(t,e){return Point2d.create(this.x-t.x,this.y-t.y,e)}plus(t,e){return Point2d.create(this.x+t.x,this.y+t.y,e)}plusXY(t=0,e=0,r){return Point2d.create(this.x+t,this.y+e,r)}plusScaled(t,e,r){return Point2d.create(this.x+t.x*e,this.y+t.y*e,r)}plus2Scaled(t,e,r,i,n){return Point2d.create(this.x+t.x*e+r.x*i,this.y+t.y*e+r.y*i,n)}plus3Scaled(t,e,r,i,n,s,o){return Point2d.create(this.x+t.x*e+r.x*i+n.x*s,this.y+t.y*e+r.y*i+n.y*s,o)}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)}crossProductToPoints(t,e){const r=t.x-this.x,i=t.y-this.y,n=e.x-this.x;return r*(e.y-this.y)-i*n}fractionOfProjectionToLine(t,e,r){const n=t.distanceSquared(e);return n<i.Geometry.smallMetricDistanceSquared?r||0:t.dotVectorsToTargets(e,this)/n}}e.Point2d=Point2d;class Vector2d extends XY{constructor(t=0,e=0){super(t,e)}clone(){return new Vector2d(this.x,this.y)}static create(t=0,e=0,r){return r?(r.x=t,r.y=e,r):new Vector2d(t,e)}static unitX(t=1){return new Vector2d(t,0)}static unitY(t=1){return new Vector2d(0,t)}static createZero(t){return Vector2d.create(0,0,t)}static createFrom(t,e){return t instanceof Float64Array?t.length>=2?Vector2d.create(t[0],t[1]):t.length>=1?Vector2d.create(t[0],0):Vector2d.create(0,0):Vector2d.create(t.x,t.y,e)}static fromJSON(t){const e=new Vector2d;return e.setFromJSON(t),e}static createPolar(t,e){return Vector2d.create(t*e.cos(),t*e.sin())}static createStartEnd(t,e,r){return Vector2d.create(e.x-t.x,e.y-t.y,r)}static createOffsetBisector(t,e,r){let i=t.plus(e);if(i=i.normalize()){const e=r*i.dotProduct(t);return i.safeDivideOrNull(e)}}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalize(t){const e=i.Geometry.correctSmallMetricDistance(this.magnitude());return t=t||new Vector2d,this.safeDivideOrNull(e,t)}fractionOfProjectionToVector(t,e){const r=this.dotProduct(t),n=t.magnitudeSquared();return n<i.Geometry.smallMetricDistanceSquared?e||0:r/n}negate(t){return(t=t||new Vector2d).x=-this.x,t.y=-this.y,t}rotate90CCWXY(t){t=t||new Vector2d;const e=this.x,r=this.y;return t.x=-r,t.y=e,t}rotate90CWXY(t){t=t||new Vector2d;const e=this.x,r=this.y;return t.x=r,t.y=-e,t}unitPerpendicularXY(t){t=t||new Vector2d;const e=this.x,r=this.y;t.x=-r,t.y=e;const i=e*e+r*r;if(0!==i){const e=1/Math.sqrt(i);t.x*=e,t.y*=e}return t}rotateXY(t,e){const r=t.sin(),i=t.cos(),n=this.x,s=this.y;return(e=e||new Vector2d).x=n*i-s*r,e.y=n*r+s*i,e}interpolate(t,e,r){if(r=r||new Vector2d,t<=.5)r.x=this.x+t*(e.x-this.x),r.y=this.y+t*(e.y-this.y);else{const i=t-1;r.x=e.x+i*(e.x-this.x),r.y=e.y+i*(e.y-this.y)}return r}plus(t,e){return(e=e||new Vector2d).x=this.x+t.x,e.y=this.y+t.y,e}minus(t,e){return(e=e||new Vector2d).x=this.x-t.x,e.y=this.y-t.y,e}plusScaled(t,e,r){return(r=r||new Vector2d).x=this.x+t.x*e,r.y=this.y+t.y*e,r}plus2Scaled(t,e,r,i,n){return(n=n||new Vector2d).x=this.x+t.x*e+r.x*i,n.y=this.y+t.y*e+r.y*i,n}plus3Scaled(t,e,r,i,n,s,o){return(o=o||new Vector2d).x=this.x+t.x*e+r.x*i+n.x*s,o.y=this.y+t.y*e+r.y*i+n.y*s,o}scale(t,e){return(e=e||new Vector2d).x=this.x*t,e.y=this.y*t,e}scaleToLength(t,e){const r=i.Geometry.correctSmallMetricDistance(this.magnitude());if(0!==r)return this.scale(t/r,e)}dotProduct(t){return this.x*t.x+this.y*t.y}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}crossProduct(t){return this.x*t.y-this.y*t.x}angleTo(t){return n.Angle.createAtan2(this.crossProduct(t),this.dotProduct(t))}isParallelTo(t,e=!1){const r=this.magnitudeSquared(),n=t.magnitudeSquared();if(r<i.Geometry.smallMetricDistanceSquared||n<i.Geometry.smallMetricDistanceSquared)return!1;if(this.dotProduct(t)<0&&!e)return!1;const s=this.crossProduct(t);return s*s<=i.Geometry.smallAngleRadiansSquared*r*n}isPerpendicularTo(t){return n.Angle.isPerpendicularDotSet(this.magnitudeSquared(),t.magnitudeSquared(),this.dotProduct(t))}}e.Vector2d=Vector2d},"./lib/geometry3d/Point3dArrayCarrier.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/IndexedXYZCollection.js");e.Point3dArrayCarrier=class Point3dArrayCarrier extends n.IndexedReadWriteXYZCollection{constructor(t){super(),this.data=t}isValidIndex(t){return t>=0&&t<this.data.length}getPoint3dAtCheckedPointIndex(t,e){if(this.isValidIndex(t)){const r=this.data[t];return i.Point3d.create(r.x,r.y,r.z,e)}}getPoint3dAtUncheckedPointIndex(t,e){const r=this.data[t];return i.Point3d.create(r.x,r.y,r.z,e)}getVector3dAtCheckedVectorIndex(t,e){if(this.isValidIndex(t)){const r=this.data[t];return i.Vector3d.create(r.x,r.y,r.z,e)}}getXAtUncheckedPointIndex(t){return this.data[t].x}getYAtUncheckedPointIndex(t){return this.data[t].y}getZAtUncheckedPointIndex(t){return this.data[t].z}vectorIndexIndex(t,e,r){if(this.isValidIndex(t)&&this.isValidIndex(e))return i.Vector3d.createStartEnd(this.data[t],this.data[e],r)}vectorXYAndZIndex(t,e,r){if(this.isValidIndex(e))return i.Vector3d.createStartEnd(t,this.data[e],r)}crossProductXYAndZIndexIndex(t,e,r,n){if(this.isValidIndex(e)&&this.isValidIndex(r))return i.Vector3d.createCrossProductToPoints(t,this.data[e],this.data[r],n)}crossProductIndexIndexIndex(t,e,r,n){if(this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(r))return i.Vector3d.createCrossProductToPoints(this.data[t],this.data[e],this.data[r],n)}accumulateCrossProductIndexIndexIndex(t,e,r,i){const n=this.data;this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(r)&&i.addCrossProductToTargetsInPlace(n[t].x,n[t].y,n[t].z,n[e].x,n[e].y,n[e].z,n[r].x,n[r].y,n[r].z)}accumulateScaledXYZ(t,e,r){if(this.isValidIndex(t)){const i=this.data[t];r.x+=e*i.x,r.y+=e*i.y,r.z+=e*i.z}}get length(){return this.data.length}push(t){this.data.push(t.clone())}pushXYZ(t,e,r){this.data.push(i.Point3d.create(void 0===t?0:t,void 0===e?0:e,void 0===r?0:r))}back(t){if(this.data.length>0)return this.data[this.data.length-1].clone(t)}front(t){if(this.data.length>0)return this.data[0].clone(t)}pop(){this.data.length>0&&this.data.pop()}clear(){this.data.length=0}reverseInPlace(){this.data.reverse()}distanceSquaredIndexIndex(t,e){const r=this.data.length;if(t>=0&&t<r&&e>=0&&e<r)return this.data[t].distanceSquared(this.data[e])}distanceIndexIndex(t,e){const r=this.data.length;if(t>=0&&t<r&&e>=0&&e<r)return this.data[t].distance(this.data[e])}cyclicIndex(t){return t%this.length}}},"./lib/geometry3d/Point3dVector3d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Angle.js"),s=r("./lib/geometry3d/Ray3d.js");class XYZ{constructor(t=0,e=0,r=0){this.x=t,this.y=e,this.z=r}set(t=0,e=0,r=0){this.x=t,this.y=e,this.z=r}setZero(){this.x=0,this.y=0,this.z=0}static isXAndY(t){return void 0!==t.x&&void 0!==t.y}static hasZ(t){return void 0!==t.z}static isXYAndZ(t){return this.isXAndY(t)&&this.hasZ(t)}static isAnyImmediatePointType(t){return Point3d.isXAndY(t)||i.Geometry.isNumberArray(t,2)}static accessX(t,e){return void 0!==t.x?t.x:Array.isArray(t)&&t.length>0&&Number.isFinite(t[0])?t[0]:e}static accessY(t,e){return void 0!==t.y?t.y:Array.isArray(t)&&t.length>1&&Number.isFinite(t[1])?t[1]:e}static accessZ(t,e){return void 0!==t.z?t.z:Array.isArray(t)&&t.length>2&&Number.isFinite(t[2])?t[2]:e}setFrom(t){void 0===t?this.setZero():XYZ.isXAndY(t)?(this.x=t.x,this.y=t.y,this.z=XYZ.hasZ(t)?t.z:0):(this.x=t[0],this.y=t[1],this.z=t[2])}setFromPoint3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}setFromVector3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}isAlmostEqual(t,e){return i.Geometry.isSameCoordinate(this.x,t.x,e)&&i.Geometry.isSameCoordinate(this.y,t.y,e)&&i.Geometry.isSameCoordinate(this.z,t.z,e)}isAlmostEqualXYZ(t,e,r,n){return i.Geometry.isSameCoordinate(this.x,t,n)&&i.Geometry.isSameCoordinate(this.y,e,n)&&i.Geometry.isSameCoordinate(this.z,r,n)}isAlmostEqualXY(t,e){return i.Geometry.isSameCoordinate(this.x,t.x,e)&&i.Geometry.isSameCoordinate(this.y,t.y,e)}toJSON(){return[this.x,this.y,this.z]}toJSONXYZ(){return{x:this.x,y:this.y,z:this.z}}toFloat64Array(){return Float64Array.of(this.x,this.y,this.z)}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0,t[2]||0):t?this.set(t.x||0,t.y||0,t.z||0):this.set(0,0,0)}distance(t){const e=t.x-this.x,r=t.y-this.y,i=t.z-this.z;return Math.sqrt(e*e+r*r+i*i)}distanceSquared(t){const e=t.x-this.x,r=t.y-this.y,i=t.z-this.z;return e*e+r*r+i*i}distanceXY(t){const e=t.x-this.x,r=t.y-this.y;return Math.sqrt(e*e+r*r)}distanceSquaredXY(t){const e=t.x-this.x,r=t.y-this.y;return e*e+r*r}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y),Math.abs(this.z-t.z))}at(t){return t<.5?this.x:t>1.5?this.z:this.y}indexOfMaxAbs(){let t=0,e=Math.abs(this.x),r=Math.abs(this.y);return r>e&&(t=1,e=r),(r=Math.abs(this.z))>e&&(t=2,e=r),t}get isAlmostZero(){return i.Geometry.isSmallMetricDistance(this.x)&&i.Geometry.isSmallMetricDistance(this.y)&&i.Geometry.isSmallMetricDistance(this.z)}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}magnitudeSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}magnitudeXY(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquaredXY(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}isAlmostEqualMetric(t){return this.maxDiff(t)<=i.Geometry.smallMetricDistance}addInPlace(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}subtractInPlace(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}addScaledInPlace(t,e){this.x+=e*t.x,this.y+=e*t.y,this.z+=e*t.z}scaleInPlace(t){this.x*=t,this.y*=t,this.z*=t}addXYZInPlace(t=0,e=0,r=0){this.x+=t,this.y+=e,this.z+=r}cloneAsPoint3d(){return Point3d.create(this.x,this.y,this.z)}vectorTo(t,e){return Vector3d.create(t.x-this.x,t.y-this.y,t.z-this.z,e)}scaledVectorTo(t,e,r){return Vector3d.create(e*(t.x-this.x),e*(t.y-this.y),e*(t.z-this.z),r)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}freeze(){Object.freeze(this)}}e.XYZ=XYZ;class Point3d extends XYZ{constructor(t=0,e=0,r=0){super(t,e,r)}static fromJSON(t){const e=new Point3d;return e.setFromJSON(t),e}clone(t){return Point3d.create(this.x,this.y,this.z,t)}static create(t=0,e=0,r=0,i){return i?(i.x=t,i.y=e,i.z=r,i):new Point3d(t,e,r)}static createFrom(t,e){if(t instanceof Float64Array){let r=0,i=0,n=0;return t.length>0&&(r=t[0]),t.length>1&&(i=t[1]),t.length>2&&(n=t[2]),Point3d.create(r,i,n,e)}return Point3d.create(t.x,t.y,XYZ.hasZ(t)?t.z:0,e)}static createFromPacked(t,e,r){const i=3*e;if(i>=0&&i+2<t.length)return Point3d.create(t[i],t[i+1],t[i+2],r)}static createFromPackedXYZW(t,e,r){const n=4*e;if(n>=0&&n+3<t.length){const e=t[n+3];if(!i.Geometry.isSmallMetricDistance(e)){const i=1/e;return Point3d.create(i*t[n],i*t[n+1],i*t[n+2],r)}}}static createZero(t){return Point3d.create(0,0,0,t)}crossProductToPoints(t,e,r){return Vector3d.createCrossProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,r)}crossProductToPointsMagnitude(t,e){return i.Geometry.crossProductMagnitude(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z)}tripleProductToPoints(t,e,r){return i.Geometry.tripleProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,r.x-this.x,r.y-this.y,r.z-this.z)}crossProductToPointsXY(t,e){return i.Geometry.crossProductXYXY(t.x-this.x,t.y-this.y,e.x-this.x,e.y-this.y)}interpolate(t,e,r){if(t<=.5)return Point3d.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),this.z+t*(e.z-this.z),r);const i=t-1;return Point3d.create(e.x+i*(e.x-this.x),e.y+i*(e.y-this.y),e.z+i*(e.z-this.z),r)}interpolatePointAndTangent(t,e,r,i){i=i||s.Ray3d.createZero();const n=e.x-this.x,o=e.y-this.y,a=e.z-this.z;if(i.direction.set(r*n,r*o,r*a),t<=.5)i.origin.set(this.x+t*n,this.y+t*o,this.z+t*a);else{const r=t-1;i.origin.set(e.x+r*n,e.y+r*o,e.z+r*a)}return i}interpolateXYZ(t,e,r,n,s){return Point3d.create(i.Geometry.interpolate(this.x,t,n.x),i.Geometry.interpolate(this.y,e,n.y),i.Geometry.interpolate(this.z,r,n.z),s)}interpolatePerpendicularXY(t,e,r,i){i=i||new Point3d;const n=e.minus(this);return this.interpolate(t,e,i),i.x-=r*n.y,i.y+=r*n.x,i}minus(t,e){return Point3d.create(this.x-t.x,this.y-t.y,this.z-t.z,e)}plus(t,e){return Point3d.create(this.x+t.x,this.y+t.y,this.z+t.z,e)}plusXYZ(t=0,e=0,r=0,i){return Point3d.create(this.x+t,this.y+e,this.z+r,i)}plusScaled(t,e,r){return Point3d.create(this.x+t.x*e,this.y+t.y*e,this.z+t.z*e,r)}plus2Scaled(t,e,r,i,n){return Point3d.create(this.x+t.x*e+r.x*i,this.y+t.y*e+r.y*i,this.z+t.z*e+r.z*i,n)}plus3Scaled(t,e,r,i,n,s,o){return Point3d.create(this.x+t.x*e+r.x*i+n.x*s,this.y+t.y*e+r.y*i+n.y*s,this.z+t.z*e+r.z*i+n.z*s,o)}static createScale(t,e,r){return Point3d.create(t.x*e,t.y*e,t.z*e,r)}static createAdd2Scaled(t,e,r,i,n){return Point3d.create(t.x*e+r.x*i,t.y*e+r.y*i,t.z*e+r.z*i,n)}static createAdd3Scaled(t,e,r,i,n,s,o){return Point3d.create(t.x*e+r.x*i+n.x*s,t.y*e+r.y*i+n.y*s,t.z*e+r.z*i+n.z*s,o)}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)+(t.z-this.z)*(e.z-this.z)}fractionOfProjectionToLine(t,e,r=0){const n=t.distanceSquared(e);return n<i.Geometry.smallMetricDistanceSquared?r:t.dotVectorsToTargets(e,this)/n}}e.Point3d=Point3d;class Vector3d extends XYZ{constructor(t=0,e=0,r=0){super(t,e,r)}clone(t){return Vector3d.create(this.x,this.y,this.z,t)}static create(t=0,e=0,r=0,i){return i?(i.x=t,i.y=e,i.z=r,i):new Vector3d(t,e,r)}static createCrossProduct(t,e,r,i,n,s,o){return Vector3d.create(e*s-r*n,r*i-t*s,t*n-e*i,o)}addCrossProductToTargetsInPlace(t,e,r,i,n,s,o,a,c){const l=i-t,d=n-e,h=s-r,u=o-t,f=a-e,g=c-r;this.x+=d*g-h*f,this.y+=h*u-l*g,this.z+=l*f-d*u}static createCrossProductToPoints(t,e,r,i){return Vector3d.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,r.x-t.x,r.y-t.y,r.z-t.z,i)}static createPolar(t,e,r){return Vector3d.create(t*e.cos(),t*e.sin(),r)}static createSpherical(t,e,r){const i=r.cos();return Vector3d.create(i*t*e.cos(),i*t*e.sin(),r.sin())}static fromJSON(t){const e=new Vector3d;return e.setFromJSON(t),e}static createFrom(t,e){if(t instanceof Float64Array){let r=0,i=0,n=0;return t.length>0&&(r=t[0]),t.length>1&&(i=t[1]),t.length>2&&(n=t[2]),Vector3d.create(r,i,n,e)}return Vector3d.create(t.x,t.y,XYZ.hasZ(t)?t.z:0,e)}static createStartEnd(t,e,r){return r?(r.set(e.x-t.x,e.y-t.y,e.z-t.z),r):new Vector3d(e.x-t.x,e.y-t.y,e.z-t.z)}static createStartEndXYZXYZ(t,e,r,i,n,s,o){return this.create(i-t,n-e,s-r,o)}static createRotateVectorAroundVector(t,e,r){const i=e.normalize();if(i){const e=i.crossProduct(t);let n,s;return r?(n=r.cos(),s=r.sin()):(n=0,s=1),Vector3d.createAdd3Scaled(t,n,e,s,i,i.dotProduct(t)*(1-n))}}setStartEnd(t,e){this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z}static createZero(t){return Vector3d.create(0,0,0,t)}static unitX(t=1){return new Vector3d(t,0,0)}static unitY(t=1){return new Vector3d(0,t,0)}static unitZ(t=1){return new Vector3d(0,0,t)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalizeWithLength(t){const e=i.Geometry.correctSmallMetricDistance(this.magnitude());return t=t||new Vector3d,{v:this.safeDivideOrNull(e,t),mag:e}}normalize(t){return this.normalizeWithLength(t).v}normalizeInPlace(){const t=i.Geometry.inverseMetricDistance(this.magnitude());return!!t&&(this.x*=t,this.y*=t,this.z*=t,!0)}fractionOfProjectionToVector(t,e=0){const r=this.dotProduct(t),n=t.magnitudeSquared();return n<i.Geometry.smallMetricDistanceSquared?e:r/n}negate(t){return(t=t||new Vector3d).x=-this.x,t.y=-this.y,t.z=-this.z,t}rotate90CCWXY(t){t=t||new Vector3d;const e=this.x,r=this.y;return t.x=-r,t.y=e,t.z=this.z,t}unitPerpendicularXY(t){t=t||new Vector3d;const e=this.x,r=this.y;t.x=-r,t.y=e,t.z=0;const i=e*e+r*r;if(0!==i){const e=1/Math.sqrt(i);t.x*=e,t.y*=e}return t}rotateXY(t,e){const r=t.sin(),i=t.cos(),n=this.x,s=this.y;return(e=e||new Vector3d).x=n*i-s*r,e.y=n*r+s*i,e.z=this.z,e}rotate90Towards(t,e){const r=this.crossProduct(t).normalize();return r?r.crossProduct(this,e):void 0}rotate90Around(t,e){const r=t.normalize();return r?r.crossProduct(this).plusScaled(r,r.dotProduct(this),e):void 0}interpolate(t,e,r){if(r=r||new Vector3d,t<=.5)r.x=this.x+t*(e.x-this.x),r.y=this.y+t*(e.y-this.y),r.z=this.z+t*(e.z-this.z);else{const i=t-1;r.x=e.x+i*(e.x-this.x),r.y=e.y+i*(e.y-this.y),r.z=e.z+i*(e.z-this.z)}return r}plus(t,e){return(e=e||new Vector3d).x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e}minus(t,e){return(e=e||new Vector3d).x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e}plusScaled(t,e,r){return(r=r||new Vector3d).x=this.x+t.x*e,r.y=this.y+t.y*e,r.z=this.z+t.z*e,r}plus2Scaled(t,e,r,i,n){return(n=n||new Vector3d).x=this.x+t.x*e+r.x*i,n.y=this.y+t.y*e+r.y*i,n.z=this.z+t.z*e+r.z*i,n}plus3Scaled(t,e,r,i,n,s,o){return(o=o||new Vector3d).x=this.x+t.x*e+r.x*i+n.x*s,o.y=this.y+t.y*e+r.y*i+n.y*s,o.z=this.z+t.z*e+r.z*i+n.z*s,o}static createAdd2Scaled(t,e,r,i,n){return Vector3d.create(t.x*e+r.x*i,t.y*e+r.y*i,t.z*e+r.z*i,n)}static createAdd2ScaledXYZ(t,e,r,i,n,s,o,a,c){return Vector3d.create(t*i+n*a,e*i+s*a,r*i+o*a,c)}static createAdd3Scaled(t,e,r,i,n,s,o){return Vector3d.create(t.x*e+r.x*i+n.x*s,t.y*e+r.y*i+n.y*s,t.z*e+r.z*i+n.z*s,o)}scale(t,e){return(e=e||new Vector3d).x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}scaleToLength(t,e){const r=i.Geometry.correctSmallMetricDistance(this.magnitude());if(0!==r)return this.scale(t/r,e)}unitCrossProduct(t,e){return this.crossProduct(t,e).normalize(e)}unitCrossProductWithDefault(t,e,r,i,n){const s=this.crossProduct(t,n).normalize(n);return void 0===s?Vector3d.create(e,r,i,n):s}normalizeWithDefault(t,e,r,i){const n=this.normalize(i);return n||((i=Vector3d.create(t,e,r,i)).normalizeInPlace()?i:Vector3d.create(1,0,0,i))}tryNormalizeInPlace(t=i.Geometry.smallMetricDistance){const e=this.magnitude();return!(e<t||0===e)&&(this.scaleInPlace(1/e),!0)}sizedCrossProduct(t,e,r){if((r=this.crossProduct(t,r)).tryNormalizeInPlace())return r.scaleInPlace(e),r}crossProductMagnitudeSquared(t){const e=this.y*t.z-this.z*t.y,r=this.z*t.x-this.x*t.z,i=this.x*t.y-this.y*t.x;return e*e+r*r+i*i}crossProductMagnitude(t){return Math.sqrt(this.crossProductMagnitudeSquared(t))}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)+this.z*(e.z-t.z)}dotProductStart3dEnd4d(t,e){const r=e.w;return this.x*(e.x-t.x*r)+this.y*(e.y-t.y*r)+this.z*(e.z-t.z*r)}crossProductStartEnd(t,e,r){return Vector3d.createCrossProduct(this.x,this.y,this.z,e.x-t.x,e.y-t.y,e.z-t.z,r)}crossProductStartEndXY(t,e){return i.Geometry.crossProductXYXY(this.x,this.y,e.x-t.x,e.y-t.y)}dotProductStartEndXYZ(t,e,r,i){return this.x*(e-t.x)+this.y*(r-t.y)+this.z*(i-t.z)}dotProductStartEndXYZW(t,e,r,n,s){if(i.Geometry.isSmallMetricDistance(s))return 0;const o=1/s;return this.x*(o*e-t.x)+this.y*(o*r-t.y)+this.z*(o*n-t.z)}dotProductXY(t){return this.x*t.x+this.y*t.y}dotProductXYZ(t,e,r=0){return this.x*t+this.y*e+this.z*r}tripleProduct(t,e){return i.Geometry.tripleProduct(this.x,this.y,this.z,t.x,t.y,t.z,e.x,e.y,e.z)}crossProductXY(t){return this.x*t.y-this.y*t.x}crossProduct(t,e){return Vector3d.createCrossProduct(this.x,this.y,this.z,t.x,t.y,t.z,e)}crossProductXYZ(t,e,r,i){return Vector3d.createCrossProduct(this.x,this.y,this.z,t,e,r,i)}angleTo(t){return n.Angle.createAtan2(this.crossProductMagnitude(t),this.dotProduct(t))}angleFromPerpendicular(t){return n.Angle.createAtan2(this.dotProduct(t),this.crossProductMagnitude(t))}angleToXY(t){return n.Angle.createAtan2(this.crossProductXY(t),this.dotProductXY(t))}planarRadiansTo(t,e){const r=e.dotProduct(e);if(0===r)return 0;const i=1/r,n=this.plusScaled(e,-this.dotProduct(e)*i),s=t.plusScaled(e,-t.dotProduct(e)*i);return n.signedRadiansTo(s,e)}planarAngleTo(t,e){return n.Angle.createRadians(this.planarRadiansTo(t,e))}signedRadiansTo(t,e){const r=this.crossProduct(t),i=Math.atan2(r.magnitude(),this.dotProduct(t));return e.dotProduct(r)<0?-i:i}signedAngleTo(t,e){return n.Angle.createRadians(this.signedRadiansTo(t,e))}smallerUnorientedAngleTo(t){return n.Angle.createRadians(this.smallerUnorientedRadiansTo(t))}smallerUnorientedRadiansTo(t){const e=this.dotProduct(t),r=this.crossProductMagnitude(t);return Math.atan2(Math.abs(r),Math.abs(e))}isParallelTo(t,e=!1,r=!1){const n=this.magnitudeSquared(),s=t.magnitudeSquared();return n<i.Geometry.smallMetricDistanceSquared||s<i.Geometry.smallMetricDistanceSquared?r:this.dotProduct(t)<0&&!e?r:this.crossProductMagnitudeSquared(t)<=i.Geometry.smallAngleRadiansSquared*n*s}isPerpendicularTo(t,e=!1){const r=this.magnitudeSquared();if(r<i.Geometry.smallMetricDistanceSquared)return e;const n=t.magnitudeSquared();if(n<i.Geometry.smallMetricDistanceSquared)return e;const s=this.dotProduct(t);return s*s<=i.Geometry.smallAngleRadiansSquared*r*n}}e.Vector3d=Vector3d},"./lib/geometry3d/PointHelpers.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point2dVector2d.js"),s=r("./lib/geometry3d/Point3dVector3d.js"),o=r("./lib/geometry3d/Transform.js"),a=r("./lib/geometry4d/Point4d.js"),c=r("./lib/geometry3d/IndexedXYZCollection.js"),l=r("./lib/geometry3d/PointStreaming.js"),d=r("./lib/geometry3d/Range.js");e.NumberArray=class NumberArray{static preciseSum(t){const e=t.length;if(0===e)return 0;let r,i,n=t[0],s=0;for(let o=1;o<e;o++)s=(i=n+(r=t[o]-s))-n-r,n=i;return n}static isExactEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}return void 0===t&&void 0===e}static isAlmostEqual(t,e,r){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(Math.abs(t[i]-e[i])>=r)return!1;return!0}return void 0===t&&void 0===e}static sum(t){let e=0;for(const r of t)e+=r;return e}static isCoordinateInArray(t,e){if(e)for(const r of e)if(i.Geometry.isSameCoordinate(t,r))return!0;return!1}static maxAbsArray(t){const e=t.length;if(0===e)return 0;let r=Math.abs(t[0]);for(let i=1;i<e;i++){const e=Math.abs(t[i]);r<e&&(r=e)}return r}static maxAbsTwo(t,e){return(t=Math.abs(t))>(e=Math.abs(e))?t:e}static maxAbsDiff(t,e){let r=0;const i=Math.min(t.length,e.length);for(let n=0;n<i;n++)r=Math.max(r,Math.abs(t[n]-e[n]));return r}static maxAbsDiffFloat64(t,e){let r=0;const i=Math.min(t.length,e.length);for(let n=0;n<i;n++)r=Math.max(r,Math.abs(t[n]-e[n]));return r}};e.Point2dArray=class Point2dArray{static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(!t[r].isAlmostEqual(e[r]))return!1;return!0}return void 0===t&&void 0===e}static clonePoint2dArray(t){return t.map(t=>t.clone())}static pointCountExcludingTrailingWraparound(t){let e=t.length;if(e<2)return e;const r=t[0].x,n=t[0].y;for(;e>1;){if(!i.Geometry.isSameCoordinate(t[e-1].x,r)||!i.Geometry.isSameCoordinate(t[e-1].y,n))return e;e--}return e}};e.Vector3dArray=class Vector3dArray{static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(!t[r].isAlmostEqual(e[r]))return!1;return!0}return void 0===t&&void 0===e}static cloneVector3dArray(t){return t.map(t=>s.Vector3d.create(t.x,t.y,t.z))}};class Point4dArray{static packPointsAndWeightsToFloat64Array(t,e,r){r=r||new Float64Array(4*t.length);let i=0,n=0;for(n=0;n<t.length;n++)r[i++]=t[n].x,r[i++]=t[n].y,r[i++]=t[n].z,r[i++]=e[n];return r}static packToFloat64Array(t,e){e=e||new Float64Array(4*t.length);let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=i.z,e[r++]=i.w;return e}static unpackToPoint4dArray(t){const e=[];for(let r=0;r+3<t.length;r+=4)e.push(a.Point4d.create(t[r],t[r+1],t[r+2],t[r+3]));return e}static unpackFloat64ArrayToPointsAndWeights(t,e,r,i=s.Point3d.create){e.length=0,r.length=0;for(let n=0;n+3<t.length;n+=4)e.push(i(t[n],t[n+1],t[n+2])),r.push(t[n+3])}static multiplyInPlace(t,e){const r=e.length,i=Point4dArray._workPoint4d;for(let n=0;n+3<r;n+=4)t.multiplyXYZW(e[n],e[n+1],e[n+2],e[n+3],i),e[n]=i.x,e[n+1]=i.y,e[n+2]=i.z,e[n+3]=i.w}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;if(t instanceof Float64Array&&e instanceof Float64Array){for(let r=0;r<t.length;r++)if(!i.Geometry.isSameCoordinate(t[r],e[r]))return!1}else if(Array.isArray(t)&&Array.isArray(e))for(let r=0;r<t.length;r++)if(!t[r].isAlmostEqual(e[r]))return!1;return!0}return void 0===t&&void 0===e}static isCloseToPlane(t,e,r=i.Geometry.smallMetricDistance){if(Array.isArray(t)){for(const i of t)if(Math.abs(e.altitudeXYZW(i.x,i.y,i.z,i.w))>r)return!1}else if(t instanceof Float64Array){const i=t.length;for(let n=0;n+2<i;n+=4)if(Math.abs(e.altitudeXYZW(t[n],t[n+1],t[n+2],t[n+3]))>r)return!1}return!0}}e.Point4dArray=Point4dArray,Point4dArray._workPoint4d=a.Point4d.create();class Point3dArray{static packToFloat64Array(t){const e=new Float64Array(3*t.length);let r=0;for(const i of t)e[r++]=i.x,e[r++]=i.y,e[r++]=i.z;return e}static evaluateTrilinearWeights(t,e,r,i,n,s,o){t[0]=e*i*s,t[1]=r*i*s,t[2]=e*n*s,t[3]=r*n*s,t[4]=e*i*o,t[5]=r*i*o,t[6]=e*n*o,t[7]=r*n*o}static sumWeightedX(t,e){let r=0;const i=t.length;for(let n=0;n<i;n++)r+=t[n]*e[n].x;return r}static sumWeightedY(t,e){let r=0;const i=t.length;for(let n=0;n<i;n++)r+=t[n]*e[n].y;return r}static sumWeightedZ(t,e){let r=0;const i=t.length;for(let n=0;n<i;n++)r+=t[n]*e[n].z;return r}static evaluateTrilinearPoint(t,e,r,i,n){let o;n||(n=s.Point3d.create(0,0,0)),this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-r,r,1-i,i);for(let s=0;s<8;s++)o=this._weightUVW[s],n.x+=o*t[s].x,n.y+=o*t[s].y,n.z+=o*t[s].z;return n}static evaluateTrilinearDerivativeTransform(t,e,r,i,n){return this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-r,r,1-i,i),this.evaluateTrilinearWeights(this._weightDU,-1,1,1-r,r,1-i,i),this.evaluateTrilinearWeights(this._weightDV,1-e,e,-1,1,1-i,i),this.evaluateTrilinearWeights(this._weightDW,1-e,e,1-r,r,-1,1),o.Transform.createRowValues(this.sumWeightedX(this._weightDU,t),this.sumWeightedX(this._weightDV,t),this.sumWeightedX(this._weightDW,t),this.sumWeightedX(this._weightUVW,t),this.sumWeightedY(this._weightDU,t),this.sumWeightedY(this._weightDV,t),this.sumWeightedY(this._weightDW,t),this.sumWeightedY(this._weightUVW,t),this.sumWeightedZ(this._weightDU,t),this.sumWeightedZ(this._weightDV,t),this.sumWeightedZ(this._weightDW,t),this.sumWeightedZ(this._weightUVW,t),n)}static unpackNumbersToPoint3dArray(t){const e=[];for(let r=0;r+2<t.length;r+=3)e.push(s.Point3d.create(t[r],t[r+1],t[r+2]));return e}static unpackNumbersToNestedArrays(t,e){const r=[],i=t.length;let n=0,s=0;for(;n<i;){const o=[];for((s=n+e)>i&&(s=i);n<s;n++)o.push(t[n]);r.push(o)}return r}static unpackNumbersToNestedArraysIJK(t,e,r){const i=[],n=t.length;let s,o=0,a=0;for(;o<n;){const c=[];for(s=o+e*r;o<s;){const r=[];for((a=o+e)>n&&(a=n);o<a;o++)r.push(t[o]);c.push(r)}i.push(c)}return i}static multiplyInPlace(t,e){const r=s.Point3d.create(),i=e.length;for(let n=0;n+2<i;n+=3)t.multiplyXYZ(e[n],e[n+1],e[n+2],r),e[n]=r.x,e[n+1]=r.y,e[n+2]=r.z}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;if(t instanceof Float64Array&&e instanceof Float64Array){for(let r=0;r<t.length;r++)if(!i.Geometry.isSameCoordinate(t[r],e[r]))return!1}else if(Array.isArray(t)&&Array.isArray(e))for(let r=0;r<t.length;r++)if(!t[r].isAlmostEqual(e[r]))return!1;return!0}return void 0===t&&void 0===e}static centroid(t,e){e=s.Point3d.create(0,0,0,e);const r=s.Point3d.create();if(t.length>0){for(let i=0;i<t.length;i++)t.getPoint3dAtCheckedPointIndex(i,r),e.x+=r.x,e.y+=r.y,e.z+=r.z;e.scaleInPlace(1/t.length)}return e}static indexOfMostDistantPoint(t,e,r){if(0===t.length)return;let i,n=-1,s=-1;for(let o=0;o<t.length;o++)(i=e.distance(t[o]))>n&&(e.vectorTo(t[o],r),n=i,s=o);return s}static indexOfPointWithMaxCrossProductMagnitude(t,e,r,i){if(0===t.length)return;let n,s,o=-1,a=-1;for(let c=0;c<t.length;c++)(n=(s=e.vectorTo(t[c],s)).crossProductMagnitude(r))>o&&(i.setFrom(s),o=n,a=c);return a}static closestPointIndex(t,e){let r,n=-1,s=Number.MAX_VALUE;const o=e.x,a=e.y,c=e.z;for(let l=0;l<t.length;l++)(r=i.Geometry.distanceXYZXYZ(o,a,c,t[l].x,t[l].y,t[l].z))<s&&(n=l,s=r);return n}static isCloseToPlane(t,e,r=i.Geometry.smallMetricDistance){if(Array.isArray(t)){let i;for(i of t)if(Math.abs(e.altitude(i))>r)return!1}else if(t instanceof Float64Array){const i=t.length;for(let n=0;n+2<i;n+=3)if(Math.abs(e.altitudeXYZ(t[n],t[n+1],t[n+2]))>r)return!1}return!0}static sumEdgeLengths(t,e=!1){let r=0;if(Array.isArray(t)){const i=t.length-1;for(let e=0;e<i;e++)r+=t[e].distance(t[e+1]);e&&i>0&&(r+=t[0].distance(t[i]))}else if(t instanceof Float64Array){const n=t.length;let s=0;for(;s+5<n;s+=3)r+=i.Geometry.hypotenuseXYZ(t[s+3]-t[s],t[s+4]-t[s+1],t[s+5]-t[s+2]);e&&s>=3&&(r+=i.Geometry.hypotenuseXYZ(t[0]-t[s],t[1]-t[s+1],t[2]-t[s+2]))}return r}static clonePoint3dArray(t){return t.map(t=>s.Point3d.create(t.x,t.y,t.z))}static clonePoint2dArray(t){return t.map(t=>n.Point2d.create(t.x,t.y))}static cloneWithMaxEdgeLength(t,e){if(0===t.length)return[];const r=[t[0]];for(let n=1;n<t.length;n++){const s=t[n-1].distance(t[n]),o=i.Geometry.stepCount(e,s,1);for(let e=1;e<o;e++)r.push(t[n-1].interpolate(e/o,t[n]));r.push(t[n])}return r}static xyzToArray(t,e,r){return[t,e,r]}static cloneDeepJSONNumberArrays(t){const e=new l.PointStringDeepXYZArrayCollector(this.xyzToArray);return l.VariantPointDataStream.streamXYZ(t,e),e.claimResult()}static cloneDeepXYZPoint3dArrays(t){const e=new l.PointStringDeepXYZArrayCollector(s.Point3d.create);return l.VariantPointDataStream.streamXYZ(t,e),e.claimResult()}static createRange(t){return d.Range3d.createFromVariantData(t)}static streamXYZ(t,e,r,i){let n=0;if(Array.isArray(t))if(t.length>0&&s.Point3d.isAnyImmediatePointType(t[0])){e&&e(t,!0);for(const e of t){const t=s.Point3d.accessX(e),i=s.Point3d.accessY(e),o=s.Point3d.accessZ(e,0);void 0!==t&&void 0!==i&&r(t,i,o),n++}i&&i(t,!0)}else{e&&e(t,!1);for(const s of t)n+=this.streamXYZ(s,e,r,i);i&&i(t,!1)}else if(t instanceof c.IndexedXYZCollection){e&&e(t,!0);const o=Point3dArray._workPoint=s.Point3d.create(0,0,0,Point3dArray._workPoint);for(let e=0;e<t.length;e++)t.getPoint3dAtCheckedPointIndex(e,o),n++,r(o.x,o.y,o.z);i&&i(t,!0)}return n}static streamXYZXYZ(t,e,r,i){let n,o,a,l=0,d=0,h=0,u=!1,f=0;if(Array.isArray(t))if(t.length>0&&s.Point3d.isAnyImmediatePointType(t[0])){e&&e(t,!0);for(const e of t)n=s.Point3d.accessX(e),o=s.Point3d.accessY(e),a=s.Point3d.accessZ(e,0),void 0!==n&&void 0!==o&&(u&&(r(l,d,h,n,o,a),f++),u=!0,l=n,d=o,h=a);i&&i(t,!0)}else{e&&e(t,!1);for(const n of t)f+=this.streamXYZXYZ(n,e,r,i);i&&i(t,!1)}else if(t instanceof c.IndexedXYZCollection){e&&e(t,!0);const n=Point3dArray._workPoint=s.Point3d.create(0,0,0,Point3dArray._workPoint);for(let e=0;e<t.length;e++)t.getPoint3dAtCheckedPointIndex(e,n),e>0&&(f++,r(l,d,h,n.x,n.y,n.z)),l=n.x,d=n.y,h=n.z;i&&i(t,!0)}return f}static computeConvexHullXY(t,e,r,n=!1){e.length=0,r.length=0;let s=t.length;const o=t.slice(0,s);if(o.sort(i.Geometry.lexicalXYLessThan),s<3){for(const t of o)e.push(t);return void(n&&o.length>0&&e.push(o[0]))}e.push(o[0]),e.push(o[1]);let a=0;for(let i=2;i<s;i++){const t=o[i];let r=e.length-1;for(;r>=1&&e[r-1].crossProductToPointsXY(e[r],t)<=0;)o[a++]=e[r],r--,e.pop();e.push(t)}const c=e.length-1;o.length=a,o.push(e[0]),o.sort(i.Geometry.lexicalXYLessThan),s=o.length,e.push(o[s-1]);for(let i=s-1;i-- >0;){const t=o[i];let n=e.length-1;for(;n>c&&e[n-1].crossProductToPointsXY(e[n],t)<=0;)r.push(e[n]),n--,e.pop();i>0&&e.push(t)}n&&e.push(e[0])}static minMaxPoints(t){if(0===t.length)return;const e={minXPoint:t[0].clone(),maxXPoint:t[0].clone(),minYPoint:t[0].clone(),maxYPoint:t[0].clone()};let r;for(let i=1;i<t.length;i++)(r=t[i]).x<e.minXPoint.x&&e.minXPoint.setFromPoint3d(r),r.x>e.maxXPoint.x&&e.maxXPoint.setFromPoint3d(r),r.y<e.minYPoint.y&&e.minYPoint.setFromPoint3d(r),r.y>e.maxYPoint.y&&e.maxYPoint.setFromPoint3d(r);return e}}e.Point3dArray=Point3dArray,Point3dArray._weightUVW=new Float64Array(8),Point3dArray._weightDU=new Float64Array(8),Point3dArray._weightDV=new Float64Array(8),Point3dArray._weightDW=new Float64Array(8)},"./lib/geometry3d/PointStreaming.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/IndexedXYZCollection.js"),s=r("./lib/geometry3d/Range.js"),o=r("./lib/geometry3d/GrowableXYZArray.js");class PointStreamXYZHandlerBase{startChain(t,e){}handleXYZ(t,e,r){}endChain(t,e){}}e.PointStreamXYZHandlerBase=PointStreamXYZHandlerBase;e.PointStreamXYZXYZHandlerBase=class PointStreamXYZXYZHandlerBase extends PointStreamXYZHandlerBase{handleXYZ(t,e,r){void 0!==this._x0&&this.handleXYZXYZ(this._x0,this._y0,this._z0,t,e,r),this._x0=t,this._y0=e,this._z0=r}startChain(t,e){this._x0=this._y0=this._z0=void 0}handleXYZXYZ(t,e,r,i,n,s){}};e.PointStreamGrowableXYZArrayCollector=class PointStreamGrowableXYZArrayCollector extends PointStreamXYZHandlerBase{startChain(t,e){this._currentData=void 0}handleXYZ(t,e,r){this._currentData||(this._currentData=new o.GrowableXYZArray),this._currentData.pushXYZ(t,e,r)}endChain(t,e){void 0!==this._currentData&&(void 0===this._pointArrays&&(this._pointArrays=[]),this._pointArrays.push(this._currentData),this._currentData=void 0)}claimArrayOfGrowableXYZArray(){const t=this._pointArrays;return this._pointArrays=void 0,t}};e.PointStreamRangeCollector=class PointStreamRangeCollector extends PointStreamXYZHandlerBase{constructor(){super(...arguments),this._range=s.Range3d.createNull()}handleXYZ(t,e,r){this._range||(this._range=s.Range3d.createNull()),this._range.extendXYZ(t,e,r)}claimResult(){const t=this._range;return this._range=void 0,t||s.Range3d.createNull()}};e.PointStringDeepXYZArrayCollector=class PointStringDeepXYZArrayCollector{constructor(t){this._xyzFunction=t,this._resultStack=[],this._resultStack.push([])}startChain(t,e){this._resultStack.push([])}handleXYZ(t,e,r){this._resultStack[this._resultStack.length-1].push(this._xyzFunction(t,e,r))}endChain(t,e){const r=this._resultStack[this._resultStack.length-1];this._resultStack.pop(),this._resultStack[this._resultStack.length-1].push(r)}claimResult(){const t=this._resultStack[0];return 1===t.length?t[0]:t}};class VariantPointDataStream{static streamXYZ(t,e){let r=0;if(Array.isArray(t))if(t.length>0&&i.Point3d.isAnyImmediatePointType(t[0])){e.startChain(t,!0);for(const n of t){const t=i.Point3d.accessX(n),s=i.Point3d.accessY(n),o=i.Point3d.accessZ(n,0);void 0!==t&&void 0!==s&&e.handleXYZ(t,s,o),r++}e.endChain(t,!0)}else{e.startChain(t,!1);for(const i of t)r+=this.streamXYZ(i,e);e.endChain(t,!1)}else if(t instanceof n.IndexedXYZCollection){e.startChain(t,!0);const n=VariantPointDataStream._workPoint=i.Point3d.create(0,0,0,VariantPointDataStream._workPoint);for(let i=0;i<t.length;i++)t.getPoint3dAtCheckedPointIndex(i,n),r++,e.handleXYZ(n.x,n.y,n.z);e.endChain(t,!0)}return r}}e.VariantPointDataStream=VariantPointDataStream},"./lib/geometry3d/PolygonOps.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point2dVector2d.js"),s=r("./lib/geometry3d/Point3dVector3d.js"),o=r("./lib/geometry4d/Matrix4d.js"),a=r("./lib/geometry3d/Ray3d.js"),c=r("./lib/geometry3d/IndexedXYZCollection.js"),l=r("./lib/geometry3d/Point3dArrayCarrier.js"),d=r("./lib/topology/XYParitySearchContext.js"),h=r("./lib/geometry3d/GrowableXYZArray.js"),u=r("./lib/geometry3d/Range.js"),f=r("./lib/geometry4d/Point4d.js");class PolygonOps{static sumTriangleAreas(t){let e=0;const r=t.length;if(Array.isArray(t)){if(r>=3){const i=t[0],n=i.vectorTo(t[1]);let o=s.Vector3d.create();for(let s=2;s<r;s++)o=i.vectorTo(t[s],o),e+=n.crossProductMagnitude(o),n.setFrom(o)}return.5*e}const i=s.Vector3d.create();for(let n=2;n<r;n++)t.crossProductIndexIndexIndex(0,n-1,n,i),e+=i.magnitude();return.5*e}static sumTriangleAreasXY(t){let e=0;const r=t.length;if(r>=3){const i=t[0],n=i.vectorTo(t[1]);let o=s.Vector3d.create();for(let s=2;s<r;s++)o=i.vectorTo(t[s],o),e+=n.crossProductXY(o),n.setFrom(o)}return e*=.5}static areaNormalGo(t,e){e||(e=new s.Vector3d);const r=t.length;if(3===r)t.crossProductIndexIndexIndex(0,1,2,e);else if(r>=3){e.setZero();for(let i=2;i<r;i++)t.accumulateCrossProductIndexIndexIndex(0,i-1,i,e)}return e.scaleInPlace(.5),e}static areaNormal(t,e){return e||(e=s.Vector3d.create()),PolygonOps.areaNormalGo(new l.Point3dArrayCarrier(t),e),e}static area(t){return PolygonOps.areaNormal(t).magnitude()}static areaXY(t){let e=0;if(t instanceof c.IndexedXYZCollection){if(t.length>2){const r=t.getXAtUncheckedPointIndex(0),n=t.getYAtUncheckedPointIndex(0);let s,o,a=t.getXAtUncheckedPointIndex(1)-r,c=t.getYAtUncheckedPointIndex(1)-n;for(let l=1;l+1<t.length;l++,a=s,c=o)s=t.getXAtUncheckedPointIndex(l)-r,o=t.getYAtUncheckedPointIndex(l)-n,e+=i.Geometry.crossProductXYXY(a,c,s,o)}}else for(let r=1;r+1<t.length;r++)e+=t[0].crossProductToPointsXY(t[r],t[r+1]);return.5*e}static centroidAreaNormal(t){if(Array.isArray(t)){const e=new l.Point3dArrayCarrier(t);return this.centroidAreaNormal(e)}if(t instanceof c.IndexedXYZCollection)return this.centroidAreaNormalGo(t)}static centroidAreaNormalGo(t){if(Array.isArray(t)){const e=new l.Point3dArrayCarrier(t);return this.centroidAreaNormal(e)}const e=t.length;if(3===e){const e=t.crossProductIndexIndexIndex(0,1,2),r=.5*e.magnitude(),i=t.getPoint3dAtCheckedPointIndex(0);t.accumulateScaledXYZ(1,1,i),t.accumulateScaledXYZ(2,1,i),i.scaleInPlace(1/3);const n=a.Ray3d.createCapture(i,e);return n.tryNormalizeInPlaceWithAreaWeight(r)?n:void 0}if(e>=3){const r=s.Vector3d.createZero();for(let i=2;i<e;i++)t.accumulateCrossProductIndexIndexIndex(0,i-1,i,r);r.normalizeInPlace();const n=t.getPoint3dAtCheckedPointIndex(0),o=s.Vector3d.create(),c=s.Vector3d.create();t.vectorXYAndZIndex(n,1,o);let l=s.Vector3d.create();const d=s.Vector3d.createZero(),h=s.Vector3d.createZero();let u;for(let i=2;i<e;i++){t.vectorXYAndZIndex(n,i,c),l=o.crossProduct(c,l),u=r.dotProduct(l),h.addInPlace(l);const e=u/6;d.plus2Scaled(o,e,c,e,d),o.setFrom(c)}const f=.5*h.magnitude(),g=i.Geometry.conditionalDivideFraction(1,f);if(void 0!==g){const t=a.Ray3d.createCapture(n.plusScaled(d,g),h);return t.tryNormalizeInPlaceWithAreaWeight(f),t}}}static centroidAndAreaXY(t,e){let r=0;if(e.set(0,0),t.length<3)return;const s=t[0];let o=n.Vector2d.create(0,0),a=0;for(let i=1;i+1<t.length;i++){const e=s.vectorTo(t[i]),r=s.vectorTo(t[i+1]),n=e.crossProduct(r);o=o.plus(e.plus(r).scale(n)),a+=n}r=.5*a;const c=i.Geometry.conditionalDivideFraction(1,6*r);if(void 0!==c)return e.setFrom(s.plusScaled(o,c)),r;e.setFrom(s)}static unitNormal(t,e){const r=t.length;return 3===r?(t.crossProductIndexIndexIndex(0,1,2,e),e.normalizeInPlace()):4===r?(t.vectorIndexIndex(0,2,PolygonOps._vector0),t.vectorIndexIndex(1,3,PolygonOps._vector1),PolygonOps._vector0.crossProduct(PolygonOps._vector1,e),e.normalizeInPlace()):(PolygonOps.areaNormalGo(t,e),e.normalizeInPlace())}static addSecondMomentAreaProducts(t,e,r){this.addSecondMomentTransformedProducts(PolygonOps._triangleMomentWeights,t,e,2,r)}static addSecondMomentVolumeProducts(t,e,r){this.addSecondMomentTransformedProducts(PolygonOps._tetrahedralMomentWeights,t,e,3,r)}static addSecondMomentTransformedProducts(t,e,r,i,n){const s=PolygonOps._normal;if(PolygonOps.unitNormal(e,s)){const o=PolygonOps._vector0,a=PolygonOps._vector1,c=PolygonOps._vector2,l=PolygonOps._matrixA,d=PolygonOps._matrixB,h=PolygonOps._matrixC,u=e.vectorXYAndZIndex(r,0,PolygonOps._vectorOrigin),f=e.length;let g=0;for(let p=2;p<f;p++)2===i?(e.vectorIndexIndex(0,p-1,o),e.vectorIndexIndex(0,p,a),g=s.tripleProduct(o,a),l.setOriginAndVectors(u,o,a,s),l.multiplyMatrixMatrix(t,d),d.multiplyMatrixMatrixTranspose(l,h),n.addScaledInPlace(h,g)):3===i&&(e.vectorXYAndZIndex(r,0,o),e.vectorXYAndZIndex(r,p-1,a),e.vectorXYAndZIndex(r,p,c),g=o.tripleProduct(a,c),l.setOriginAndVectors(r,o,a,c),l.multiplyMatrixMatrix(t,d),d.multiplyMatrixMatrixTranspose(l,h),n.addScaledInPlace(h,g))}}static testXYPolygonTurningDirections(t){let e=t.length,r=e-1;for(;r>1&&t[r].x===t[0].x&&t[r].y===t[0].y;)e=r--;if(e>2){let i=n.Point2d.create(t[r].x-t[r-1].x,t[r].y-t[r-1].y);const s=n.Point2d.create(t[0].x-t[r].x,t[0].y-t[r].y),o=i.x*s.y-i.y*s.x;for(let r=1;r<e;r++){if(i=s.clone(),n.Point2d.create(t[r].x-t[r-1].x,t[r].y-t[r-1].y,s),(i.x*s.y-i.y*s.x)*o<=0)return 0}return o>0?1:-1}return 0}static classifyPointInPolygon(t,e,r){const i=new d.XYParitySearchContext(t,e);let n=0;const s=r.length;let o,a=-1;for(n=0;n<s;n=o)if((o=n+1)>=s&&(o=0),i.tryStartEdge(r[n].x,r[n].y,r[o].x,r[o].y)){a=o;break}if(!(a<0)){for(let t=1;t<=s;t++)if((o=a+t)>=s&&(o-=s),!i.advance(r[o].x,r[o].y))return i.classifyCounts();return i.classifyCounts()}}static classifyPointInPolygonXY(t,e,r){const i=new d.XYParitySearchContext(t,e);let n=0;const s=r.length;let o,a=-1;for(n=0;n<s;n=o)if((o=n+1)>=s&&(o=0),i.tryStartEdge(r.getXAtUncheckedPointIndex(n),r.getYAtUncheckedPointIndex(n),r.getXAtUncheckedPointIndex(o),r.getYAtUncheckedPointIndex(o))){a=o;break}if(!(a<0)){for(let t=1;t<=s;t++)if((o=a+t)>=s&&(o-=s),!i.advance(r.getXAtUncheckedPointIndex(o),r.getYAtUncheckedPointIndex(o)))return i.classifyCounts();return i.classifyCounts()}}static orientLoopsCCWForOutwardNormalInPlace(t,e){if(t instanceof c.IndexedXYZCollection)return this.orientLoopsCCWForOutwardNormalInPlace([t],e);const r=[],i=s.Vector3d.create();let n=0;for(const s of t)if(this.unitNormal(s,i)){const t=i.dotProduct(e);r.push(t),t<=0&&s.reverseInPlace(),n++}else r.push(0);return n}static sortOuterAndHoleLoopsXY(t){const e=[];for(const r of t)SortablePolygon.pushLoop(e,r);return SortablePolygon.assignParentsAndDepth(e)}}e.PolygonOps=PolygonOps,PolygonOps._triangleMomentWeights=o.Matrix4d.createRowValues(2/24,1/24,0,4/24,1/24,2/24,0,4/24,0,0,0,0,4/24,4/24,0,.5),PolygonOps._tetrahedralMomentWeights=o.Matrix4d.createRowValues(1/60,1/120,1/120,1/24,1/120,1/60,1/120,1/24,1/120,1/120,1/60,1/24,1/24,1/24,1/24,1/6),PolygonOps._vector0=s.Vector3d.create(),PolygonOps._vector1=s.Vector3d.create(),PolygonOps._vector2=s.Vector3d.create(),PolygonOps._vectorOrigin=s.Vector3d.create(),PolygonOps._normal=s.Vector3d.create(),PolygonOps._matrixA=o.Matrix4d.createIdentity(),PolygonOps._matrixB=o.Matrix4d.createIdentity(),PolygonOps._matrixC=o.Matrix4d.createIdentity();class IndexedXYZCollectionPolygonOps{static splitConvexPolygonInsideOutsidePlane(t,e,r,i,n){const s=IndexedXYZCollectionPolygonOps._xyz0Work,o=IndexedXYZCollectionPolygonOps._xyz1Work,a=IndexedXYZCollectionPolygonOps._xyz2Work,c=e.length;r.clear(),i.clear();if(c>2){e.back(s),n.setNull();let l=t.altitude(s);n.extendX(l);for(let d=0;d<c;d++){e.getPoint3dAtUncheckedPointIndex(d,o);const c=t.altitude(o);n.extendX(c);let h=!1;if(l*c<0){const t=-l/(c-l);t>1-1e-8&&c>=0?h=!0:(s.interpolate(t,o,a),r.push(a),i.push(a))}(c>=0||h)&&r.push(o),(c<=0||h)&&i.push(o),s.setFromPoint3d(o),l=c}}}static clipConvexPolygonInPlace(t,e,r,n=!0,s=i.Geometry.smallMetricDistance){r.clear();const o=n?1:-1,a=e.length;let c=0;const l=-s;if(e.length>1){let i,n=e.length-1,s=o*e.evaluateUncheckedIndexPlaneAltitude(n,t);for(let d=0;d<a;s=i,n=d++){if((i=o*e.evaluateUncheckedIndexPlaneAltitude(d,t))<0&&c++,s*i<0){const t=-s/(i-s);t>1-1e-8&&i>=0||r.pushInterpolatedFromGrowableXYZArray(e,n,t,d)}i>=l&&r.pushFromGrowableXYZArray(e,d),n=d,s=i}}r.length<=2?e.clear():c>0&&(e.clear(),e.pushFromGrowableXYZArray(r)),r.clear()}static intersectRangeConvexPolygonInPlace(t,e){if(t.isNull)return;const r=new h.GrowableXYZArray,i=f.Point4d.create();return i.set(0,0,-1,t.high.z),this.clipConvexPolygonInPlace(i,e,r,!0),0!==e.length&&(i.set(0,0,-1,-t.low.z),this.clipConvexPolygonInPlace(i,e,r,!0),0===e.length&&i.set(0,-1,0,-t.high.y),this.clipConvexPolygonInPlace(i,e,r,!0),0!==e.length&&(i.set(0,1,0,t.low.y),this.clipConvexPolygonInPlace(i,e,r,!0),0!==e.length&&(i.set(-1,0,0,t.high.x),this.clipConvexPolygonInPlace(i,e,r,!0),0!==e.length&&(i.set(1,0,0,-t.low.x),this.clipConvexPolygonInPlace(i,e,r,!0),0!==e.length))))?e:void 0}}e.IndexedXYZCollectionPolygonOps=IndexedXYZCollectionPolygonOps,IndexedXYZCollectionPolygonOps._xyz0Work=s.Point3d.create(),IndexedXYZCollectionPolygonOps._xyz1Work=s.Point3d.create(),IndexedXYZCollectionPolygonOps._xyz2Work=s.Point3d.create();class Point3dArrayPolygonOps{static convexPolygonSplitInsideOutsidePlane(t,e,r,i,n){const s=new l.Point3dArrayCarrier(e),o=new l.Point3dArrayCarrier(r),a=new l.Point3dArrayCarrier(i);IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(t,s,o,a,n)}static polygonPlaneCrossings(t,e,r){if(r.length=0,e.length>=2){const i=this._xyz0Work;i.setFromPoint3d(e[e.length-1]);let n=t.altitude(i);for(const s of e){const e=t.altitude(s);if(n*e<0){const t=-n/(e-n);r.push(i.interpolate(t,s))}0===e&&r.push(s.clone()),i.setFromPoint3d(s),n=e}}}static convexPolygonClipInPlace(t,e,r,n=i.Geometry.smallMetricDistance){void 0===r&&(r=[]),r.length=0;let o=0;const a=-n;if(e.length>2){let i=e[e.length-1],n=t.altitude(i);for(const c of e){const e=t.altitude(c);if(e<0&&o++,n*e<0){const t=-n/(e-n);t>1-1e-8&&e>=0||r.push(i.interpolate(t,c))}e>=a&&r.push(c),i=s.Point3d.createFrom(c),n=e}}if(r.length<=2)e.length=0;else if(o>0){e.length=0;for(const t of r)e.push(t);r.length=0}}}e.Point3dArrayPolygonOps=Point3dArrayPolygonOps,Point3dArrayPolygonOps._xyz0Work=s.Point3d.create();class SortablePolygon{constructor(t,e,r){this.loop=t,this.range=e,this.signedArea=r,this.sortKey=Math.abs(this.signedArea),this.isHole=!1}static pushLoop(t,e){const r=PolygonOps.areaXY(e);return!(r>0)||(t.push(new SortablePolygon(e,u.Range3d.createFromVariantData(e),r)),!0)}static assignParentsAndDepth(t){const e=[];t.sort((t,e)=>e.sortKey-t.sortKey),e.length=0;for(let r=t.length;r-- >0;){const e=t[r].loop.getXAtUncheckedPointIndex(0),i=t[r].loop.getYAtUncheckedPointIndex(0);t[r].parentIndex=void 0,t[r].outputSetIndex=void 0;for(let n=r;n-- >0;)if(t[n].range.containsXY(e,i)&&1===PolygonOps.classifyPointInPolygonXY(e,i,t[n].loop)){t[r].parentIndex=n;break}}for(const r of t){r.isHole=!1;const i=r.parentIndex;if(void 0!==i&&(r.isHole=!t[i].isHole),r.isHole){r.reverseLoopForAreaSign(-1),e[t[i].outputSetIndex].push(r.loop)}else r.reverseLoopForAreaSign(1),r.outputSetIndex=e.length,e.push([]),e[r.outputSetIndex].push(r.loop)}return e}reverseLoopForAreaSign(t){t*this.signedArea<0&&(this.loop.reverseInPlace(),this.signedArea*=-1)}}},"./lib/geometry3d/PolylineCompressionByEdgeOffset.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Point3dArrayCarrier.js"),s=r("./lib/Geometry.js");class PolylineCompressionContext{constructor(t,e,r){this._toleranceSquared=r*r,this._source=t,this._dest=e}acceptPointByIndex(t){const e=this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(t));e&&this._dest.push(e)}indexOfMaxCrossProduct(t,e){let r,i,n=0;for(let s=t;s<=e;s++){const t=this._source.cyclicIndex(s),e=this._source.cyclicIndex(s+1),o=this._source.cyclicIndex(s+2);this._source.crossProductIndexIndexIndex(t,e,o,PolylineCompressionContext._vectorQ),(r=PolylineCompressionContext._vectorQ.magnitudeSquared())>n&&(n=r,i=s)}return i}indexOfMaxDeviation(t,e){const r=this._source.cyclicIndex(t),i=this._source.cyclicIndex(e);let n,s,o,a,c,l=this._toleranceSquared;this._source.vectorIndexIndex(r,i,PolylineCompressionContext._vector01);const d=PolylineCompressionContext._vector01.magnitudeSquared();for(let h=t+1;h<e;h++)c=this._source.cyclicIndex(h),this._source.vectorIndexIndex(r,c,PolylineCompressionContext._vectorQ),(s=PolylineCompressionContext._vector01.dotProduct(PolylineCompressionContext._vectorQ))<=0?o=PolylineCompressionContext._vectorQ.magnitudeSquared():s>d?(this._source.vectorIndexIndex(i,c,PolylineCompressionContext._vectorQ),o=PolylineCompressionContext._vectorQ.magnitudeSquared()):(a=s/d,o=PolylineCompressionContext._vectorQ.magnitudeSquared()-d*a*a),o>l&&(l=o,n=h);return n}recursiveCompressByChordErrorGo(t,e){if(e===t+1)return void this.acceptPointByIndex(e);const r=this.indexOfMaxDeviation(t,e);void 0===r?this.acceptPointByIndex(e):(this.recursiveCompressByChordErrorGo(t,r),this.recursiveCompressByChordErrorGo(r,e))}static compressPoint3dArrayByChordError(t,e){const r=new n.Point3dArrayCarrier(t),i=new n.Point3dArrayCarrier([]);return this.compressCollectionByChordError(r,i,e),i.data}static compressCollectionByChordError(t,e,r){e.clear();const i=t.length;if(1===i)return void e.push(t.getPoint3dAtCheckedPointIndex(0));const n=new PolylineCompressionContext(t,e,r);let s=0,o=i-1;if(i>2&&t.distanceIndexIndex(0,i-1)<=r){const t=n.indexOfMaxCrossProduct(0,i-1);void 0!==t&&(o=(s=t+1)+i)}n.acceptPointByIndex(s),n.recursiveCompressByChordErrorGo(s,o)}static compressInPlaceByShortEdgeLength(t,e){const r=t.length;if(r<2)return;let i=0,n=r-1;for(;n>0&&t.distanceIndexIndex(n-1,r-1)<e;)n--;if(0===n)return void(t.length=1);n<r-1&&t.moveIndexToIndex(r-1,n);let s=i+1;for(;s<=n;)t.distanceIndexIndex(i,s)>=e&&(t.moveIndexToIndex(s,i+1),i++),s++;t.length=i+1}static compressInPlaceBySmallTriangleArea(t,e){const r=t.length;if(r<3)return;let n=0;const s=i.Vector3d.create();for(let i=1;i+1<r;i++)t.crossProductIndexIndexIndex(n,i,i+1,s),.5*s.magnitude()>e&&t.moveIndexToIndex(i,++n);t.moveIndexToIndex(r-1,++n),t.length=n+1}static compressInPlaceByPerpendicularDistance(t,e,r=1.0001){const i=t.length;if(i<3)return;let n=0;const o=PolylineCompressionContext._vector01,a=PolylineCompressionContext._vectorQ;let c;const l=e*e;let d,h=1;for(;h+1<i;h++){t.vectorIndexIndex(n,h+1,o),t.vectorIndexIndex(n,h,a),d=o.magnitudeSquared();const e=s.Geometry.conditionalDivideFraction(a.dotProduct(o),d);void 0!==e&&e>=0&&e<=r&&(c=PolylineCompressionContext._vectorQ.magnitudeSquared()-d*e*e)<=l?(t.moveIndexToIndex(h+1,++n),h+=1):t.moveIndexToIndex(h,++n)}h<i&&t.moveIndexToIndex(h,++n),t.length=n+1}}e.PolylineCompressionContext=PolylineCompressionContext,PolylineCompressionContext._vector01=i.Vector3d.create(),PolylineCompressionContext._vectorQ=i.Vector3d.create()},"./lib/geometry3d/PolylineOps.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js"),n=r("./lib/geometry3d/PolylineCompressionByEdgeOffset.js"),s=r("./lib/geometry3d/GrowableXYZArray.js");e.PolylineOps=class PolylineOps{static edgeLengthRange(t){const e=i.Range1d.createNull();for(let r=1;r<t.length;r++)e.extendX(t[r-1].distance(t[r]));return e}static compressByChordError(t,e){return n.PolylineCompressionContext.compressPoint3dArrayByChordError(t,e)}static compressShortEdges(t,e){const r=s.GrowableXYZArray.create(t);return n.PolylineCompressionContext.compressInPlaceByShortEdgeLength(r,e),r.getPoint3dArray()}static compressSmallTriangles(t,e){const r=s.GrowableXYZArray.create(t);return n.PolylineCompressionContext.compressInPlaceBySmallTriangleArea(r,e),r.getPoint3dArray()}static compressByPerpendicularDistance(t,e,r=2){const i=s.GrowableXYZArray.create(t);let o=i.length;for(let s=0;s<r;s++){n.PolylineCompressionContext.compressInPlaceByPerpendicularDistance(i,e);const t=i.length;if(t===o)break;o=t}return i.getPoint3dArray()}}},"./lib/geometry3d/Range.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Matrix3d.js"),s=r("./lib/geometry3d/Point2dVector2d.js"),o=r("./lib/geometry3d/Point3dVector3d.js"),a=r("./lib/geometry3d/Transform.js"),c=r("./lib/geometry3d/PointStreaming.js");class RangeBase{static npcScaleFactor(t,e){return e<=t?0:1/(e-t)}static isExtremeValue(t){return Math.abs(t)>=RangeBase._EXTREME_POSITIVE}static isExtremePoint3d(t){return RangeBase.isExtremeValue(t.x)||RangeBase.isExtremeValue(t.y)||RangeBase.isExtremeValue(t.z)}static isExtremePoint2d(t){return RangeBase.isExtremeValue(t.x)||RangeBase.isExtremeValue(t.y)}static rangeToRangeAbsoluteDistance(t,e,r,i){return e<t?RangeBase._EXTREME_POSITIVE:i<r?RangeBase._EXTREME_POSITIVE:i<t?t-i:i<=e?0:r<=e?0:r-e}static coordinateToRangeAbsoluteDistance(t,e,r){return r<e?RangeBase._EXTREME_POSITIVE:t<e?e-t:t>r?t-r:0}}e.RangeBase=RangeBase,RangeBase._EXTREME_POSITIVE=1e200,RangeBase._EXTREME_NEGATIVE=-1e200;class Range3d extends RangeBase{constructor(t=RangeBase._EXTREME_POSITIVE,e=RangeBase._EXTREME_POSITIVE,r=RangeBase._EXTREME_POSITIVE,i=RangeBase._EXTREME_NEGATIVE,n=RangeBase._EXTREME_NEGATIVE,s=RangeBase._EXTREME_NEGATIVE){super(),this.low=o.Point3d.create(t,e,r),this.high=o.Point3d.create(i,n,s)}setNull(){this.low.x=RangeBase._EXTREME_POSITIVE,this.low.y=RangeBase._EXTREME_POSITIVE,this.low.z=RangeBase._EXTREME_POSITIVE,this.high.x=RangeBase._EXTREME_NEGATIVE,this.high.y=RangeBase._EXTREME_NEGATIVE,this.high.z=RangeBase._EXTREME_NEGATIVE}freeze(){Object.freeze(this),Object.freeze(this.low),Object.freeze(this.high)}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z)}toFloat64Array(){return Range3d.toFloat64Array(this)}static fromFloat64Array(t){if(6!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3],t[4],t[5])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}isAlmostEqual(t){return this.low.isAlmostEqual(t.low)&&this.high.isAlmostEqual(t.high)||this.isNull&&t.isNull}setFrom(t){this.low.setFrom(t.low),this.high.setFrom(t.high)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYZXYZOrCorrectToNull(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z,e)}setFromJSON(t){if(!t)return;if(this.setNull(),Array.isArray(t)){const e=o.Point3d.create();for(const r of t)e.setFromJSON(r),this.extendPoint(e);return}const e=o.Point3d.fromJSON(t.low),r=o.Point3d.fromJSON(t.high);RangeBase.isExtremePoint3d(e)||RangeBase.isExtremePoint3d(r)||(this.extendPoint(e),this.extendPoint(r))}toJSON(){return{low:this.low.toJSON(),high:this.high.toJSON()}}static fromJSON(t){const e=new this;return e.setFromJSON(t),e}setDirect(t,e,r,i,n,s,o){this.low.x=t,this.low.y=e,this.low.z=r,this.high.x=i,this.high.y=n,this.high.z=s,o&&(this.low.x>this.high.x||this.low.y>this.high.y||this.low.z>this.high.z)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.low.z,this.high.x,this.high.y,this.high.z,!1),t}static createNull(t){return(t=t||new this).setNull(),t}extend(...t){let e;for(e of t)this.extendPoint(e)}static create(...t){const e=Range3d.createNull();let r;for(r of t)e.extendPoint(r);return e}static createFromVariantData(t){const e=new c.PointStreamRangeCollector;return c.VariantPointDataStream.streamXYZ(t,e),e.claimResult()}static createTransformed(t,...e){const r=this.createNull();let i;for(i of e)r.extendTransformedXYZ(t,i.x,i.y,i.z);return r}static createTransformedArray(t,e){const r=this.createNull();return r.extendArray(e,t),r}static createInverseTransformedArray(t,e){const r=this.createNull();return r.extendInverseTransformedArray(e,t),r}setXYZ(t,e,r){this.low.x=this.high.x=t,this.low.y=this.high.y=e,this.low.z=this.high.z=r}static createXYZ(t,e,r,i){return(i=i||new this).setDirect(t,e,r,t,e,r,!1),i}static createXYZXYZ(t,e,r,i,n,s,o){return(o=o||new this).setDirect(Math.min(t,i),Math.min(e,n),Math.min(r,s),Math.max(t,i),Math.max(e,n),Math.max(r,s),!1),o}static createXYZXYZOrCorrectToNull(t,e,r,i,n,s,o){return(o=o||new this).setDirect(Math.min(t,i),Math.min(e,n),Math.min(r,s),Math.max(t,i),Math.max(e,n),Math.max(r,s),!0),o}static createRange2d(t,e=0,r){const i=r||new this;return i.setNull(),i.extendXYZ(t.low.x,t.low.y,e),i.extendXYZ(t.high.x,t.high.y,e),i}static createArray(t,e){let r;for(r of((e=e||new this).setNull(),t))e.extendPoint(r);return e}extendArray(t,e){if(Array.isArray(t))if(e)for(const r of t)this.extendTransformedXYZ(e,r.x,r.y,r.z);else for(const r of t)this.extendXYZ(r.x,r.y,r.z);else if(e)for(let r=0;r<t.length;r++)this.extendTransformedXYZ(e,t.getXAtUncheckedPointIndex(r),t.getYAtUncheckedPointIndex(r),t.getZAtUncheckedPointIndex(r));else for(let r=0;r<t.length;r++)this.extendXYZ(t.getXAtUncheckedPointIndex(r),t.getYAtUncheckedPointIndex(r),t.getZAtUncheckedPointIndex(r))}extendInverseTransformedArray(t,e){if(Array.isArray(t))for(const r of t)this.extendInverseTransformedXYZ(e,r.x,r.y,r.z);else for(let r=0;r<t.length;r++)this.extendInverseTransformedXYZ(e,t.getXAtUncheckedPointIndex(r),t.getYAtUncheckedPointIndex(r),t.getZAtUncheckedPointIndex(r))}extendTransformedXYZ(t,e,r,i){const n=t.origin,s=t.matrix.coffs;this.extendXYZ(n.x+s[0]*e+s[1]*r+s[2]*i,n.y+s[3]*e+s[4]*r+s[5]*i,n.z+s[6]*e+s[7]*r+s[8]*i)}extendTransformedXYZW(t,e,r,i,n){const s=t.origin,o=t.matrix.coffs;this.extendXYZW(s.x*n+o[0]*e+o[1]*r+o[2]*i,s.y*n+o[3]*e+o[4]*r+o[5]*i,s.z*n+o[6]*e+o[7]*r+o[8]*i,n)}extendInverseTransformedXYZ(t,e,r,i){const n=t.origin;if(!t.matrix.computeCachedInverse(!0))return!1;const s=t.matrix.inverseCoffs,o=e-n.x,a=r-n.y,c=i-n.z;return this.extendXYZ(s[0]*o+s[1]*a+s[2]*c,s[3]*o+s[4]*a+s[5]*c,s[6]*o+s[7]*a+s[8]*c),!0}extendTransformTransformedXYZ(t,e,r,i,n){const s=e.origin,o=e.matrix.coffs;this.extendTransformedXYZ(t,s.x+o[0]*r+o[1]*i+o[2]*n,s.y+o[3]*r+o[4]*i+o[5]*n,s.z+o[6]*r+o[7]*i+o[8]*n)}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y||this.high.z<this.low.z}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y||t.high.z<t.low.z}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y&&this.high.z===this.low.z}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get zLow(){return this.low.z}get xHigh(){return this.high.x}get yHigh(){return this.high.y}get zHigh(){return this.high.z}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}zLength(){const t=this.high.z-this.low.z;return t>0?t:0}maxLength(){return Math.max(this.xLength(),this.yLength(),this.zLength())}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,r,i){return this.low.interpolateXYZ(t,e,r,this.high,i)}localXYZToWorld(t,e,r,i){if(!this.isNull)return this.low.interpolateXYZ(t,e,r,this.high,i)}localToWorld(t,e){return this.localXYZToWorld(t.x,t.y,t.z,e)}localToWorldArrayInPlace(t){if(this.isNull)return!1;for(const e of t)this.low.interpolateXYZ(e.x,e.y,e.z,this.high,e);return!1}worldToLocal(t,e){const r=RangeBase.npcScaleFactor(this.low.x,this.high.x),i=RangeBase.npcScaleFactor(this.low.y,this.high.y),n=RangeBase.npcScaleFactor(this.low.z,this.high.z);if(0!==r&&0!==i&&0!==n)return o.Point3d.create((t.x-this.low.x)*r,(t.y-this.low.y)*i,(t.z-this.low.z)*n,e)}worldToLocalArrayInPlace(t){const e=RangeBase.npcScaleFactor(this.low.x,this.high.x),r=RangeBase.npcScaleFactor(this.low.y,this.high.y),i=RangeBase.npcScaleFactor(this.low.z,this.high.z);if(0===e||0===r||0===i)return!1;for(const n of t)o.Point3d.create((n.x-this.low.x)*e,(n.y-this.low.y)*r,(n.z-this.low.z)*i,n);return!0}corners(){return[o.Point3d.create(this.low.x,this.low.y,this.low.z),o.Point3d.create(this.high.x,this.low.y,this.low.z),o.Point3d.create(this.low.x,this.high.y,this.low.z),o.Point3d.create(this.high.x,this.high.y,this.low.z),o.Point3d.create(this.low.x,this.low.y,this.high.z),o.Point3d.create(this.high.x,this.low.y,this.high.z),o.Point3d.create(this.low.x,this.high.y,this.high.z),o.Point3d.create(this.high.x,this.high.y,this.high.z)]}static faceCornerIndices(t){return 0===t?[0,4,6,2]:1===t?[1,3,7,5]:2===t?[0,1,5,4]:3===t?[3,2,6,7]:4===t?[0,2,3,1]:[4,5,7,6]}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return i.Geometry.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return i.Geometry.isSmallMetricDistance(this.yLength())}get isAlmostZeroZ(){return i.Geometry.isSmallMetricDistance(this.zLength())}containsXYZ(t,e,r){return t>=this.low.x&&e>=this.low.y&&r>=this.low.z&&t<=this.high.x&&e<=this.high.y&&r<=this.high.z}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXYZ(t.x,t.y,t.z)}containsPointXY(t){return t.x>=this.low.x&&t.y>=this.low.y&&t.x<=this.high.x&&t.y<=this.high.y}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.low.z>=this.low.z&&t.high.x<=this.high.x&&t.high.y<=this.high.y&&t.high.z<=this.high.z}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||this.low.z>t.high.z||t.low.x>this.high.x||t.low.y>this.high.y||t.low.z>this.high.z)}intersectsRangeXY(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?RangeBase._EXTREME_POSITIVE:Math.min(i.Geometry.hypotenuseXYZ(RangeBase.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),RangeBase.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y),RangeBase.coordinateToRangeAbsoluteDistance(t.z,this.low.z,this.high.z)),RangeBase._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(i.Geometry.hypotenuseXYZ(RangeBase.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),RangeBase.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y),RangeBase.rangeToRangeAbsoluteDistance(this.low.z,this.high.z,t.low.z,t.high.z)),RangeBase._EXTREME_POSITIVE)}extendXYZ(t,e,r){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e),r<this.low.z&&(this.low.z=r),r>this.high.z&&(this.high.z=r)}extendXYZW(t,e,r,n){i.Geometry.isSmallMetricDistance(n)||this.extendXYZ(t/n,e/n,r/n)}extendPoint(t){this.extendXYZ(t.x,t.y,t.z)}extendTransformedPoint(t,e){this.extendTransformedXYZ(t,e.x,e.y,e.z)}extendRange(t){Range3d.isNull(t)||(this.extendXYZ(t.low.x,t.low.y,t.low.z),this.extendXYZ(t.high.x,t.high.y,t.high.z))}intersect(t,e){return this.intersectsRange(t)?Range3d.createXYZXYZOrCorrectToNull(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.max(this.low.z,t.low.z),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),Math.min(this.high.z,t.high.z),e):Range3d.createNull(e)}union(t,e){return this.isNull?t.clone(e):t.isNull?this.clone(e):Range3d.createXYZXYZOrCorrectToNull(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.min(this.low.z,t.low.z),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),Math.max(this.high.z,t.high.z),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),r=.5*(this.low.y+this.high.y),n=.5*(this.low.z+this.high.z);this.high.x=i.Geometry.interpolate(e,t,this.high.x),this.high.y=i.Geometry.interpolate(r,t,this.high.y),this.high.z=i.Geometry.interpolate(n,t,this.high.z),this.low.x=i.Geometry.interpolate(e,t,this.low.x),this.low.y=i.Geometry.interpolate(r,t,this.low.y),this.low.z=i.Geometry.interpolate(n,t,this.low.z)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.low.z-t,this.high.x+t,this.high.y+t,this.high.z+t,!0)}getLocalToWorldTransform(t){return a.Transform.createOriginAndMatrix(o.Point3d.create(this.low.x,this.low.y,this.low.z),n.Matrix3d.createRowValues(this.high.x-this.low.x,0,0,0,this.high.y-this.low.y,0,0,0,this.high.z-this.low.z),t)}getNpcToWorldRangeTransform(t){const e=this.getLocalToWorldTransform(t),r=e.matrix;return 0===r.coffs[0]&&(r.coffs[0]=1),0===r.coffs[4]&&(r.coffs[4]=1),0===r.coffs[8]&&(r.coffs[8]=1),e}ensureMinLengths(t=.001){let e=(t-this.xLength())/2;e>0&&(this.low.x-=e,this.high.x+=e),(e=(t-this.yLength())/2)>0&&(this.low.y-=e,this.high.y+=e),(e=(t-this.zLength())/2)>0&&(this.low.z-=e,this.high.z+=e)}}e.Range3d=Range3d;class Range1d extends RangeBase{constructor(t=RangeBase._EXTREME_POSITIVE,e=RangeBase._EXTREME_NEGATIVE){super(),this.low=t,this.high=e,this.setDirect(t,e)}setNull(){this.low=RangeBase._EXTREME_POSITIVE,this.high=RangeBase._EXTREME_NEGATIVE}setDirect(t,e,r=!1){this.low=t,this.high=e,r&&t>e&&this.setNull()}isAlmostEqual(t){return i.Geometry.isSameCoordinate(this.low,t.low)&&i.Geometry.isSameCoordinate(this.high,t.high)||this.isNull&&t.isNull}setFrom(t){this.low=t.low,this.high=t.high}setFromJSON(t){if(this.setNull(),Array.isArray(t)){let e;for(e of t)Number.isFinite(e)&&this.extendX(e)}else void 0!==t.low&&Number.isFinite(t.low)&&void 0!==t.high&&Number.isFinite(t.high)&&(this.extendX(t.low),this.extendX(t.high))}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}toJSON(){return this.isNull?new Array:[this.low,this.high]}clone(t){return(t=t||new this.constructor).setDirect(this.low,this.high),t}static createFrom(t,e){return(e=e||new this).setDirect(t.low,t.high),e}static createNull(t){return(t=t||new this).setNull(),t}cloneTranslated(t,e){return(e=e||this.clone()).isNull||(e.low+=t,e.high+=t),e}setX(t){this.low=this.high=t}static createX(t,e){return(e=e||new this).setDirect(t,t),e}static createXX(t,e,r){return(r=r||new this).setDirect(Math.min(t,e),Math.max(t,e)),r}static createXXOrCorrectToNull(t,e,r){return e<t?Range1d.createNull(r):((r=r||new this).setDirect(Math.min(t,e),Math.max(t,e)),r)}static createArray(t,e){let r;for(r of(e=e||new this,t))e.extendX(r);return e}extendArray(t){let e;for(e of t)this.extendX(e)}extendArraySubset(t,e,r){const i=e+r;for(let n=e;n<i;n++)this.extendX(t[n])}get isNull(){return this.high<this.low}get isSinglePoint(){return this.high===this.low}length(){const t=this.high-this.low;return t>0?t:0}fractionToPoint(t){return i.Geometry.interpolate(this.low,t,this.high)}maxAbs(){return this.isNull?0:Math.max(Math.abs(this.low),Math.abs(this.high))}get isAlmostZeroLength(){return i.Geometry.isSmallMetricDistance(this.length())}containsX(t){return t>=this.low&&t<=this.high}containsRange(t){return t.low>=this.low&&t.high<=this.high}intersectsRange(t){return!(this.low>t.high||t.low>this.high)}distanceToRange(t){return RangeBase.rangeToRangeAbsoluteDistance(this.low,this.high,t.low,t.high)}distanceToX(t){return this.isNull?RangeBase._EXTREME_POSITIVE:RangeBase.coordinateToRangeAbsoluteDistance(t,this.low,this.high)}extendX(t){t<this.low&&(this.low=t),t>this.high&&(this.high=t)}extendRange(t){t.isNull||(this.extendX(t.low),this.extendX(t.high))}intersect(t,e){return this.intersectsRange(t)?Range1d.createXXOrCorrectToNull(Math.max(this.low,t.low),Math.min(this.high,t.high),e):Range1d.createNull(e)}union(t,e){return Range1d.createXX(Math.min(this.low,t.low),Math.max(this.high,t.high),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low+this.high);this.high=i.Geometry.interpolate(e,t,this.high),this.low=i.Geometry.interpolate(e,t,this.low)}}expandInPlace(t){this.setDirect(this.low-t,this.high+t,!0)}clipLinearMapToInterval(t,e,r,n){if(n<r||this.high<this.low)return!1;const s=i.Geometry.conditionalDivideFraction(r-t,e),o=i.Geometry.conditionalDivideFraction(n-t,e);return void 0===s||void 0===o?r<=t&&t<=n||(this.setNull(),!1):(s<o?(s>this.low&&(this.low=s),o<this.high&&(this.high=o)):(s<this.high&&(this.high=s),o>this.low&&(this.low=o)),!(this.high<this.low)||(this.setNull(),!1))}}e.Range1d=Range1d;class Range2d extends RangeBase{constructor(t=Range2d._EXTREME_POSITIVE,e=Range2d._EXTREME_POSITIVE,r=Range2d._EXTREME_NEGATIVE,i=Range2d._EXTREME_NEGATIVE){super(),this.low=s.Point2d.create(t,e),this.high=s.Point2d.create(r,i)}setNull(){this.low.x=RangeBase._EXTREME_POSITIVE,this.low.y=RangeBase._EXTREME_POSITIVE,this.high.x=RangeBase._EXTREME_NEGATIVE,this.high.y=RangeBase._EXTREME_NEGATIVE}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.high.x,t.high.y)}toFloat64Array(){return Range2d.toFloat64Array(this)}static fromFloat64Array(t){if(4!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}isAlmostEqual(t){return this.low.isAlmostEqual(t.low)&&this.high.isAlmostEqual(t.high)||this.isNull&&t.isNull}setFrom(t){this.low.set(t.low.x,t.low.y),this.high.set(t.high.x,t.high.y)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYXYOrCorrectToNull(t.low.x,t.low.y,t.high.x,t.high.y,e)}setFromJSON(t){if(this.setNull(),Array.isArray(t)){const e=s.Point2d.create();for(const r of t)e.setFromJSON(r),this.extendPoint(e);return}const e=s.Point2d.fromJSON(t.low),r=s.Point2d.fromJSON(t.high);RangeBase.isExtremePoint2d(e)||RangeBase.isExtremePoint2d(r)||(this.extendPoint(e),this.extendPoint(r))}freeze(){Object.freeze(this.low),Object.freeze(this.high)}toJSON(){return this.isNull?[]:[this.low.toJSON(),this.high.toJSON()]}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}setDirect(t,e,r,i,n){this.low.x=t,this.low.y=e,this.high.x=r,this.high.y=i,n&&(this.low.x>this.high.x||this.low.y>this.high.y)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.high.x,this.high.y,!1),t}static createNull(t){return(t=t||new this).setNull(),t}setXY(t,e){this.low.x=this.high.x=t,this.low.y=this.high.y=e}static createXY(t,e,r){return(r=r||new this).setDirect(t,e,t,e,!1),r}static createXYXY(t,e,r,i,n){return(n=n||new this).setDirect(Math.min(t,r),Math.min(e,i),Math.max(t,r),Math.max(e,i),!1),n}static createXYXYOrCorrectToNull(t,e,r,i,n){return t>r||e>i?this.createNull(n):((n=n||new this).setDirect(Math.min(t,r),Math.min(e,i),Math.max(t,r),Math.max(e,i),!0),n)}static createArray(t,e){let r;for(r of(e=e||new this,t))e.extendPoint(r);return e}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get xHigh(){return this.high.x}get yHigh(){return this.high.y}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,r){return this.low.interpolateXY(t,e,this.high,r)}corners3d(t=!1,e=0){return t?[o.Point3d.create(this.low.x,this.low.y,e),o.Point3d.create(this.high.x,this.low.y,e),o.Point3d.create(this.high.x,this.high.y,e),o.Point3d.create(this.low.x,this.high.y,e),o.Point3d.create(this.low.x,this.low.y,e)]:[o.Point3d.create(this.low.x,this.low.y,e),o.Point3d.create(this.high.x,this.low.y,e),o.Point3d.create(this.low.x,this.high.y,e),o.Point3d.create(this.high.x,this.high.y,e)]}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return i.Geometry.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return i.Geometry.isSmallMetricDistance(this.yLength())}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXY(t.x,t.y)}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.high.x<=this.high.x&&t.high.y<=this.high.y}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?Range2d._EXTREME_POSITIVE:Math.min(i.Geometry.hypotenuseXY(RangeBase.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),RangeBase.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y)),Range2d._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(i.Geometry.hypotenuseXY(RangeBase.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),RangeBase.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y)),Range2d._EXTREME_POSITIVE)}extendXY(t,e){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e)}extendTransformedXY(t,e,r){const i=t.multiplyComponentXYZ(0,e,r,0),n=t.multiplyComponentXYZ(1,e,r,0);this.extendXY(i,n)}extendPoint(t){this.extendXY(t.x,t.y)}extendRange(t){Range2d.isNull(t)||(this.extendXY(t.low.x,t.low.y),this.extendXY(t.high.x,t.high.y))}intersect(t,e){return this.intersectsRange(t)?Range2d.createXYXY(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),e):Range2d.createNull(e)}union(t,e){return this.isNull?Range2d.createFrom(t,e):Range2d.isNull(t)?this.clone(e):Range2d.createXYXY(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),r=.5*(this.low.y+this.high.y);this.high.x=i.Geometry.interpolate(e,t,this.high.x),this.high.y=i.Geometry.interpolate(r,t,this.high.y),this.low.x=i.Geometry.interpolate(e,t,this.low.x),this.low.y=i.Geometry.interpolate(r,t,this.low.y)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.high.x+t,this.high.y+t,!0)}}e.Range2d=Range2d},"./lib/geometry3d/Ray3d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Transform.js"),s=r("./lib/geometry3d/Matrix3d.js"),o=r("./lib/Geometry.js"),a=r("./lib/curve/CurveLocationDetail.js"),c=r("./lib/numerics/Polynomials.js"),l=r("./lib/geometry3d/Point2dVector2d.js"),d=r("./lib/geometry3d/Range.js");class Ray3d{constructor(t,e){this.origin=t,this.direction=e,this.a=void 0}static _create(t,e,r,n,s,o){return new Ray3d(i.Point3d.create(t,e,r),i.Vector3d.create(n,s,o))}static createXAxis(){return Ray3d._create(0,0,0,1,0,0)}static createYAxis(){return Ray3d._create(0,0,0,0,1,0)}static createZAxis(){return Ray3d._create(0,0,0,0,0,1)}static createZero(t){return t?(t.origin.setZero(),t.direction.setZero(),t):new Ray3d(i.Point3d.createZero(),i.Vector3d.createZero())}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.direction.isAlmostEqual(t.direction)}static create(t,e,r){return r?(r.set(t,e),r):new Ray3d(t.clone(),e.clone())}static createWeightedDerivative(t,e,r){const i=t[3],n=e[3],s=t[0],a=t[1],c=t[2],l=e[0]*i-t[0]*n,d=e[1]*i-t[1]*n,h=e[2]*i-t[2]*n;if(o.Geometry.isSmallMetricDistance(i))return;const u=1/i,f=u*u;return Ray3d.createXYZUVW(s*u,a*u,c*u,l*f,d*f,h*f,r)}static createXYZUVW(t,e,r,n,s,o,a){return a?(a.getOriginRef().set(t,e,r),a.getDirectionRef().set(n,s,o),a):new Ray3d(i.Point3d.create(t,e,r),i.Vector3d.create(n,s,o))}static createCapture(t,e){return new Ray3d(t,e)}static createPointVectorNumber(t,e,r,i){return i?(i.origin.setFrom(t),i.direction.setFrom(e),i.a=r,i):((i=new Ray3d(t.clone(),e.clone())).a=r,i)}static createStartEnd(t,e,r){return r?(r.origin.setFrom(t),r.direction.setStartEnd(t,e),r):new Ray3d(t,i.Vector3d.createStartEnd(t,e))}getOriginRef(){return this.origin}getDirectionRef(){return this.direction}set(t,e){this.origin.setFrom(t),this.direction.setFrom(e)}clone(t){return t?(t.set(this.origin.clone(),this.direction.clone()),t):new Ray3d(this.origin.clone(),this.direction.clone())}cloneTransformed(t){return new Ray3d(t.multiplyPoint3d(this.origin),t.multiplyVector(this.direction))}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.direction,this.direction)}setFrom(t){this.set(t.origin,t.direction)}fractionToPoint(t){return this.origin.plusScaled(this.direction,t)}dotProductToPoint(t){return this.direction.dotProductStartEnd(this.origin,t)}pointToFraction(t){return o.Geometry.safeDivideFraction(this.direction.dotProductStartEnd(this.origin,t),this.direction.magnitudeSquared(),0)}projectPointToRay(t){return this.origin.plusScaled(this.direction,this.pointToFraction(t))}toRigidZFrame(){const t=s.Matrix3d.createRigidHeadsUp(this.direction,o.AxisOrder.ZXY);return n.Transform.createOriginAndMatrix(this.origin,t)}setFromJSON(t){if(!t)return this.origin.set(0,0,0),void this.direction.set(0,0,1);this.origin.setFromJSON(t.origin),this.direction.setFromJSON(t.direction)}trySetDirectionMagnitudeInPlace(t=1){return this.direction.tryNormalizeInPlace()?(this.direction.scaleInPlace(t),!0):(this.direction.setZero(),this.a=0,!1)}tryNormalizeInPlaceWithAreaWeight(t){const e=o.Geometry.smallMetricDistanceSquared;return this.a=t,!!(Math.abs(t)>e&&this.direction.tryNormalizeInPlace(e))||(this.direction.setZero(),this.a=0,!1)}toJSON(){return{origin:this.origin.toJSON(),direction:this.direction.toJSON()}}static fromJSON(t){const e=Ray3d.createXAxis();return e.setFromJSON(t),e}distance(t){const e=this.direction.magnitudeSquared(),r=this.dotProductToPoint(t),i=o.Geometry.inverseMetricDistanceSquared(e);return i?Math.sqrt(this.origin.distanceSquared(t)-r*r*i):Math.sqrt(this.origin.distanceSquared(t))}intersectionWithPlane(t,e){const r=i.Vector3d.createStartEnd(t.getOriginRef(),this.origin),n=this.direction.dotProduct(t.getNormalRef()),s=r.dotProduct(t.getNormalRef()),a=o.Geometry.conditionalDivideFraction(-s,n);if(void 0!==a)return e&&this.origin.plusScaled(this.direction,a,e),a}intersectionWithRange3d(t,e){if(t.isNull)return d.Range1d.createNull(e);const r=d.Range1d.createXX(-o.Geometry.largeCoordinateResult,o.Geometry.largeCoordinateResult,e);return r.clipLinearMapToInterval(this.origin.x,this.direction.x,t.low.x,t.high.x)&&r.clipLinearMapToInterval(this.origin.y,this.direction.y,t.low.y,t.high.y)&&r.clipLinearMapToInterval(this.origin.z,this.direction.z,t.low.z,t.high.z),r}perpendicularPartOfVectorToTarget(t,e){const r=i.Vector3d.createStartEnd(this.origin,t),n=this.direction.magnitudeSquared(),s=this.direction.dotProductStartEnd(this.origin,t),a=o.Geometry.safeDivideFraction(s,n,0);return r.plusScaled(this.direction,-a,e)}static closestApproachRay3dRay3d(t,e){const r=l.Vector2d.create();let i,n,s,o,d;c.SmallSystem.ray3dXYZUVWClosestApproachUnbounded(t.origin.x,t.origin.y,t.origin.z,t.direction.x,t.direction.y,t.direction.z,e.origin.x,e.origin.y,e.origin.z,e.direction.x,e.direction.y,e.direction.z,r)?(i=r.x,n=r.y,s=t.fractionToPoint(i),o=e.fractionToPoint(n),d=s.isAlmostEqualMetric(o)?a.CurveCurveApproachType.Intersection:a.CurveCurveApproachType.PerpendicularChord):(n=0,i=t.pointToFraction(e.origin),s=t.fractionToPoint(i),o=e.fractionToPoint(n),d=s.isAlmostEqualMetric(o)?a.CurveCurveApproachType.CoincidentGeometry:a.CurveCurveApproachType.ParallelGeometry);const h=a.CurveLocationDetailPair.createCapture(a.CurveLocationDetail.createRayFractionPoint(t,i,t.fractionToPoint(i)),a.CurveLocationDetail.createRayFractionPoint(e,n,e.fractionToPoint(n)));return h.approachType=d,h}}e.Ray3d=Ray3d},"./lib/geometry3d/Segment1d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js");class Segment1d{constructor(t,e){this.x0=t,this.x1=e}set(t,e){this.x0=t,this.x1=e}shift(t){this.x0+=t,this.x1+=t}static create(t=0,e=1,r){return r?(r.set(t,e),r):new Segment1d(t,e)}setFrom(t){this.x0=t.x0,this.x1=t.x1}clone(){return new Segment1d(this.x0,this.x1)}get isIn01(){return i.Geometry.isIn01(this.x0)&&i.Geometry.isIn01(this.x1)}fractionToPoint(t){return i.Geometry.interpolate(this.x0,t,this.x1)}signedDelta(){return this.x1-this.x0}reverseInPlace(){const t=this.x0;this.x0=this.x1,this.x1=t}isAlmostEqual(t){return i.Geometry.isSameCoordinate(this.x0,t.x0)&&i.Geometry.isSameCoordinate(this.x1,t.x1)}get isExact01(){return 0===this.x0&&1===this.x1}get isExact01Reversed(){return 1===this.x0&&0===this.x1}clipBy01FunctionValuesPositive(t,e){const r=e-t,i=t+this.x0*r,n=t+this.x1*r,s=n-i;if(i>0){if(n>=0)return!0;const t=-i/s;return this.x1=this.x0+t*(this.x1-this.x0),!0}if(i<0){if(n<0)return!1;const t=-i/s;return this.x0=this.x0+t*(this.x1-this.x0),!0}return n>0}}e.Segment1d=Segment1d},"./lib/geometry3d/Transform.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry4d/Point4d.js"),s=r("./lib/geometry3d/Range.js"),o=r("./lib/geometry3d/Point2dVector2d.js"),a=r("./lib/geometry3d/Point3dVector3d.js"),c=r("./lib/geometry3d/Matrix3d.js");class Transform{constructor(t,e){this._origin=t,this._matrix=e}static get identity(){return void 0===this._identity&&(this._identity=Transform.createIdentity(),this._identity.freeze()),this._identity}freeze(){Object.freeze(this),Object.freeze(this._origin),this._matrix.freeze()}setFrom(t){this._origin.setFrom(t._origin),this._matrix.setFrom(t._matrix)}setIdentity(){this._origin.setZero(),this._matrix.setIdentity()}setFromJSON(t){if(t){if(t instanceof Object&&t.origin&&t.matrix)return this._origin.setFromJSON(t.origin),void this._matrix.setFromJSON(t.matrix);if(i.Geometry.isArrayOfNumberArray(t,3,4)){const e=t;return this._matrix.setRowValues(e[0][0],e[0][1],e[0][2],e[1][0],e[1][1],e[1][2],e[2][0],e[2][1],e[2][2]),void this._origin.set(e[0][3],e[1][3],e[2][3])}if(i.Geometry.isNumberArray(t,12)){const e=t;return this._matrix.setRowValues(e[0],e[1],e[2],e[4],e[5],e[6],e[8],e[9],e[10]),void this._origin.set(e[3],e[7],e[11])}}this.setIdentity()}isAlmostEqual(t){return this._origin.isAlmostEqual(t._origin)&&this._matrix.isAlmostEqual(t._matrix)}toJSON(){return[[this._matrix.coffs[0],this._matrix.coffs[1],this._matrix.coffs[2],this._origin.x],[this._matrix.coffs[3],this._matrix.coffs[4],this._matrix.coffs[5],this._origin.y],[this._matrix.coffs[6],this._matrix.coffs[7],this._matrix.coffs[8],this._origin.z]]}static fromJSON(t){const e=Transform.createIdentity();return e.setFromJSON(t),e}clone(t){return t?(t._matrix.setFrom(this._matrix),t._origin.setFrom(this._origin),t):new Transform(a.Point3d.createFrom(this._origin),this._matrix.clone())}cloneRigid(t=i.AxisOrder.XYZ){const e=c.Matrix3d.createRigidFromMatrix3d(this.matrix,t);if(e)return new Transform(this.origin.cloneAsPoint3d(),e)}static createRefs(t,e,r){return r?(r._origin=t,r._matrix=e,r):new Transform(t,e)}static createRowValues(t,e,r,i,n,s,o,l,d,h,u,f,g){return g?(g._origin.set(i,l,f),g._matrix.setRowValues(t,e,r,n,s,o,d,h,u),g):new Transform(a.Point3d.create(i,l,f),c.Matrix3d.createRowValues(t,e,r,n,s,o,d,h,u))}static createZero(t){return Transform.createRowValues(0,0,0,0,0,0,0,0,0,0,0,0,t)}static createTranslationXYZ(t=0,e=0,r=0,i){return Transform.createRefs(a.Vector3d.create(t,e,r),c.Matrix3d.createIdentity(),i)}static createTranslation(t,e){return Transform.createRefs(t,c.Matrix3d.createIdentity(),e)}get matrix(){return this._matrix}get origin(){return this._origin}getOrigin(){return a.Point3d.createFrom(this._origin)}getTranslation(){return a.Vector3d.createFrom(this._origin)}get isIdentity(){return this._matrix.isIdentity&&this._origin.isAlmostZero}static createIdentity(t){return t?(t._origin.setZero(),t._matrix.setIdentity(),t):Transform.createRefs(a.Point3d.createZero(),c.Matrix3d.createIdentity())}static createOriginAndMatrix(t,e,r){return Transform.createRefs(t?t.cloneAsPoint3d():a.Point3d.createZero(),void 0===e?c.Matrix3d.createIdentity():e.clone(),r)}static createOriginAndMatrixColumns(t,e,r,i,n){return n?n.setOriginAndMatrixColumns(t,e,r,i):n=Transform.createRefs(a.Vector3d.createFrom(t),c.Matrix3d.createColumns(e,r,i)),n}setOriginAndMatrixColumns(t,e,r,i){void 0!==t&&this._origin.setFrom(t),this._matrix.setColumns(e,r,i)}static createFixedPointAndMatrix(t,e,r){const i=c.Matrix3d.xyzMinusMatrixTimesXYZ(t,e,t);return Transform.createRefs(i,e.clone(),r)}static createMatrixPickupPutdown(t,e,r,i){const n=c.Matrix3d.xyzMinusMatrixTimesXYZ(r,t,e);return Transform.createRefs(n,t.clone(),i)}static createScaleAboutPoint(t,e,r){const i=c.Matrix3d.createScale(e,e,e),n=c.Matrix3d.xyzMinusMatrixTimesXYZ(t,i,t);return Transform.createRefs(n,i,r)}multiplyPoint2d(t,e){return c.Matrix3d.xyPlusMatrixTimesXY(this._origin,this._matrix,t,e)}multiplyPoint3d(t,e){return c.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t,e)}multiplyXYAndZInPlace(t){return c.Matrix3d.xyzPlusMatrixTimesXYZInPlace(this._origin,this._matrix,t)}multiplyXYZ(t,e,r=0,i){return c.Matrix3d.xyzPlusMatrixTimesCoordinates(this._origin,this._matrix,t,e,r,i)}multiplyComponentXYZ(t,e,r,i=0){const n=this._matrix.coffs,s=3*t;return this.origin.at(t)+n[s]*e+n[s+1]*r+n[s+2]*i}multiplyComponentXYZW(t,e,r,i,n){const s=this._matrix.coffs,o=3*t;return this.origin.at(t)*n+s[o]*e+s[o+1]*r+s[o+2]*i}multiplyXYZW(t,e,r,i,n){return c.Matrix3d.xyzPlusMatrixTimesWeightedCoordinates(this._origin,this._matrix,t,e,r,i,n)}multiplyXYZWToFloat64Array(t,e,r,i,n){return c.Matrix3d.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin,this._matrix,t,e,r,i,n)}multiplyXYZToFloat64Array(t,e,r,i){return c.Matrix3d.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin,this._matrix,t,e,r,i)}multiplyTransposeXYZW(t,e,r,i,s){const o=this._matrix.coffs,a=this._origin;return n.Point4d.create(t*o[0]+e*o[3]+r*o[6],t*o[1]+e*o[4]+r*o[7],t*o[2]+e*o[5]+r*o[8],t*a.x+e*a.y+r*a.z+i,s)}multiplyPoint3dArrayInPlace(t){let e;for(e of t)c.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,e,e)}multiplyPoint3dArrayArrayInPlace(t){for(const e of t)this.multiplyPoint3dArrayInPlace(e)}multiplyInversePoint3d(t,e){return this._matrix.multiplyInverseXYZAsPoint3d(t.x-this._origin.x,t.y-this._origin.y,t.z-this._origin.z,e)}multiplyInverseXYZ(t,e,r,i){return this._matrix.multiplyInverseXYZAsPoint3d(t-this._origin.x,e-this._origin.y,r-this._origin.z,i)}multiplyInversePoint3dArray(t,e){if(!this._matrix.computeCachedInverse(!0))return;const r=this.origin.x,i=this.origin.y,n=this.origin.z;if(e){const s=Transform.matchArrayLengths(t,e,a.Point3d.createZero);for(let o=0;o<s;o++)this._matrix.multiplyInverseXYZAsPoint3d(t[o].x-r,t[o].y-i,t[o].z-n,e[o])}e=[];for(const s of t)e.push(this._matrix.multiplyInverseXYZAsPoint3d(s.x-r,s.y-i,s.z-n));return e}multiplyInversePoint3dArrayInPlace(t){if(!this._matrix.computeCachedInverse(!0))return!1;const e=this.origin.x,r=this.origin.y,i=this.origin.z,n=t.length;for(let s=0;s<n;s++)this._matrix.multiplyInverseXYZAsPoint3d(t[s].x-e,t[s].y-r,t[s].z-i,t[s]);return!0}computeCachedInverse(t=!0){return this._matrix.computeCachedInverse(t)}static matchArrayLengths(t,e,r){const i=t.length,n=e.length;if(i>n)for(let s=n;s<i;s++)e.push(r());else n>i&&(e.length=i);return i}multiplyPoint2dArray(t,e){if(e){const r=Transform.matchArrayLengths(t,e,o.Point2d.createZero);for(let i=0;i<r;i++)c.Matrix3d.xyPlusMatrixTimesXY(this._origin,this._matrix,t[i],e[i]);return e}e=[];for(const r of t)e.push(c.Matrix3d.xyPlusMatrixTimesXY(this._origin,this._matrix,r));return e}multiplyPoint3dArray(t,e){if(e){const r=Transform.matchArrayLengths(t,e,a.Point3d.createZero);for(let i=0;i<r;i++)c.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t[i],e[i]);return e}e=[];for(const r of t)e.push(c.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,r));return e}multiplyVector(t,e){return this._matrix.multiplyVector(t,e)}multiplyVectorXYZ(t,e,r,i){return this._matrix.multiplyXYZ(t,e,r,i)}multiplyTransformTransform(t,e){return e?(e.setMultiplyTransformTransform(this,t),e):Transform.createRefs(c.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t._origin),this._matrix.multiplyMatrixMatrix(t._matrix))}setMultiplyTransformTransform(t,e){void 0===Transform._scratchPoint&&(Transform._scratchPoint=a.Point3d.create()),c.Matrix3d.xyzPlusMatrixTimesXYZ(t._origin,t._matrix,e._origin,Transform._scratchPoint),this._origin.setFrom(Transform._scratchPoint),t._matrix.multiplyMatrixMatrix(e._matrix,this._matrix)}multiplyTransformMatrix3d(t,e){return e?(this._matrix.multiplyMatrixMatrix(t,e._matrix),e._origin.setFrom(this._origin),e):Transform.createRefs(this._origin.cloneAsPoint3d(),this._matrix.multiplyMatrixMatrix(t))}multiplyRange(t,e){if(t.isNull)return t.clone(e);const r=t.low.x,i=t.low.y,n=t.low.z,o=t.high.x,a=t.high.y,c=t.high.z;return(e=s.Range3d.createNull(e)).extendTransformedXYZ(this,r,i,n),e.extendTransformedXYZ(this,o,i,n),e.extendTransformedXYZ(this,r,a,n),e.extendTransformedXYZ(this,o,a,n),e.extendTransformedXYZ(this,r,i,c),e.extendTransformedXYZ(this,o,i,c),e.extendTransformedXYZ(this,r,a,c),e.extendTransformedXYZ(this,o,a,c),e}inverse(){const t=this._matrix.inverse();if(t)return Transform.createRefs(t.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z),t)}static initFromRange(t,e,r,i){const n=e.minus(t);0===n.x&&(n.x=1),0===n.y&&(n.y=1),0===n.z&&(n.z=1);const s=new c.Matrix3d;if(r&&(c.Matrix3d.createScale(n.x,n.y,n.z,s),Transform.createOriginAndMatrix(t,s,r)),i){const e=new a.Point3d(-t.x/n.x,-t.y/n.y,-t.z/n.z);c.Matrix3d.createScale(1/n.x,1/n.y,1/n.z,s),Transform.createOriginAndMatrix(e,s,i)}}}e.Transform=Transform},"./lib/geometry3d/YawPitchRollAngles.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Angle.js"),s=r("./lib/geometry3d/Matrix3d.js"),o=r("./lib/geometry3d/Point3dVector3d.js");class YawPitchRollAngles{constructor(t=n.Angle.zero(),e=n.Angle.zero(),r=n.Angle.zero()){this.yaw=t,this.pitch=e,this.roll=r}freeze(){Object.freeze(this.yaw),Object.freeze(this.pitch),Object.freeze(this.roll)}static createDegrees(t,e,r){return new YawPitchRollAngles(n.Angle.createDegrees(t),n.Angle.createDegrees(e),n.Angle.createDegrees(r))}static createRadians(t,e,r){return new YawPitchRollAngles(n.Angle.createRadians(t),n.Angle.createRadians(e),n.Angle.createRadians(r))}static fromJSON(t){return t=t||{},new YawPitchRollAngles(n.Angle.fromJSON(t.yaw),n.Angle.fromJSON(t.pitch),n.Angle.fromJSON(t.roll))}setFromJSON(t){t=t||{},this.yaw=n.Angle.fromJSON(t.yaw),this.pitch=n.Angle.fromJSON(t.pitch),this.roll=n.Angle.fromJSON(t.roll)}toJSON(){const t={};return this.pitch.isAlmostZero||(t.pitch=this.pitch.toJSON()),this.roll.isAlmostZero||(t.roll=this.roll.toJSON()),this.yaw.isAlmostZero||(t.yaw=this.yaw.toJSON()),t}setFrom(t){this.yaw.setFrom(t.yaw),this.pitch.setFrom(t.pitch),this.roll.setFrom(t.roll)}isAlmostEqual(t){return this.yaw.isAlmostEqualAllowPeriodShift(t.yaw)&&this.pitch.isAlmostEqualAllowPeriodShift(t.pitch)&&this.roll.isAlmostEqualAllowPeriodShift(t.roll)}clone(){return new YawPitchRollAngles(this.yaw.clone(),this.pitch.clone(),this.roll.clone())}toMatrix3d(t){const e=Math.cos(this.yaw.radians),r=Math.sin(this.yaw.radians),i=Math.cos(this.pitch.radians),n=Math.sin(this.pitch.radians),o=Math.cos(this.roll.radians),a=Math.sin(this.roll.radians);return s.Matrix3d.createRowValues(e*i,-(r*o+e*n*a),r*a-e*n*o,r*i,e*o-r*n*a,-(e*a+r*n*o),n,i*a,i*o,t)}maxAbsRadians(){return i.Geometry.maxAbsXYZ(this.yaw.radians,this.pitch.radians,this.roll.radians)}sumSquaredRadians(){return i.Geometry.hypotenuseSquaredXYZ(this.yaw.radians,this.pitch.radians,this.roll.radians)}isIdentity(t=!0){return t?n.Angle.isAlmostEqualRadiansAllowPeriodShift(0,this.yaw.radians)&&n.Angle.isAlmostEqualRadiansAllowPeriodShift(0,this.pitch.radians)&&n.Angle.isAlmostEqualRadiansAllowPeriodShift(0,this.roll.radians):n.Angle.isAlmostEqualRadiansNoPeriodShift(0,this.yaw.radians)&&n.Angle.isAlmostEqualRadiansNoPeriodShift(0,this.pitch.radians)&&n.Angle.isAlmostEqualRadiansNoPeriodShift(0,this.roll.radians)}maxDiffRadians(t){return Math.max(this.yaw.radians-t.yaw.radians,this.pitch.radians-t.pitch.radians,this.roll.radians-t.roll.radians)}maxAbsDegrees(){return i.Geometry.maxAbsXYZ(this.yaw.degrees,this.pitch.degrees,this.roll.degrees)}sumSquaredDegrees(){return i.Geometry.hypotenuseSquaredXYZ(this.yaw.degrees,this.pitch.degrees,this.roll.degrees)}static tryFromTransform(t){return{angles:YawPitchRollAngles.createFromMatrix3d(t.matrix),origin:o.Point3d.createFrom(t.origin)}}static createFromMatrix3d(t,e){const r=t.at(2,0),s=Math.sqrt(t.at(2,1)*t.at(2,1)+t.at(2,2)*t.at(2,2)),o=n.Angle.createAtan2(r,s),a=n.Angle.createAtan2(r,-s),c=e||new YawPitchRollAngles;if(s<i.Geometry.smallAngleRadians)c.yaw=n.Angle.createAtan2(-t.at(0,1),t.at(1,1)),c.pitch=o,c.roll=n.Angle.createRadians(0);else{const e=n.Angle.createAtan2(t.at(1,0),t.at(0,0)),r=n.Angle.createAtan2(t.at(2,1),t.at(2,2)),i=n.Angle.createAtan2(-t.at(1,0),-t.at(0,0)),s=n.Angle.createAtan2(-t.at(2,1),-t.at(2,2)),l=new YawPitchRollAngles(e,o,r),d=new YawPitchRollAngles(i,a,s),h=.95,u=l.maxAbsRadians(),f=d.maxAbsRadians();if(u<h*f)c.setFrom(l);else if(f<h*u)c.setFrom(d);else{l.sumSquaredRadians()<=d.sumSquaredRadians()?c.setFrom(l):c.setFrom(d)}}const l=c.toMatrix3d();return t.maxDiff(l)<i.Geometry.smallAngleRadians?c:void 0}}e.YawPitchRollAngles=YawPitchRollAngles},"./lib/geometry4d/Map4d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Transform.js"),n=r("./lib/geometry3d/Matrix3d.js"),s=r("./lib/geometry4d/Matrix4d.js");class Map4d{constructor(t,e){this._matrix0=t,this._matrix1=e}get transform0(){return this._matrix0}get transform1(){return this._matrix1}static createRefs(t,e){return new Map4d(t,e)}static createIdentity(){return new Map4d(s.Matrix4d.createIdentity(),s.Matrix4d.createIdentity())}static createTransform(t,e){if(void 0===e){if(void 0===(e=t.inverse()))return}else{if(!t.multiplyTransformTransform(e).isIdentity)return}return new Map4d(s.Matrix4d.createTransform(t),s.Matrix4d.createTransform(e))}static createBoxMap(t,e,r,i,n){const o=s.Matrix4d.createBoxToBox(t,e,r,i,n?n.transform0:void 0),a=s.Matrix4d.createBoxToBox(r,i,t,e,n?n.transform1:void 0);if(o&&a)return n||new Map4d(o,a)}setFrom(t){this._matrix0.setFrom(t._matrix0),this._matrix1.setFrom(t._matrix1)}clone(){return new Map4d(this._matrix0.clone(),this._matrix1.clone())}setIdentity(){this._matrix0.setIdentity(),this._matrix1.setIdentity()}setFromJSON(t){t.matrix0&&t.matrix1?(this._matrix0.setFromJSON(t.matrix0),this._matrix1.setFromJSON(t.matrix1)):this.setIdentity()}static fromJSON(t){const e=new Map4d(s.Matrix4d.createIdentity(),s.Matrix4d.createIdentity());return e.setFromJSON(t),e}toJSON(){return{matrix0:this._matrix0.toJSON(),matrix1:this._matrix1.toJSON()}}isAlmostEqual(t){return this._matrix0.isAlmostEqual(t._matrix0)&&this._matrix1.isAlmostEqual(t._matrix1)}static createVectorFrustum(t,e,r,o,a){a=Math.max(a,1e-8);const c=i.Transform.createOriginAndMatrix(t,n.Matrix3d.createColumns(e,r,o)),l=c.inverse();if(!l)return;const d=new Map4d(s.Matrix4d.createTransform(l),s.Matrix4d.createTransform(c));return new Map4d(s.Matrix4d.createRowValues(1,0,0,0,0,1,0,0,0,0,a,0,0,0,a-1,1),s.Matrix4d.createRowValues(1,0,0,0,0,1,0,0,0,0,1/a,0,0,0,(1-a)/a,1)).multiplyMapMap(d)}multiplyMapMap(t){return new Map4d(this._matrix0.multiplyMatrixMatrix(t._matrix0),t._matrix1.multiplyMatrixMatrix(this._matrix1))}reverseInPlace(){const t=this._matrix0;this._matrix0=this._matrix1,this._matrix1=t}sandwich0This1(t){return new Map4d(t._matrix0.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(t._matrix1)),t._matrix0.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(t._matrix1)))}sandwich1This0(t){return new Map4d(t._matrix1.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(t._matrix0)),t._matrix1.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(t._matrix0)))}}e.Map4d=Map4d},"./lib/geometry4d/Matrix4d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/Transform.js"),o=r("./lib/geometry3d/Matrix3d.js"),a=r("./lib/geometry4d/Point4d.js");class Matrix4d{constructor(){this._coffs=new Float64Array(16)}setFrom(t){for(let e=0;e<16;e++)this._coffs[e]=t._coffs[e]}clone(t){if(t===this)return this;void 0===t&&(t=new Matrix4d);for(let e=0;e<16;e++)t._coffs[e]=this._coffs[e];return t}setZero(){for(let t=0;t<16;t++)this._coffs[t]=0}setIdentity(){for(let t=0;t<16;t++)this._coffs[t]=0;this._coffs[0]=this._coffs[5]=this._coffs[10]=this._coffs[15]=1}static is1000(t,e,r,i,n){return Math.abs(t-1)<=n&&Math.abs(e)<=n&&Math.abs(r)<=n&&Math.abs(i)<=n}isIdentity(t=1e-10){return Matrix4d.is1000(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],t)&&Matrix4d.is1000(this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[4],t)&&Matrix4d.is1000(this._coffs[10],this._coffs[11],this._coffs[8],this._coffs[9],t)&&Matrix4d.is1000(this._coffs[15],this._coffs[12],this._coffs[13],this._coffs[14],t)}static createZero(t){return t?(t.setZero(),t):new Matrix4d}static createRowValues(t,e,r,i,n,s,o,a,c,l,d,h,u,f,g,p,m){return(m=m||new Matrix4d)._coffs[0]=t,m._coffs[1]=e,m._coffs[2]=r,m._coffs[3]=i,m._coffs[4]=n,m._coffs[5]=s,m._coffs[6]=o,m._coffs[7]=a,m._coffs[8]=c,m._coffs[9]=l,m._coffs[10]=d,m._coffs[11]=h,m._coffs[12]=u,m._coffs[13]=f,m._coffs[14]=g,m._coffs[15]=p,m}static createRows(t,e,r,i,n){return this.createRowValues(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,r.x,r.y,r.z,r.w,i.x,i.y,i.z,i.w,n)}setOriginAndVectors(t,e,r,i){this._coffs[0]=e.x,this._coffs[1]=r.x,this._coffs[2]=i.x,this._coffs[3]=t.x,this._coffs[4]=e.y,this._coffs[5]=r.y,this._coffs[6]=i.y,this._coffs[7]=t.y,this._coffs[8]=e.z,this._coffs[9]=r.z,this._coffs[10]=i.z,this._coffs[11]=t.z,this._coffs[12]=0,this._coffs[13]=0,this._coffs[14]=0,this._coffs[15]=1}static createTransform(t,e){const r=t.matrix,i=t.origin;return Matrix4d.createRowValues(r.coffs[0],r.coffs[1],r.coffs[2],i.x,r.coffs[3],r.coffs[4],r.coffs[5],i.y,r.coffs[6],r.coffs[7],r.coffs[8],i.z,0,0,0,1,e)}static createIdentity(t){return(t=Matrix4d.createZero(t))._coffs[0]=1,t._coffs[5]=1,t._coffs[10]=1,t._coffs[15]=1,t}static createTranslationXYZ(t,e,r,i){return(i=Matrix4d.createZero(i))._coffs[0]=1,i._coffs[5]=1,i._coffs[10]=1,i._coffs[15]=1,i._coffs[3]=t,i._coffs[7]=e,i._coffs[11]=r,i}plusScaled(t,e,r){r=this.clone(r);for(let i=0;i<16;i++)r._coffs[i]+=e*t._coffs[i];return r}static createTranslationAndScaleXYZ(t,e,r,i,n,s,o){return Matrix4d.createRowValues(i,0,0,t,0,n,0,e,0,0,s,r,0,0,0,1,o)}static createBoxToBox(t,e,r,n,s){const o=e.x-t.x,a=e.y-t.y,c=e.z-t.z,l=n.x-r.x,d=n.y-r.y,h=n.z-r.z,u=i.Geometry.conditionalDivideFraction(l,o),f=i.Geometry.conditionalDivideFraction(d,a),g=i.Geometry.conditionalDivideFraction(h,c);if(void 0!==u&&void 0!==f&&void 0!==g)return Matrix4d.createTranslationAndScaleXYZ(r.x-u*t.x,r.y-f*t.y,r.z-g*t.z,u,f,g,s)}setFromJSON(t){if(i.Geometry.isArrayOfNumberArray(t,4,4))for(let e=0;e<4;++e)for(let r=0;r<4;++r)this._coffs[4*e+r]=t[e][r];else this.setZero()}maxDiff(t){let e=0;for(let r=0;r<16;r++)e=Math.max(e,Math.abs(this._coffs[r]-t._coffs[r]));return e}maxAbs(){let t=0;for(let e=0;e<16;e++)t=Math.max(t,Math.abs(this._coffs[e]));return t}isAlmostEqual(t){return i.Geometry.isSmallMetricDistance(this.maxDiff(t))}toJSON(){const t=[];for(let e=0;e<4;++e){const r=4*e;t.push([this._coffs[r],this._coffs[r+1],this._coffs[r+2],this._coffs[r+3]])}return t}static fromJSON(t){const e=new Matrix4d;return e.setFromJSON(t),e}getSteppedPoint(t,e,r){return a.Point4d.create(this._coffs[t],this._coffs[t+e],this._coffs[t+2*e],this._coffs[t+3*e],r)}columnX(){return this.getSteppedPoint(0,4)}columnY(){return this.getSteppedPoint(1,4)}columnZ(){return this.getSteppedPoint(2,4)}columnW(){return this.getSteppedPoint(3,4)}rowX(){return this.getSteppedPoint(0,1)}rowY(){return this.getSteppedPoint(4,1)}rowZ(){return this.getSteppedPoint(8,1)}rowW(){return this.getSteppedPoint(12,1)}get hasPerspective(){return 0!==this._coffs[12]||0!==this._coffs[13]||0!==this._coffs[14]||1!==this._coffs[15]}diagonal(){return this.getSteppedPoint(0,5)}weight(){return this._coffs[15]}matrixPart(){return o.Matrix3d.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[8],this._coffs[9],this._coffs[10])}get asTransform(){if(!this.hasPerspective)return s.Transform.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11])}multiplyMatrixMatrix(t,e){e=e&&e!==this&&e!==t?e:new Matrix4d;for(let r=0;r<16;r+=4)for(let i=0;i<4;i++)e._coffs[r+i]=this._coffs[r]*t._coffs[i]+this._coffs[r+1]*t._coffs[i+4]+this._coffs[r+2]*t._coffs[i+8]+this._coffs[r+3]*t._coffs[i+12];return e}multiplyMatrixMatrixTranspose(t,e){e=e&&e!==this&&e!==t?e:new Matrix4d;let r=0;for(let i=0;i<16;i+=4)for(let n=0;n<16;n+=4)e._coffs[r++]=this._coffs[i]*t._coffs[n]+this._coffs[i+1]*t._coffs[n+1]+this._coffs[i+2]*t._coffs[n+2]+this._coffs[i+3]*t._coffs[n+3];return e}multiplyMatrixTransposeMatrix(t,e){e=e&&e!==this&&e!==t?e:new Matrix4d;let r=0;for(let i=0;i<4;i+=1)for(let n=0;n<4;n+=1)e._coffs[r++]=this._coffs[i]*t._coffs[n]+this._coffs[i+4]*t._coffs[n+4]+this._coffs[i+8]*t._coffs[n+8]+this._coffs[i+12]*t._coffs[n+12];return e}cloneTransposed(t){return Matrix4d.createRowValues(this._coffs[0],this._coffs[4],this._coffs[8],this._coffs[12],this._coffs[1],this._coffs[5],this._coffs[9],this._coffs[13],this._coffs[2],this._coffs[6],this._coffs[10],this._coffs[14],this._coffs[3],this._coffs[7],this._coffs[11],this._coffs[15],t)}multiplyXYZW(t,e,r,i,n){return(n=n||a.Point4d.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*r+this._coffs[3]*i,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*r+this._coffs[7]*i,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*r+this._coffs[11]*i,this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*r+this._coffs[15]*i)}multiplyBlockedFloat64ArrayInPlace(t){const e=t.length;let r,i,n,s;for(let o=0;o+3<e;o+=4)r=t[o],i=t[o+1],n=t[o+2],s=t[o+3],t[o]=this._coffs[0]*r+this._coffs[1]*i+this._coffs[2]*n+this._coffs[3]*s,t[o+1]=this._coffs[4]*r+this._coffs[5]*i+this._coffs[6]*n+this._coffs[7]*s,t[o+2]=this._coffs[8]*r+this._coffs[9]*i+this._coffs[10]*n+this._coffs[11]*s,t[o+3]=this._coffs[12]*r+this._coffs[13]*i+this._coffs[14]*n+this._coffs[15]*s}multiplyPoint3d(t,e,r){return this.multiplyXYZW(t.x,t.y,t.z,e,r)}multiplyPoint3dArray(t,e,r=1){t.forEach((t,i)=>{e[i]=this.multiplyXYZW(t.x,t.y,t.z,r,e[i])})}multiplyTransposeXYZW(t,e,r,i,n){return(n=n||a.Point4d.createZero()).set(this._coffs[0]*t+this._coffs[4]*e+this._coffs[8]*r+this._coffs[12]*i,this._coffs[1]*t+this._coffs[5]*e+this._coffs[9]*r+this._coffs[13]*i,this._coffs[2]*t+this._coffs[6]*e+this._coffs[10]*r+this._coffs[14]*i,this._coffs[3]*t+this._coffs[7]*e+this._coffs[11]*r+this._coffs[15]*i)}rowDotColumn(t,e,r){const i=4*t,n=r;return this._coffs[i]*e._coffs[n]+this._coffs[i+1]*e._coffs[n+4]+this._coffs[i+2]*e._coffs[n+8]+this._coffs[i+3]*e._coffs[n+12]}rowDotRow(t,e,r){const i=4*t,n=4*r;return this._coffs[i]*e._coffs[n]+this._coffs[i+1]*e._coffs[n+1]+this._coffs[i+2]*e._coffs[n+2]+this._coffs[i+3]*e._coffs[n+3]}columnDotColumn(t,e,r){const i=t,n=r;return this._coffs[i]*e._coffs[n]+this._coffs[i+4]*e._coffs[n+4]+this._coffs[i+8]*e._coffs[n+8]+this._coffs[i+12]*e._coffs[n+12]}columnDotRow(t,e,r){const i=t,n=4*r;return this._coffs[i]*e._coffs[n]+this._coffs[i+4]*e._coffs[n+1]+this._coffs[i+8]*e._coffs[n+2]+this._coffs[i+12]*e._coffs[n+3]}atIJ(t,e){return this._coffs[4*t+e]}setAtIJ(t,e,r){this._coffs[4*t+e]=r}multiplyXYZWQuietRenormalize(t,e,r,s,o){(o=o||n.Point3d.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*r+this._coffs[3]*s,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*r+this._coffs[7]*s,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*r+this._coffs[11]*s);const a=this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*r+this._coffs[15]*s,c=i.Geometry.conditionalDivideCoordinate(o.x,a),l=i.Geometry.conditionalDivideCoordinate(o.y,a),d=i.Geometry.conditionalDivideCoordinate(o.z,a);return void 0!==c&&void 0!==l&&void 0!==d&&(o.x=c,o.y=l,o.z=d),o}multiplyPoint4dArrayQuietRenormalize(t,e){t.forEach((t,r)=>{e[r]=this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,t.w,e[r])})}multiplyPoint4d(t,e){return this.multiplyXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyTransposePoint4d(t,e){return this.multiplyTransposeXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyPoint3dQuietNormalize(t,e){return this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,e)}multiplyPoint3dArrayQuietNormalize(t){t.forEach(t=>this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,t))}addMomentsInPlace(t,e,r,i){this._coffs[0]+=t*t,this._coffs[1]+=t*e,this._coffs[2]+=t*r,this._coffs[3]+=t*i,this._coffs[4]+=e*t,this._coffs[5]+=e*e,this._coffs[6]+=e*r,this._coffs[7]+=e*i,this._coffs[8]+=r*t,this._coffs[9]+=r*e,this._coffs[10]+=r*r,this._coffs[11]+=r*i,this._coffs[12]+=i*t,this._coffs[13]+=i*e,this._coffs[14]+=i*r,this._coffs[15]+=i*i}addScaledInPlace(t,e=1){for(let r=0;r<16;r++)this._coffs[r]+=e*t._coffs[r]}rowOperation(t,e,r,i){if(0===i)return;let n=4*t+r,s=4*e+r;for(let o=r;o<4;o++,n++,s++)this._coffs[s]+=i*this._coffs[n]}determinant(){const t=this._coffs;return i.Geometry.determinant4x4(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])}createInverse(t){const e=this.maxAbs();if(0===e)return;const r=1/e,n=this.columnX(),s=this.columnY(),o=this.columnZ(),c=this.columnW();n.scale(r,n),s.scale(r,s),o.scale(r,o),c.scale(r,c);const l=a.Point4d.perpendicularPoint4dPlane(s,o,c),d=a.Point4d.perpendicularPoint4dPlane(n,c,o),h=a.Point4d.perpendicularPoint4dPlane(c,n,s),u=a.Point4d.perpendicularPoint4dPlane(o,s,n);t=Matrix4d.createRows(l,d,h,u,t);const f=l.dotProduct(n),g=d.dotProduct(s),p=h.dotProduct(o),m=u.dotProduct(c),y=t.maxAbs();if(f*g>0&&f*p>0&&f*m>0){if(void 0!==i.Geometry.conditionalDivideCoordinate(y,f)){const e=r/f;return t.scaleRowsInPlace(e,e,e,e),t}}}rowArrays(t){return t?[[t(this._coffs[0]),t(this._coffs[1]),t(this._coffs[2]),t(this._coffs[3])],[t(this._coffs[4]),t(this._coffs[5]),t(this._coffs[6]),t(this._coffs[7])],[t(this._coffs[8]),t(this._coffs[9]),t(this._coffs[10]),t(this._coffs[11])],[t(this._coffs[12]),t(this._coffs[13]),t(this._coffs[14]),t(this._coffs[15])]]:[[this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3]],[this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7]],[this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11]],[this._coffs[12],this._coffs[13],this._coffs[14],this._coffs[15]]]}scaleRowsInPlace(t,e,r,i){for(let n=0;n<4;n++)this._coffs[n]*=t;for(let n=4;n<8;n++)this._coffs[n]*=e;for(let n=8;n<12;n++)this._coffs[n]*=r;for(let n=12;n<16;n++)this._coffs[n]*=i}addScaledOuterProductInPlace(t,e,r){let i=t.x*r;this._coffs[0]+=i*e.x,this._coffs[1]+=i*e.y,this._coffs[2]+=i*e.z,this._coffs[3]+=i*e.w,i=t.y*r,this._coffs[4]+=i*e.x,this._coffs[5]+=i*e.y,this._coffs[6]+=i*e.z,this._coffs[7]+=i*e.w,i=t.z*r,this._coffs[8]+=i*e.x,this._coffs[9]+=i*e.y,this._coffs[10]+=i*e.z,this._coffs[11]+=i*e.w,i=t.w*r,this._coffs[12]+=i*e.x,this._coffs[13]+=i*e.y,this._coffs[14]+=i*e.z,this._coffs[15]+=i*e.w}addTranslationSandwichInPlace(t,e,r,i,n){const s=t._coffs[3],o=t._coffs[7],a=t._coffs[11],c=t._coffs[12],l=t._coffs[13],d=t._coffs[14],h=t._coffs[15],u=e*h,f=r*h,g=i*h;this._coffs[0]+=n*(t._coffs[0]+e*s+c*e+e*u),this._coffs[1]+=n*(t._coffs[1]+r*s+l*e+e*f),this._coffs[2]+=n*(t._coffs[2]+i*s+d*e+e*g),this._coffs[3]+=n*(s+u),this._coffs[4]+=n*(t._coffs[4]+e*o+c*r+r*u),this._coffs[5]+=n*(t._coffs[5]+r*o+l*r+r*f),this._coffs[6]+=n*(t._coffs[6]+i*o+d*r+r*g),this._coffs[7]+=n*(o+f),this._coffs[8]+=n*(t._coffs[8]+e*a+c*i+i*u),this._coffs[9]+=n*(t._coffs[9]+r*a+l*i+i*f),this._coffs[10]+=n*(t._coffs[10]+i*a+d*i+i*g),this._coffs[11]+=n*(a+g),this._coffs[12]+=n*(c+u),this._coffs[13]+=n*(l+f),this._coffs[14]+=n*(d+g),this._coffs[15]+=n*h}multiplyTranslationSandwichInPlace(t,e,r){const i=this._coffs[3],n=this._coffs[7],s=this._coffs[11],o=this._coffs[12],a=this._coffs[13],c=this._coffs[14],l=this._coffs[15],d=t*l,h=e*l,u=r*l;this._coffs[0]+=t*i+o*t+t*d,this._coffs[1]+=e*i+a*t+t*h,this._coffs[2]+=r*i+c*t+t*u,this._coffs[3]+=d,this._coffs[4]+=t*n+o*e+e*d,this._coffs[5]+=e*n+a*e+e*h,this._coffs[6]+=r*n+c*e+e*u,this._coffs[7]+=h,this._coffs[8]+=t*s+o*r+r*d,this._coffs[9]+=e*s+a*r+r*h,this._coffs[10]+=r*s+c*r+r*u,this._coffs[11]+=u,this._coffs[12]+=d,this._coffs[13]+=h,this._coffs[14]+=u}}e.Matrix4d=Matrix4d},"./lib/geometry4d/MomentData.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Transform.js"),s=r("./lib/geometry3d/Matrix3d.js"),o=r("./lib/geometry4d/Matrix4d.js"),a=r("./lib/geometry4d/Point4d.js"),c=r("./lib/Geometry.js");class MomentData{constructor(){this._point0=i.Point3d.create(),this._point1=i.Point3d.create(),this.origin=i.Point3d.createZero(),this.sums=o.Matrix4d.createZero(),this.localToWorldMap=n.Transform.createIdentity(),this.radiusOfGyration=i.Vector3d.create(),this.needOrigin=!1}get quantitySum(){return this.sums.atIJ(3,3)}signFactor(t){return t*this.quantitySum>0?1:-1}setOriginIfNeeded(t){this.needOrigin&&(this.origin.setFromPoint3d(t),this.needOrigin=!1)}setOriginFromGrowableXYZArrayIfNeeded(t){this.needOrigin&&t.length>0&&(t.getPoint3dAtCheckedPointIndex(0,this.origin),this.needOrigin=!1)}setOriginXYZIfNeeded(t,e,r){this.needOrigin&&(this.origin.set(t,e,r),this.needOrigin=!1)}static create(t,e=!1){const r=new MomentData;return r.needOrigin=e,t&&(r.origin.setFromPoint3d(t),r.needOrigin=!1),r}static momentTensorFromInertiaProducts(t){const e=t.sumDiagonal(),r=s.Matrix3d.createScale(e,e,e);return r.addScaledInPlace(t,-1),r}static sortColumnsForIncreasingMoments(t,e){const r=[t.indexedColumnWithWeight(0,e.x),t.indexedColumnWithWeight(1,e.y),t.indexedColumnWithWeight(2,e.z)].sort((t,e)=>t.w<e.w?-1:t.w>e.w?1:0);t.setColumnsPoint4dXYZ(r[0],r[1],r[2]),t.determinant()<0&&t.scaleColumnsInPlace(-1,-1,-1),t.at(0,0)<0&&t.scaleColumnsInPlace(-1,-1,1),t.at(2,2)<0&&t.scaleColumnsInPlace(1,-1,-1),e.set(r[0].w,r[1].w,r[2].w)}static pointsToPrincipalAxes(t){const e=new MomentData;return 0===t.length?e:(e.clearSums(t[0]),e.accumulatePointMomentsFromOrigin(t),this.inertiaProductsToPrincipalAxes(e.origin,e.sums))}static inertiaProductsToPrincipalAxes(t,e){const r=new MomentData;if(r.sums.setFrom(e),r.origin.setFrom(t),!r.shiftOriginAndSumsToCentroidOfSums())return;const o=r.sums.matrixPart(),a=MomentData.momentTensorFromInertiaProducts(o),c=i.Vector3d.create(),l=s.Matrix3d.createZero();return a.fastSymmetricEigenvalues(l,c),MomentData.sortColumnsForIncreasingMoments(l,c),r.localToWorldMap=n.Transform.createOriginAndMatrix(r.origin,l),r.radiusOfGyration.set(Math.sqrt(c.x),Math.sqrt(c.y),Math.sqrt(c.z)),r.radiusOfGyration.scaleInPlace(1/Math.sqrt(r.sums.weight())),r}static areEquivalentPrincipalAxes(t,e){if(t&&e&&c.Geometry.isSameCoordinate(t.quantitySum,e.quantitySum)&&t.localToWorldMap.getOrigin().isAlmostEqual(e.localToWorldMap.getOrigin())&&t.radiusOfGyration.isAlmostEqual(e.radiusOfGyration)){if(c.Geometry.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.y)){if(c.Geometry.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.z))return!0;const r=t.localToWorldMap.matrix.columnZ(),i=e.localToWorldMap.matrix.columnZ();return!!r.isParallelTo(i,!0)}const r=i.Vector3d.create(),n=i.Vector3d.create();for(let i=0;i<3;i++)if(t.localToWorldMap.matrix.getColumn(i,r),e.localToWorldMap.matrix.getColumn(i,n),!r.isParallelTo(n,!0))return!1;return!0}return!1}clearSums(t){this.sums.setZero(),t?this.origin.setFrom(t):this.origin.setZero()}accumulatePointMomentsFromOrigin(t){for(const e of t)this.sums.addMomentsInPlace(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,1)}shiftOriginAndSumsToCentroidOfSums(){const t=this.sums.columnW().realPoint();return!!t&&(this.shiftOriginAndSumsByXYZ(t.x,t.y,t.z),!0)}shiftOriginAndSumsByXYZ(t,e,r){this.origin.addXYZInPlace(t,e,r),this.sums.multiplyTranslationSandwichInPlace(-t,-e,-r)}shiftOriginAndSumsToNewOrigin(t){this.shiftOriginAndSumsByXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z)}accumulateTriangleMomentsXY(t,e,r){this.setOriginXYZIfNeeded(e.x,e.y,0);const i=this.origin.x,n=this.origin.y,s=MomentData._vectorA=void 0!==t?a.Point4d.create(t.x-i,t.y-n,0,1,MomentData._vectorA):a.Point4d.create(this.origin.x,this.origin.y,0,1,MomentData._vectorA),o=MomentData._vectorB=a.Point4d.create(e.x-i,e.y-n,0,1,MomentData._vectorB),l=MomentData._vectorC=a.Point4d.create(r.x-i,r.y-n,0,1,MomentData._vectorC),d=c.Geometry.crossProductXYXY(o.x-s.x,o.y-s.y,l.x-s.x,l.y-s.y);if(0!==d){const t=d/12,e=d/24;this.sums.addScaledOuterProductInPlace(s,s,t),this.sums.addScaledOuterProductInPlace(s,o,e),this.sums.addScaledOuterProductInPlace(s,l,e),this.sums.addScaledOuterProductInPlace(o,s,e),this.sums.addScaledOuterProductInPlace(o,o,t),this.sums.addScaledOuterProductInPlace(o,l,e),this.sums.addScaledOuterProductInPlace(l,s,e),this.sums.addScaledOuterProductInPlace(l,o,e),this.sums.addScaledOuterProductInPlace(l,l,t)}}accumulateScaledOuterProduct(t,e){this.setOriginXYZIfNeeded(t.x,t.y,0);const r=MomentData._vectorA=a.Point4d.create(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,1,MomentData._vectorA);this.sums.addScaledOuterProductInPlace(r,r,e)}accumulateLineMomentsXYZ(t,e){this.setOriginXYZIfNeeded(t.x,t.y,t.z);const r=this.origin.x,i=this.origin.y,n=this.origin.z,s=MomentData._vectorA=a.Point4d.create(t.x-r,t.y-i,t.z-n,1,MomentData._vectorA),o=MomentData._vectorB=a.Point4d.create(e.x-r,e.y-i,e.z-n,1,MomentData._vectorB),c=t.distance(e),l=c/3,d=c/6;this.sums.addScaledOuterProductInPlace(s,s,l),this.sums.addScaledOuterProductInPlace(s,o,d),this.sums.addScaledOuterProductInPlace(o,s,d),this.sums.addScaledOuterProductInPlace(o,o,l)}accumulateTriangleToLineStringMomentsXY(t,e){const r=e.length;if(r>1){e.getPoint3dAtUncheckedPointIndex(0,this._point0);for(let i=1;i<r;i++)e.getPoint3dAtUncheckedPointIndex(i,this._point1),this.accumulateTriangleMomentsXY(t,this._point0,this._point1),this._point0.setFromPoint3d(this._point1)}}accumulateXYProductsInCentroidalFrame(t,e,r,i,n,s,a){const l=o.Matrix4d.createRowValues(t,e,0,0,e,r,0,0,0,0,0,0,0,0,0,i),d=c.Geometry.crossProductXYXY(s.x,a.x,s.y,a.y),h=o.Matrix4d.createRowValues(s.x,a.x,0,n.x-this.origin.x,s.y,a.y,0,n.y-this.origin.y,0,0,0,0,0,0,0,1),u=h.multiplyMatrixMatrix(l).multiplyMatrixMatrixTranspose(h);this.sums.addScaledInPlace(u,d)}accumulateProducts(t,e){this.setOriginIfNeeded(t.origin),this.sums.addTranslationSandwichInPlace(t.sums,this.origin.x-t.origin.x,this.origin.y-t.origin.y,this.origin.z-t.origin.z,e)}accumulateProductsFromOrigin(t,e,r){this.setOriginIfNeeded(t),this.sums.addTranslationSandwichInPlace(e,this.origin.x-t.x,this.origin.y-t.y,this.origin.z-t.z,r)}toJSON(){return{origin:this.origin,sums:this.sums.toJSON(),radiusOfGyration:this.radiusOfGyration.toJSON(),localToWorld:this.localToWorldMap.toJSON()}}}e.MomentData=MomentData},"./lib/geometry4d/PlaneByOriginAndVectors4d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry4d/Point4d.js");class PlaneByOriginAndVectors4d{constructor(t,e,r){this.origin=t,this.vectorU=e,this.vectorV=r}clone(t){return t?(t.setFrom(this),t):new PlaneByOriginAndVectors4d(this.origin.clone(),this.vectorU.clone(),this.vectorV.clone())}setFrom(t){this.origin.setFrom(t.origin),this.vectorU.setFrom(t.vectorU),this.vectorV.setFrom(t.vectorV)}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.vectorU.isAlmostEqual(t.vectorU)&&this.vectorV.isAlmostEqual(t.vectorV)}static createOriginAndVectors(t,e,r,i){return i?(i.setOriginAndVectors(t,e,r),i):new PlaneByOriginAndVectors4d(t.clone(),e.clone(),r.clone())}setOriginAndVectorsXYZW(t,e,r,i,n,s,o,a,c,l,d,h){return this.origin.set(t,e,r,i),this.vectorU.set(n,s,o,a),this.vectorV.set(c,l,d,h),this}setOriginAndVectors(t,e,r){return this.origin.setFrom(t),this.vectorU.setFrom(e),this.vectorV.setFrom(r),this}static createOriginAndVectorsXYZW(t,e,r,n,s,o,a,c,l,d,h,u,f){return f?f.setOriginAndVectorsXYZW(t,e,r,n,s,o,a,c,l,d,h,u):new PlaneByOriginAndVectors4d(i.Point4d.create(t,e,r,n),i.Point4d.create(s,o,a,c),i.Point4d.create(l,d,h,c))}static createOriginAndTargets3d(t,e,r,i){return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(t.x,t.y,t.z,1,e.x-t.x,e.y-t.y,e.z-t.z,0,r.x-t.x,r.y-t.y,r.z-t.z,0,i)}fractionToPoint(t,e,r){return this.origin.plus2Scaled(this.vectorU,t,this.vectorV,e,r)}static createXYPlane(t){return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(0,0,0,1,1,0,0,0,0,1,0,0,t)}}e.PlaneByOriginAndVectors4d=PlaneByOriginAndVectors4d},"./lib/geometry4d/Point4d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/Ray3d.js"),o=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),a=r("./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");function c(t,e,r,i,n,s){return s*(t-2*n*e-i*r)}class Point4d{constructor(t=0,e=0,r=0,i=0){this.xyzw=new Float64Array(4),this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=r,this.xyzw[3]=i}set(t=0,e=0,r=0,i=0){return this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=r,this.xyzw[3]=i,this}setComponent(t,e){t>=0&&t<4&&(this.xyzw[t]=e)}get x(){return this.xyzw[0]}set x(t){this.xyzw[0]=t}get y(){return this.xyzw[1]}set y(t){this.xyzw[1]=t}get z(){return this.xyzw[2]}set z(t){this.xyzw[2]=t}get w(){return this.xyzw[3]}set w(t){this.xyzw[3]=t}static create(t=0,e=0,r=0,i=0,n){return n?n.set(t,e,r,i):new Point4d(t,e,r,i)}setFrom(t){return this.xyzw[0]=t.xyzw[0],this.xyzw[1]=t.xyzw[1],this.xyzw[2]=t.xyzw[2],this.xyzw[3]=t.xyzw[3],this}clone(t){return t?t.setFrom(this):new Point4d(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}setFromJSON(t){i.Geometry.isNumberArray(t,4)?this.set(t[0],t[1],t[2],t[3]):this.set(0,0,0,0)}static fromJSON(t){const e=new Point4d;return e.setFromJSON(t),e}isAlmostEqual(t){return i.Geometry.isSameCoordinate(this.x,t.x)&&i.Geometry.isSameCoordinate(this.y,t.y)&&i.Geometry.isSameCoordinate(this.z,t.z)&&i.Geometry.isSameCoordinate(this.w,t.w)}isAlmostEqualXYZW(t,e,r,n){return i.Geometry.isSameCoordinate(this.x,t)&&i.Geometry.isSameCoordinate(this.y,e)&&i.Geometry.isSameCoordinate(this.z,r)&&i.Geometry.isSameCoordinate(this.w,n)}toJSON(){return[this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3]]}distanceXYZW(t){return i.Geometry.hypotenuseXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}distanceSquaredXYZW(t){return i.Geometry.hypotenuseSquaredXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}realDistanceXY(t){const e=this.w,r=t.w;if(!i.Geometry.isSmallMetricDistance(e)&&!i.Geometry.isSmallMetricDistance(r))return i.Geometry.hypotenuseXY(t.xyzw[0]/r-this.xyzw[0]/e,t.xyzw[1]/r-this.xyzw[1]/e)}maxDiff(t){return Math.max(Math.abs(t.xyzw[0]-this.xyzw[0]),Math.abs(t.xyzw[1]-this.xyzw[1]),Math.abs(t.xyzw[2]-this.xyzw[2]),Math.abs(t.xyzw[3]-this.xyzw[3]))}maxAbs(){return Math.max(Math.abs(this.xyzw[0]),Math.abs(this.xyzw[1]),Math.abs(this.xyzw[2]),Math.abs(this.xyzw[3]))}magnitudeXYZW(){return i.Geometry.hypotenuseXYZW(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}magnitudeSquaredXYZ(){return i.Geometry.hypotenuseSquaredXYZ(this.xyzw[0],this.xyzw[1],this.xyzw[2])}minus(t,e){return Point4d.create(this.xyzw[0]-t.xyzw[0],this.xyzw[1]-t.xyzw[1],this.xyzw[2]-t.xyzw[2],this.xyzw[3]-t.xyzw[3],e)}crossWeightedMinus(t,e){const r=this.xyzw[3],i=t.xyzw[3];return n.Vector3d.create(i*this.xyzw[0]-r*t.xyzw[0],i*this.xyzw[1]-r*t.xyzw[1],i*this.xyzw[2]-r*t.xyzw[2],e)}plus(t,e){return Point4d.create(this.xyzw[0]+t.xyzw[0],this.xyzw[1]+t.xyzw[1],this.xyzw[2]+t.xyzw[2],this.xyzw[3]+t.xyzw[3],e)}get isAlmostZero(){return i.Geometry.isSmallMetricDistance(this.maxAbs())}static createZero(){return new Point4d(0,0,0,0)}static createPlanePointPointZ(t,e,r){return Point4d.create(t.y*e.w-t.w*e.y,t.w*e.x-t.x*e.w,0,t.x*e.y-t.y*e.x,r)}static createFromPackedXYZW(t,e=0,r){return Point4d.create(t[e],t[e+1],t[e+2],t[e+3],r)}static createFromPointAndWeight(t,e){return new Point4d(t.x,t.y,t.z,e)}plusScaled(t,e,r){return Point4d.create(this.xyzw[0]+t.xyzw[0]*e,this.xyzw[1]+t.xyzw[1]*e,this.xyzw[2]+t.xyzw[2]*e,this.xyzw[3]+t.xyzw[3]*e,r)}interpolate(t,e,r){const i=1-t;return Point4d.create(this.xyzw[0]*i+e.xyzw[0]*t,this.xyzw[1]*i+e.xyzw[1]*t,this.xyzw[2]*i+e.xyzw[2]*t,this.xyzw[3]*i+e.xyzw[3]*t,r)}plus2Scaled(t,e,r,i,n){return Point4d.create(this.xyzw[0]+t.xyzw[0]*e+r.xyzw[0]*i,this.xyzw[1]+t.xyzw[1]*e+r.xyzw[1]*i,this.xyzw[2]+t.xyzw[2]*e+r.xyzw[2]*i,this.xyzw[3]+t.xyzw[3]*e+r.xyzw[3]*i,n)}plus3Scaled(t,e,r,i,n,s,o){return Point4d.create(this.xyzw[0]+t.xyzw[0]*e+r.xyzw[0]*i+n.xyzw[0]*s,this.xyzw[1]+t.xyzw[1]*e+r.xyzw[1]*i+n.xyzw[1]*s,this.xyzw[2]+t.xyzw[2]*e+r.xyzw[2]*i+n.xyzw[2]*s,this.xyzw[3]+t.xyzw[3]*e+r.xyzw[3]*i+n.xyzw[3]*s,o)}static createAdd2Scaled(t,e,r,i,n){return Point4d.create(t.xyzw[0]*e+r.xyzw[0]*i,t.xyzw[1]*e+r.xyzw[1]*i,t.xyzw[2]*e+r.xyzw[2]*i,t.xyzw[3]*e+r.xyzw[3]*i,n)}static createAdd3Scaled(t,e,r,i,n,s,o){return Point4d.create(t.xyzw[0]*e+r.xyzw[0]*i+n.xyzw[0]*s,t.xyzw[1]*e+r.xyzw[1]*i+n.xyzw[1]*s,t.xyzw[2]*e+r.xyzw[2]*i+n.xyzw[2]*s,t.xyzw[3]*e+r.xyzw[3]*i+n.xyzw[3]*s,o)}dotVectorsToTargets(t,e){return(t.xyzw[0]-this.xyzw[0])*(e.xyzw[0]-this.xyzw[0])+(t.xyzw[1]-this.xyzw[1])*(e.xyzw[1]-this.xyzw[1])+(t.xyzw[2]-this.xyzw[2])*(e.xyzw[2]-this.xyzw[2])+(t.xyzw[3]-this.xyzw[3])*(e.xyzw[3]-this.xyzw[3])}dotProduct(t){return this.xyzw[0]*t.xyzw[0]+this.xyzw[1]*t.xyzw[1]+this.xyzw[2]*t.xyzw[2]+this.xyzw[3]*t.xyzw[3]}dotProductXYZW(t,e,r,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*r+this.xyzw[3]*i}altitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]}altitudeXYZ(t,e,r){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*r+this.xyzw[3]}weightedAltitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]*t.w}velocity(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z}velocityXYZ(t,e,r){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*r}static unitX(){return new Point4d(1,0,0,0)}static unitY(){return new Point4d(0,1,0,0)}static unitZ(){return new Point4d(0,0,1,0)}static unitW(){return new Point4d(0,0,0,1)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}scale(t,e){return(e=e||new Point4d).xyzw[0]=this.xyzw[0]*t,e.xyzw[1]=this.xyzw[1]*t,e.xyzw[2]=this.xyzw[2]*t,e.xyzw[3]=this.xyzw[3]*t,e}negate(t){return(t=t||new Point4d).xyzw[0]=-this.xyzw[0],t.xyzw[1]=-this.xyzw[1],t.xyzw[2]=-this.xyzw[2],t.xyzw[3]=-this.xyzw[3],t}normalizeWeight(t){const e=i.Geometry.correctSmallMetricDistance(this.xyzw[3]);return t=t||new Point4d,this.safeDivideOrNull(e,t)}realPoint(t){const e=i.Geometry.correctSmallMetricDistance(this.xyzw[3]);if(0===e)return;const r=1/e;return n.Point3d.create(this.xyzw[0]*r,this.xyzw[1]*r,this.xyzw[2]*r,t)}static createRealPoint3dDefault000(t,e,r,s,o){const a=i.Geometry.correctSmallMetricDistance(s),c=0===a?0:1/a;return n.Point3d.create(t*c,e*c,r*c,o)}static createRealDerivativeRay3dDefault000(t,e,r,n,o,a,c,l,d){const h=i.Geometry.correctSmallMetricDistance(n),u=0===h?0:1/h,f=u*u;return s.Ray3d.createXYZUVW(t*u,e*u,r*u,(o*n-l*t)*f,(a*n-l*e)*f,(c*n-l*r)*f,d)}static createRealDerivativePlane3dByOriginAndVectorsDefault000(t,e,r,n,s,a,l,d,h,u,f,g,p){const m=i.Geometry.correctSmallMetricDistance(n),y=0===m?0:1/m,P=y*y,x=t*y,_=e*y,v=r*y,S=(s*n-d*t)*P,C=(a*n-d*e)*P,A=(l*n-d*r)*P;return o.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(x,_,v,S,C,A,c(h,d,g,x,S,y),c(u,d,g,_,C,y),c(f,d,g,v,A,y),p)}realPointDefault000(t){const e=i.Geometry.correctSmallMetricDistance(this.xyzw[3]);if(0===e)return n.Point3d.create(0,0,0,t);t=t||new n.Point3d;const r=1/e;return n.Point3d.create(this.xyzw[0]*r,this.xyzw[1]*r,this.xyzw[2]*r,t)}normalizeXYZW(t){const e=i.Geometry.correctSmallMetricDistance(this.magnitudeXYZW());return t=t||new Point4d,this.safeDivideOrNull(e,t)}static determinantIndexed3X3(t,e,r,n,s,o){return i.Geometry.tripleProduct(t.xyzw[n],t.xyzw[s],t.xyzw[o],e.xyzw[n],e.xyzw[s],e.xyzw[o],r.xyzw[n],r.xyzw[s],r.xyzw[o])}static perpendicularPoint4dPlane(t,e,r){return Point4d.create(Point4d.determinantIndexed3X3(t,e,r,1,2,3),-Point4d.determinantIndexed3X3(t,e,r,2,3,0),Point4d.determinantIndexed3X3(t,e,r,3,0,1),-Point4d.determinantIndexed3X3(t,e,r,0,1,2))}toPlane3dByOriginAndUnitNormal(t){const e=this.magnitudeSquaredXYZ(),r=n.Vector3d.create(this.x,this.y,this.z),s=this.w;if(void 0!==i.Geometry.conditionalDivideFraction(1,s)){const i=-s/e;return r.scaleInPlace(1/Math.sqrt(e)),a.Plane3dByOriginAndUnitNormal.create(n.Point3d.create(this.x*i,this.y*i,this.z*i),r,t)}}normalizeQuaternion(){const t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);if(t>0){const e=1/t;this.x*=e,this.y*=e,this.z*=e,this.w*=e}return t}static interpolateQuaternions(t,e,r,i){i||(i=new Point4d);if(0===e)return i=t;if(1===e)return i=r;if(.5===e)return t.plus(r,i),i.normalizeQuaternion(),i;const n=t.clone(),s=r.clone();let o=t.dotProduct(r);if(o<0&&(s.negate(s),o=-o),o>.9995)return n.interpolate(e,s,i),i.normalizeQuaternion(),i;o<-1?o=-1:o>1&&(o=1);const a=new Point4d;s.plusScaled(n,-o,a),a.normalizeQuaternion();const c=Math.acos(o)*e;return i=Point4d.createAdd2Scaled(n,Math.cos(c),a,Math.sin(c))}radiansToPoint4dXYZW(t){const e=this.magnitudeXYZW(),r=t.magnitudeXYZW(),n=this.dotProduct(t),s=i.Geometry.conditionalDivideFraction(n,e*r);if(void 0!==s)return Math.acos(s)}}e.Point4d=Point4d},"./lib/numerics/BezierPolynomials.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/numerics/PascalCoefficients.js"),s=r("./lib/numerics/Polynomials.js");class BezierCoffs{constructor(t){if(t instanceof Float64Array)this.coffs=t.slice();else if(Array.isArray(t)){this.coffs=new Float64Array(t.length);let e=0;for(const r of t)this.coffs[e++]=r}else this.coffs=new Float64Array(t)}allocateToOrder(t){this.coffs.length!==t?this.coffs=new Float64Array(t):this.coffs.fill(0)}createPeer(){return new UnivariateBezier(this.order)}get order(){return this.coffs.length}copyFrom(t){if(this.order===t.order)for(let e=0;e<this.coffs.length;e++)this.coffs[e]=t.coffs[e];else this.coffs=t.coffs.slice()}scaleInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]*=t}addInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}roots(t,e){const r=UnivariateBezier.create(this);return r.addInPlace(-t),UnivariateBezier.deflateRoots01(r)}filter01(t,e=!1){if(!t||!e)return t;let r=!1;for(const n of t)if(i.Geometry.isIn01(n)){r=!0;break}if(r){const e=[];for(const r of t)i.Geometry.isIn01(r)&&e.push(r);return e}}zero(){this.coffs.fill(0)}subdivide(t,e,r){const i=this.order;if(e.order!==i||r.order!==i)return!1;const n=1-t;r.copyFrom(this);let s=i-1;for(let o=0;o<i;o++){e.coffs[o]=r.coffs[0];for(let e=0;e<s;e++)r.coffs[e]=n*r.coffs[e]+t*r.coffs[e+1];s--}return!0}static maxAbsDiff(t,e){const r=t.order;if(e.order!==r)return;let i,n=0;for(let s=0;s<r;s++)(i=Math.abs(t.coffs[s]-e.coffs[s]))>n&&(n=i);return n}}e.BezierCoffs=BezierCoffs;e.BezierPolynomialAlgebra=class BezierPolynomialAlgebra{static accumulateScaledShiftedComponentTimesComponentDelta(t,e,r,i,s,o,a,c){const l=i-1,d=i,h=i+l-1;if(t.length!==h)return;const u=n.PascalCoefficients.getRow(d-1),f=n.PascalCoefficients.getRow(l-1),g=n.PascalCoefficients.getRow(h-1);let p;for(let n=0;n<d;n++){p=s*(a+e[o+n*r])*u[n];for(let i=0,s=c;i<l;i++,s+=r)t[n+i]+=p*f[i]*(e[s+r]-e[s])/g[n+i]}}static scaledComponentSum(t,e,r,i,n,s,o,a){const c=i;if(t.length===c)for(let l=0,d=0;l<c;l++,d+=r)t[l]=s*e[d+n]+a*e[d+o]}static componentDifference(t,e,r,i,n){const s=i-1;if(t.length===s)for(let o=0,a=n;o<s;a+=r,o++)t[o]=e[a+r]-e[a]}static accumulateProduct(t,e,r,i=1){const s=e.length,o=r.length,a=s+o-1;if(t.length!==a)return;let c,l,d;const h=n.PascalCoefficients.getRow(s-1),u=n.PascalCoefficients.getRow(o-1),f=n.PascalCoefficients.getRow(a-1);for(c=0;c<s;c++)for(d=i*h[c]*e[c],l=0;l<o;l++)t[c+l]+=d*u[l]*r[l]/f[c+l]}static accumulateProductWithDifferences(t,e,r,i=1){const s=e.length-1,o=r.length,a=s+o-1;if(t.length!==a)return;let c,l,d;const h=n.PascalCoefficients.getRow(s-1),u=n.PascalCoefficients.getRow(o-1),f=n.PascalCoefficients.getRow(a-1);for(c=0;c<s;c++)for(d=i*h[c]*(e[c+1]-e[c]),l=0;l<o;l++)t[c+l]+=d*u[l]*r[l]/f[c+l]}static univariateDifference(t,e){const r=e.length;if(e.length+1!==r)for(let i=0;i<r;i++)e[i]=t[i+1]-t[i]}static accumulate(t,e,r){if(r.length===e)for(let i=0;i<e;i++)r[i]+=t[i]}};class UnivariateBezier extends BezierCoffs{constructor(t){super(t),this._order=super.order}get order(){return this._order}allocateOrder(t){this._order!==t&&(super.allocateToOrder(t),this._order=t),this.coffs.fill(0)}clone(t=!1){if(t){const t=new UnivariateBezier(this.order);return t.coffs=this.coffs.slice(0,this.order),t}const e=new UnivariateBezier(this.coffs.length);return e._order=this._order,e.coffs=this.coffs.slice(),e}static create(t){const e=new UnivariateBezier(t.order);return e.coffs=t.coffs.slice(),e}static createCoffs(t){return new UnivariateBezier(t)}static createArraySubset(t,e,r,i){i?i.order!==r&&i.allocateToOrder(r):i=new UnivariateBezier(r);for(let n=0;n<r;n++)i.coffs[n]=t[e+n];return i}static createProduct(t,e){const r=new UnivariateBezier(t.order+e.order-1),i=n.PascalCoefficients.getRow(t.order-1),s=n.PascalCoefficients.getRow(e.order-1),o=n.PascalCoefficients.getRow(t.order+e.order-2);for(let n=0;n<t.order;n++){const a=t.coffs[n]*i[n];for(let t=0;t<e.order;t++){const i=e.coffs[t]*s[t],c=n+t,l=o[c];r.coffs[c]+=a*i/l}}return r}addSquaredSquaredBezier(t,e){const r=t.length,i=this.order;if(2*r!==i+1)return!1;const s=n.PascalCoefficients.getRow(r-1),o=n.PascalCoefficients.getRow(i-1),a=this.coffs;for(let n=0;n<r;n++){const i=t[n]*s[n]*e;for(let e=0;e<r;e++){const r=t[e]*s[e],c=n+e,l=o[c];a[c]+=i*r/l}}return!0}addConstant(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}basisFunctions(t,e){this._basisValues=n.PascalCoefficients.getBezierBasisValues(this.order,t,this._basisValues),e&&e.length===this.order||(e=new Float64Array(this.order));let r=0;for(const i of this._basisValues)e[r++]=i;return e}static sumWeightedBlocks(t,e,r,i,n){for(let a=0;a<i;a++)n[a]=0;let s,o=0;for(let a=0;a<e;a++){const e=t[a];for(s=0;s<i;s++)n[s]+=e*r[o++]}}sumBasisFunctions(t,e,r,i){const s=this._order;return i||(i=new Float64Array(s)),this._basisValues=n.PascalCoefficients.getBezierBasisValues(this.order,t,this._basisValues),UnivariateBezier.sumWeightedBlocks(this._basisValues,s,e,r,i),i}sumBasisFunctionDerivatives(t,e,r,i){const s=this._order;return i||(i=new Float64Array(r)),this._basisValues=n.PascalCoefficients.getBezierBasisDerivatives(this.order,t,this._basisValues),UnivariateBezier.sumWeightedBlocks(this._basisValues,s,e,r,i),i}evaluate(t){this._basisValues=n.PascalCoefficients.getBezierBasisValues(this.order,t,this._basisValues);let e=0;for(let r=0;r<this.order;r++)e+=this._basisValues[r]*this.coffs[r];return e}deflateLeft(){const t=this.order,e=t-1,r=n.PascalCoefficients.getRow(e-1),i=n.PascalCoefficients.getRow(t-1);let s;for(let n=0;n<e;n++)s=this.coffs[n+1],this.coffs[n]=s*i[n+1]/r[n];this._order--}deflateRight(){const t=this.order,e=t-1,r=n.PascalCoefficients.getRow(e-1),i=n.PascalCoefficients.getRow(t-1);let s,o;for(let n=0;n<e;n++)o=(s=this.coffs[n])*i[n]/r[n],this.coffs[n]=o;this._order--}deflateRoot(t){const e=this.order,r=e-1;if(1===e)return this._order=0,this.coffs[0];if(e<1)return this._order=0,0;const i=n.PascalCoefficients.getRow(e-1),s=n.PascalCoefficients.getRow(r-1),o=-t,a=1-t;let c=0;if(t>.5){let t,n=this.coffs[0]/o;this.coffs[0]=n;let l=this.coffs[1];for(let e=1;e<r;e++)t=((l=this.coffs[e]*i[e])-n*a)/o,this.coffs[e]=t/s[e],n=t;c=this.coffs[e-1]-n*a}else{let t,n,l=this.coffs[e-1]/a;this.coffs[e-1]=l;for(let r=e-2;r>0;r--)t=((n=this.coffs[r]*i[r])-l*o)/a,this.coffs[r]=t/s[r-1],l=t;c=this.coffs[0]-l*o;for(let e=0;e<r;e++)this.coffs[e]=this.coffs[e+1]}return this._order=r,c}runNewton(t,e=1e-11){const r=this.order-1;let i,s,o=0,a=t;const c=this.order,l=this.coffs,d=c-1;for(let h=0;h++<10;){UnivariateBezier._basisBuffer=n.PascalCoefficients.getBezierBasisValues(c,a,UnivariateBezier._basisBuffer),i=0;for(let e=0;e<c;e++)i+=l[e]*UnivariateBezier._basisBuffer[e];UnivariateBezier._basisBuffer1=n.PascalCoefficients.getBezierBasisValues(d,a,UnivariateBezier._basisBuffer1),s=0;for(let e=0;e<d;e++)s+=(l[e+1]-l[e])*UnivariateBezier._basisBuffer1[e];if(s*=r,Math.abs(i)>10*Math.abs(s))return;const t=i/s;if(Math.abs(t)<e){if(++o>=2)return a-t}else o=0;a-=t}}static deflateRoots01(t){const e=[],r=t.coffs;let i,n,s,o,a;for(;t.order>1;){const c=t.order;if(0===r[0]){t.deflateLeft(),e.push(0);continue}let l=0,d=0;for(let h=1;h<c;h++)if((i=r[h-1])*(n=r[h])<=0&&(l++,o=(h-1+(s=-i/(n-i)))/(c-1),void 0!==(a=t.runNewton(o,1e-10)))){e.push(a),t.deflateRoot(a),d++;break}if(!d)return e}return e}}e.UnivariateBezier=UnivariateBezier;class Order2Bezier extends BezierCoffs{constructor(t=0,e=0){super(2),this.coffs[0]=t,this.coffs[1]=e}clone(){return new Order2Bezier(this.coffs[0],this.coffs[1])}static solveCoffs(t,e){return i.Geometry.conditionalDivideFraction(-t,e-t)}basisFunctions(t,e){return e||(e=new Float64Array(2)),e[0]=1-t,e[1]=t,e}sumBasisFunctions(t,e,r,i){i||(i=new Float64Array(r));const n=1-t;for(let s=0;s<r;s++)i[s]=n*e[s]+t*e[s+r];return i}sumBasisFunctionDerivatives(t,e,r,i){i||(i=new Float64Array(r));for(let n=0;n<r;n++)i[n]=e[n+r]-e[n];return i}evaluate(t){return(1-t)*this.coffs[0]+t*this.coffs[1]}solve(t){const e=this.coffs[1]-this.coffs[0];return i.Geometry.conditionalDivideFraction(t-this.coffs[0],e)}roots(t,e){const r=this.solve(t);if(void 0!==r)return!e||i.Geometry.isIn01(r)?[r]:void 0}}e.Order2Bezier=Order2Bezier;class Order3Bezier extends BezierCoffs{constructor(t=0,e=0,r=0){super(3),this.coffs[0]=t,this.coffs[1]=e,this.coffs[2]=r}clone(){return new Order3Bezier(this.coffs[0],this.coffs[1],this.coffs[2])}basisFunctions(t,e){e||(e=new Float64Array(3));const r=1-t;return e[0]=r*r,e[1]=2*t*r,e[2]=t*t,e}sumBasisFunctions(t,e,r,i){i||(i=new Float64Array(r));const n=1-t,s=n*n,o=2*t*n,a=t*t;for(let c=0;c<r;c++)i[c]=s*e[c]+o*e[c+r]+a*e[c+2*r];return i}sumBasisFunctionDerivatives(t,e,r,i){i||(i=new Float64Array(r));const n=2*(1-t),s=2*t,o=2*r;for(let a=0;a<r;a++){const t=e[a+r];i[a]=n*(t-e[a])+s*(e[a+o]-t)}return i}addSquareLinear(t,e,r){this.coffs[0]+=r*t*t,this.coffs[1]+=r*t*e,this.coffs[2]+=r*e*e}roots(t,e){const r=this.coffs[0]-t,i=this.coffs[1]-t,n=i-r,o=this.coffs[2]-t-i-n,a=s.Degree2PowerPolynomial.solveQuadratic(o,2*n,r);return super.filter01(a,e)}evaluate(t){const e=1-t;return this.coffs[0]*e*e+t*(2*this.coffs[1]*e+this.coffs[2]*t)}}e.Order3Bezier=Order3Bezier;class Order4Bezier extends BezierCoffs{constructor(t=0,e=0,r=0,i=0){super(4),this.coffs[0]=t,this.coffs[1]=e,this.coffs[2]=r,this.coffs[3]=i}clone(){return new Order4Bezier(this.coffs[0],this.coffs[1],this.coffs[2],this.coffs[3])}static createProductOrder3Order2(t,e){return new Order4Bezier(t.coffs[0]*e.coffs[0],(t.coffs[0]*e.coffs[1]+2*t.coffs[1]*e.coffs[0])/3,(2*t.coffs[1]*e.coffs[1]+t.coffs[2]*e.coffs[0])/3,t.coffs[2]*e.coffs[1])}basisFunctions(t,e){e||(e=new Float64Array(4));const r=1-t,i=t*t,n=r*r;return e[0]=n*r,e[1]=3*n*t,e[2]=3*r*i,e[3]=t*i,e}sumBasisFunctions(t,e,r,i){i||(i=new Float64Array(r));const n=1-t,s=t*t,o=n*n,a=n*o,c=3*t*o,l=3*s*n,d=t*s;for(let h=0;h<r;h++)i[h]=a*e[h]+c*e[h+r]+l*e[h+2*r]+d*e[h+3*r];return i}sumBasisFunctionDerivatives(t,e,r,i){i||(i=new Float64Array(r));const n=1-t,s=n*n*3,o=6*t*n,a=3*t*t;for(let c=0;c<r;c++){const t=e[c],n=e[c+r],l=e[c+2*r],d=e[c+3*r];i[c]=s*(n-t)+o*(l-n)+a*(d-l)}return i}evaluate(t){const e=1-t,r=e*e,i=r*e;return this.coffs[0]*i+t*(3*this.coffs[1]*r+t*(3*this.coffs[2]*e+t*this.coffs[3]))}static createFromDegree3PowerPolynomial(t){const e=t.evaluate(0),r=t.evaluateDerivative(0),i=t.evaluateDerivative(1),n=t.evaluate(1);return new Order4Bezier(e,e+r/3,n-i/3,n)}realRoots(t,e,r){r.clear();const n=new Float64Array(4),o=this.coffs[0],a=this.coffs[1],c=this.coffs[2],l=this.coffs[3],d=Math.max(o,a,c,l),h=Math.min(o,a,c,l),u=i.Geometry.smallMetricDistance;if(!(h>u)&&!(d<-u)){if(h>=-u&&d<u)return r.push(0),r.push(1/3),r.push(2/3),void r.push(1);n[0]=o-t,n[1]=3*(a-o),n[2]=3*(o-2*a+c),n[3]=3*a-o-3*c+l,s.AnalyticRoots.appendCubicRoots(n,r),e&&r.reassign(0,1)}}}e.Order4Bezier=Order4Bezier;class Order5Bezier extends BezierCoffs{constructor(t=0,e=0,r=0,i=0,n=0){super(5),this.coffs[0]=t,this.coffs[1]=e,this.coffs[2]=r,this.coffs[3]=i,this.coffs[4]=n}clone(){return new Order5Bezier(this.coffs[0],this.coffs[1],this.coffs[2],this.coffs[3],this.coffs[4])}static createFromDegree4PowerPolynomial(t){const e=t.evaluate(0),r=t.evaluateDerivative(0),i=t.evaluateDerivative(1),n=t.evaluate(1),s=e+.25*r,o=2*s-e+t.coffs[2]/6;return new Order5Bezier(e,s,o,n-.25*i,n)}basisFunctions(t,e){e||(e=new Float64Array(5));const r=1-t,i=t*t,n=i*t,s=r*r,o=s*r;return e[0]=s*s,e[1]=4*o*t,e[2]=6*s*i,e[3]=4*r*n,e[4]=i*i,e}sumBasisFunctions(t,e,r,i){i||(i=new Float64Array(r));const n=1-t,s=t*t,o=n*n,a=o*o,c=4*(o*n)*t,l=6*o*s,d=4*n*(s*t),h=s*s;for(let u=0;u<r;u++)i[u]=a*e[u]+c*e[u+r]+l*e[u+2*r]+d*e[u+3*r]+h*e[u+4*r];return i}sumBasisFunctionDerivatives(t,e,r,i){i||(i=new Float64Array(r));const n=1-t,s=t*t,o=n*n,a=4*n*o,c=12*t*o,l=12*s*n,d=4*t*s;for(let h=0;h<r;h++){const t=e[h],n=e[h+r],s=e[h+2*r],o=e[h+3*r],u=e[h+4*r];i[h]=a*(n-t)+c*(s-n)+l*(o-s)+d*(u-o)}return i}evaluate(t){const e=1-t,r=e*e,i=r*e,n=r*r;return this.coffs[0]*n+t*(4*this.coffs[1]*i+t*(6*this.coffs[2]*r+t*(4*this.coffs[3]*e+t*this.coffs[4])))}addProductOrder3BezierOrder3Bezier(t,e,r){this.coffs[0]+=r*t.coffs[0]*e.coffs[0],this.coffs[1]+=r*(t.coffs[0]*e.coffs[1]+t.coffs[1]*e.coffs[0])*.5,this.coffs[2]+=r*(t.coffs[0]*e.coffs[2]+4*t.coffs[1]*e.coffs[1]+t.coffs[2]*e.coffs[0])/6,this.coffs[3]+=r*(t.coffs[1]*e.coffs[2]+t.coffs[2]*e.coffs[1])*.5,this.coffs[4]+=r*t.coffs[2]*e.coffs[2]}addConstant(t){for(let e=0;e<5;e++)this.coffs[e]+=t}realRoots(t,e,r){r.clear();const n=this.coffs[0]-t,o=this.coffs[1]-t,a=this.coffs[2]-t,c=this.coffs[3]-t,l=this.coffs[4]-t,d=Math.max(n,o,a,c,l),h=Math.min(n,o,a,c,l),u=i.Geometry.smallMetricDistance;if(h>u)return;if(d<-u)return;if(h>=-u&&d<u)return r.push(0),r.push(.25),r.push(.5),r.push(.75),void r.push(1);const f=new Float64Array(5);f[0]=n-t,f[1]=4*(-n+o),f[2]=6*(n-2*o+a),f[3]=4*(3*o-n-3*a+c),f[4]=n-4*o+6*a-4*c+l,s.AnalyticRoots.appendQuarticRoots(f,r),e&&r.reassign(0,1)}}e.Order5Bezier=Order5Bezier},"./lib/numerics/ClusterableArray.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point2dVector2d.js"),s=r("./lib/geometry3d/Point3dVector3d.js"),o=r("./lib/geometry3d/GrowableBlockedArray.js"),a=r("./lib/geometry3d/GrowableXYZArray.js");class ClusterableArray extends o.GrowableBlockedArray{constructor(t,e,r){super(1+t+e,r),this._numExtraDataPerPoint=e,this._numCoordinatePerPoint=t}static sortVectorComponent(t){let e=1;for(let r=1;r<t;r++)e*=ClusterableArray._vectorFactor;return e}addBlock(t){const e=this.newBlockIndex()+1,r=Math.min(this.numPerBlock-1,t.length);for(let i=0;i<r;i++)this._data[e+i]=t[i]}addDirect(t,e,r,i,n){const s=this.newBlockIndex();this._data[s+1]=t,this._data[s+2]=e,void 0!==r&&(this._data[s+3]=r),void 0!==i&&(this._data[s+4]=i),void 0!==n&&(this._data[s+5]=n)}addPoint2d(t,e,r,i){const n=this.newBlockIndex();this._data[n+1]=t.x,this._data[n+2]=t.y,void 0!==e&&(this._data[n+3]=e),void 0!==r&&(this._data[n+4]=r),void 0!==i&&(this._data[n+5]=i)}addPoint3d(t,e,r,i){const n=this.newBlockIndex();this._data[n+1]=t.x,this._data[n+2]=t.y,this._data[n+3]=t.z,void 0!==e&&(this._data[n+4]=e),void 0!==r&&(this._data[n+5]=r),void 0!==i&&(this._data[n+6]=i)}getPoint2d(t,e){const r=this.blockIndexToDoubleIndex(t);return n.Point2d.create(this._data[r+1],this._data[r+2],e)}getPoint3d(t,e){const r=this.blockIndexToDoubleIndex(t);return s.Point3d.create(this._data[r+1],this._data[r+2],this._data[r+3],e)}getExtraData(t,e){const r=this.blockIndexToDoubleIndex(t);return this._data[r+1+this._numCoordinatePerPoint+e]}getData(t,e){const r=this.blockIndexToDoubleIndex(t);return this._data[r+e]}setExtraData(t,e,r){const i=this.blockIndexToDoubleIndex(t);this._data[i+1+this._numCoordinatePerPoint+e]=r}static isClusterTerminator(t){return t===ClusterableArray.clusterTerminator}clusterIndicesLexical(t=i.Geometry.smallMetricDistance){this.setupPrimaryClusterSort();const e=this.sortIndicesLexical(),r=new Uint32Array(2*e.length);let n=0;const s=this.numBlocks;let o=0,a=0,c=0,l=0,d=0;const h=1+this._numCoordinatePerPoint;for(l=0;l<s;l++)if(o=e[l],!ClusterableArray.isClusterTerminator(o)){for(r[n++]=o,c=this.component(o,0)+t,e[l]=ClusterableArray.clusterTerminator,d=l+1;d<s;d++)if((a=e[d])!==ClusterableArray.clusterTerminator){if(this.component(a,0)>=c)break;this.distanceBetweenSubBlocks(o,a,1,h)<t&&(r[n++]=a,e[d]=ClusterableArray.clusterTerminator)}r[n++]=ClusterableArray.clusterTerminator}return r.slice(0,n)}setupPrimaryClusterSort(){const t=this.numBlocks,e=this._numCoordinatePerPoint,r=new Float64Array(e);r[0]=1;for(let o=1;o<e;o++)r[o]=r[o-1]*ClusterableArray._vectorFactor;let i=0,n=0;const s=this._data;for(let o=0;o<t;o++){i=this.blockIndexToDoubleIndex(o),n=0;for(let t=0;t<e;t++)n+=r[t]*s[i+1+t];s[i]=n}}toJSON(){const t=[];for(let e=0;e<this.numBlocks;e++){let r=this.blockIndexToDoubleIndex(e);const i=[e,this._data[r++]],n=[];for(let t=0;t<this._numCoordinatePerPoint;t++)n.push(this._data[r++]);i.push(n);for(let t=0;t<this._numExtraDataPerPoint;t++)i.push(this._data[r++]);t.push(i)}return t}createIndexBlockToClusterIndex(t){const e=this.numBlocks,r=new Uint32Array(e);r.fill(ClusterableArray.clusterTerminator);let i=0;for(const n of t)n>=e?i++:r[n]=i;return r}createIndexBlockToClusterStart(t){const e=t.length,r=this.numBlocks,i=new Uint32Array(r),n=ClusterableArray.clusterTerminator;i.fill(n);let s=0;for(let o=0;o<e;o++){const e=t[o];e>r?s=o+1:i[e]=s}return i}countClusters(t){let e=0;const r=ClusterableArray.clusterTerminator;for(const i of t)i===r&&e++;return e}createIndexClusterToClusterStart(t){let e=this.countClusters(t);const r=new Uint32Array(e),i=ClusterableArray.clusterTerminator;r.fill(i);const n=t.length;let s=0;for(let o=0;o<n;o++){t[o]===i?s=o+1:o===s&&(r[e++]=s)}return r}sortSubsetsBySingleKey(t,e){const r=1+e;let i,n,s,o=0;const a=t.length;for(let c=0;c<a;c++)if(t[c]===ClusterableArray.clusterTerminator){for(let e=o;e+1<c;e++){n=this.getWithinBlock(t[e],r);for(let o=e+1;o<c;o++)(s=this.getWithinBlock(t[o],r))<n&&(i=t[e],t[e]=t[o],t[o]=i,n=s)}o=c+1}}static clusterPoint3dArray(t,e=i.Geometry.smallMetricDistance){const r=new ClusterableArray(3,0,t.length);t.forEach(t=>{r.addDirect(t.x,t.y,t.z)});const n=r.clusterIndicesLexical(e),s=new PackedPointsWithIndex(t.length);let o=0,a=0;return n.forEach(e=>{ClusterableArray.isClusterTerminator(e)?(o++,a=0):(0===a&&s.packedPoints.push(t[e].clone()),s.oldToNew[e]=o,a++)}),s}static clusterGrowablePoint3dArray(t,e=i.Geometry.smallMetricDistance){const r=new ClusterableArray(3,0,t.length),n=s.Point3d.create(),o=t.length;for(let i=0;i<o;i++)t.getPoint3dAtUncheckedPointIndex(i,n),r.addDirect(n.x,n.y,n.z);const c=r.clusterIndicesLexical(e),l=new PackedPointsWithIndex(t.length),d=r.countClusters(c);l.growablePackedPoints=new a.GrowableXYZArray(d);let h=0,u=0;return c.forEach(e=>{ClusterableArray.isClusterTerminator(e)?(h++,u=0):(0===u&&l.growablePackedPoints.pushFromGrowableXYZArray(t,e),l.oldToNew[e]=h,u++)}),l}}e.ClusterableArray=ClusterableArray,ClusterableArray._vectorFactor=.8732,ClusterableArray.clusterTerminator=4294967295;class PackedPointsWithIndex{constructor(t){this.packedPoints=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=PackedPointsWithIndex.invalidIndex}updateIndices(t){let e=0;return t.forEach((t,r,i)=>{t<this.oldToNew.length?i[r]=this.oldToNew[t]:e++}),0===e}}PackedPointsWithIndex.invalidIndex=4294967295},"./lib/numerics/Complex.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Angle.js");class Complex{constructor(t=0,e=0){this._x=t,this._y=e}set x(t){this._x=t}get x(){return this._x}set y(t){this._y=t}get y(){return this._y}set(t=0,e=0){this.x=t,this.y=e}setFrom(t){this.x=t.x,this.y=t.y}clone(){return new Complex(this.x,this.y)}isAlmostEqual(t){return i.Geometry.isAlmostEqualNumber(this.x,t.x)&&i.Geometry.isAlmostEqualNumber(this.x,t.x)}static create(t=0,e=0,r){return r?(r.x=t,r.y=e,r):new Complex(t,e)}plus(t,e){return Complex.create(this.x+t.x,this.y+t.y,e)}minus(t,e){return Complex.create(this.x-t.x,this.y-t.y,e)}times(t,e){return Complex.create(this.x*t.x-this.y*t.y,this.x*t.y+this.y*t.x,e)}timesXY(t,e,r){return Complex.create(this.x*t-this.y*e,this.x*e+this.y*t,r)}magnitude(){return i.Geometry.hypotenuseXY(this.x,this.y)}angle(){return n.Angle.createAtan2(this.y,this.x)}distance(t){return i.Geometry.hypotenuseXY(this.x-t.x,this.y-t.y)}magnitudeSquared(){return this.x*this.x+this.y*this.y}divide(t,e){const r=t.magnitudeSquared();if(0===r)return;const i=1/r;return Complex.create((this.x*t.x+this.y*t.y)*i,(this.y*t.x-this.x*t.y)*i,e)}sqrt(t){if(0===this.x&&0===this.y)return Complex.create(0,0,t);const e=Math.abs(this.x),r=Math.abs(this.y);let i=0,n=0;if(e>=r?(i=r/e,n=Math.sqrt(e)*Math.sqrt(.5*(1+Math.sqrt(1+i*i)))):(i=e/r,n=Math.sqrt(r)*Math.sqrt(.5*(i+Math.sqrt(1+i*i)))),this.x>=0)return Complex.create(n,this.y/(2*n),t);{const e=this.y>=0?n:-n;return Complex.create(this.y/(2*e),e,t)}}setFromJSON(t){Array.isArray(t)&&t.length>1?this.set(t[0],t[1]):t&&t.x&&t.y?this.set(t.x,t.y):this.set(0,0)}static fromJSON(t){const e=new Complex;return e.setFromJSON(t),e}toJSON(){return[this.x,this.y]}}e.Complex=Complex},"./lib/numerics/ConvexPolygon2d.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Range.js"),s=r("./lib/Geometry.js");class Ray2d{constructor(t,e){this._origin=t,this._direction=e}static createOriginAndTarget(t,e){return new Ray2d(t.clone(),t.vectorTo(e))}static createOriginAndDirection(t,e){return new Ray2d(t.clone(),e.clone())}static createOriginAndDirectionCapture(t,e){return new Ray2d(t,e)}get origin(){return this._origin}get direction(){return this._direction}parallelRay(t){return new Ray2d(this._origin.addForwardLeft(0,t,this._direction),this._direction)}ccwPerpendicularRay(){return new Ray2d(this._origin,this._direction.rotate90CCWXY())}cwPerpendicularRay(){return new Ray2d(this._origin,this._direction.rotate90CWXY())}normalizeDirectionInPlace(){return!!this._direction.normalize(this._direction)||(this._direction.x=1,this._direction.y=0,!1)}intersectUnboundedLine(t,e,r,i){const n=t.vectorTo(e),o=t.vectorTo(this._origin).crossProduct(n);i[0]=this._direction.crossProduct(n);const a=s.Geometry.conditionalDivideFraction(-o,i[0]);return void 0!==a?(r[0]=a,!0):(r[0]=0,!1)}projectionFraction(t){return this._origin.vectorTo(t).fractionOfProjectionToVector(this._direction)}perpendicularProjectionFraction(t){const e=this._direction.crossProduct(this._origin.vectorTo(t)),r=this._direction.magnitudeSquared();return s.Geometry.safeDivideFraction(e,r,0)}fractionToPoint(t){return this._origin.plusScaled(this._direction,t)}}e.Ray2d=Ray2d;class ConvexPolygon2d{constructor(t){this._hullPoints=[];for(const e of t)this._hullPoints.push(e)}static createHull(t){return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(t))}static createHullIsValidCheck(t){return ConvexPolygon2d.isValidConvexHull(t)?new ConvexPolygon2d(t):new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(t))}get points(){return this._hullPoints}static isValidConvexHull(t){if(t.length<3)return!1;const e=t.length;for(let r=0;r<e;r++){const i=(r+1)%e,n=(r+2)%e;if(t[r].crossProductToPoints(t[i],t[n])<0)return!1}return!0}containsPoint(t){let e=this._hullPoints[this._hullPoints.length-1];for(const r of this._hullPoints){const i=r;if(e.crossProductToPoints(i,t)<0)return!1;e=r}return!0}distanceOutside(t){let e=0;const r=this._hullPoints.length;let i=this._hullPoints[r-1];for(let n=0;n<r;n++){const r=this._hullPoints[n];if(i.crossProductToPoints(r,t)<0){const n=Ray2d.createOriginAndTarget(i,r),s=n.projectionFraction(t);let o=0;(o=s<0?i.distance(t):s>1?r.distance(t):t.distance(n.fractionToPoint(s)))>e&&(e=o)}i=this._hullPoints[n]}return e}offsetInPlace(t){const e=this._hullPoints.length;if(e>=3){const r=this._hullPoints[0];let n=this._hullPoints[e-1].vectorTo(r);if(void 0===(n=n.normalize()))return!1;let s,o,a=n.rotate90CWXY();for(let c=0;c<e;c++){const n=c+1;if(void 0===(s=(s=this._hullPoints[c].vectorTo(n<e?this._hullPoints[n]:r)).normalize()))return!1;o=s.rotate90CWXY();const l=i.Vector2d.createOffsetBisector(a,o,t);if(void 0===l)return!1;this._hullPoints[c]=this._hullPoints[c].plus(l),a=o}}return!0}clipRay(t){let e=-Number.MAX_VALUE,r=Number.MAX_VALUE;const i=this._hullPoints.length;if(i<3)return n.Range1d.createNull();let s=this._hullPoints[i-1];for(const a of this._hullPoints){const i=[],o=[];if(t.intersectUnboundedLine(s,a,i,o)){if(o[0]>0?i[0]<r&&(r=i[0]):i[0]>e&&(e=i[0]),e>r)return n.Range1d.createNull()}else if(s.crossProductToPoints(a,t.origin)<0)return n.Range1d.createNull();s=a}const o=n.Range1d.createNull();return o.extendX(e),o.extendX(r),o}rangeAlongRay(t){const e=n.Range1d.createNull();for(const r of this._hullPoints)e.extendX(t.projectionFraction(r));return e}rangePerpendicularToRay(t){const e=n.Range1d.createNull();for(const r of this._hullPoints)e.extendX(t.perpendicularProjectionFraction(r));return e}static computeConvexHull(t){const e=[],r=t.length;if(r<3)return e;const i=t.slice(0,r);i.sort(s.Geometry.lexicalXYLessThan),e.push(i[0]),e.push(i[1]);for(let s=2;s<r;s++){const t=i[s];let r=e.length-1;for(;r>0&&e[r-1].crossProductToPoints(e[r],t)<=0;)r--,e.pop();e.push(t)}const n=e.length-1;e.push(i[r-2]);for(let s=r-2;s-- >0;){const t=i[s];let r=e.length-1;for(;r>n&&e[r-1].crossProductToPoints(e[r],t)<=0;)r--,e.pop();s>0&&e.push(t)}return e}}e.ConvexPolygon2d=ConvexPolygon2d},"./lib/numerics/Newton.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point2dVector2d.js"),s=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),o=r("./lib/numerics/Polynomials.js");class AbstractNewtonIterator{constructor(t=1e-11,e=2,r=15){this._numAccepted=0,this.numIterations=0,this._stepSizeTolerance=t,this._successiveConvergenceTarget=e,this._maxIterations=r}testConvergence(t){return Math.abs(t)<this._stepSizeTolerance?(this._numAccepted++,this._numAccepted>=this._successiveConvergenceTarget):(this._numAccepted=0,!1)}runIterations(){for(this._numAccepted=0,this.numIterations=0;this.numIterations++<this._maxIterations&&this.computeStep();){if(this.testConvergence(this.currentStepSize())&&this.applyCurrentStep(!0))return!0;this.applyCurrentStep(!1)}return!1}}e.AbstractNewtonIterator=AbstractNewtonIterator;e.NewtonEvaluatorRtoRD=class NewtonEvaluatorRtoRD{};e.Newton1dUnbounded=class Newton1dUnbounded extends AbstractNewtonIterator{constructor(t){super(),this._func=t,this.setTarget(0)}setX(t){return this._currentX=t,!0}getX(){return this._currentX}setTarget(t){this._target=t}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const t=i.Geometry.conditionalDivideFraction(this._func.currentF-this._target,this._func.currentdFdX);if(void 0!==t)return this._currentStep=t,!0}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}};e.NewtonEvaluatorRtoR=class NewtonEvaluatorRtoR{};e.Newton1dUnboundedApproximateDerivative=class Newton1dUnboundedApproximateDerivative extends AbstractNewtonIterator{constructor(t){super(),this._func=t,this.derivativeH=1e-8}setX(t){return this._currentX=t,!0}getX(){return this._currentX}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const t=this._func.currentF;if(this._func.evaluate(this._currentX+this.derivativeH)){const e=this._func.currentF,r=i.Geometry.conditionalDivideFraction(t,(e-t)/this.derivativeH);if(void 0!==r)return this._currentStep=r,!0}}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}};e.NewtonEvaluatorRRtoRRD=class NewtonEvaluatorRRtoRRD{constructor(){this.currentF=s.Plane3dByOriginAndVectors.createXYPlane()}};e.Newton2dUnboundedWithDerivative=class Newton2dUnboundedWithDerivative extends AbstractNewtonIterator{constructor(t){super(),this._func=t,this._currentStep=n.Vector2d.createZero(),this._currentUV=n.Point2d.createZero()}setUV(t,e){return this._currentUV.set(t,e),!0}getU(){return this._currentUV.x}getV(){return this._currentUV.y}applyCurrentStep(){return this.setUV(this._currentUV.x-this._currentStep.x,this._currentUV.y-this._currentStep.y)}computeStep(){if(this._func.evaluate(this._currentUV.x,this._currentUV.y)){const t=this._func.currentF;if(o.SmallSystem.linearSystem2d(t.vectorU.x,t.vectorV.x,t.vectorU.y,t.vectorV.y,t.origin.x,t.origin.y,this._currentStep))return!0}return!1}currentStepSize(){return i.Geometry.maxAbsXY(this._currentStep.x/(1+Math.abs(this._currentUV.x)),this._currentStep.y/(1+Math.abs(this._currentUV.y)))}}},"./lib/numerics/PascalCoefficients.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class PascalCoefficients{static getRow(t){const e=PascalCoefficients._allRows;for(0===e.length&&(e.push(new Float64Array([1])),e.push(new Float64Array([1,1])),e.push(new Float64Array([1,2,1])),e.push(new Float64Array([1,3,3,1])),e.push(new Float64Array([1,4,6,4,1])),e.push(new Float64Array([1,5,10,10,5,1])),e.push(new Float64Array([1,6,15,20,15,6,1])),e.push(new Float64Array([1,7,21,35,35,21,7,1])));e.length<=t;){const t=e.length,r=e[t-1],i=new Float64Array(t+1);i[0]=1;for(let e=1;e<t;e++)i[e]=r[e-1]+r[e];i[t]=1,e.push(i)}return e[t]}static getBezierBasisValues(t,e,r){const i=t-1,n=PascalCoefficients.getRow(i);(void 0===r||r.length<t)&&(r=new Float64Array(t));for(let a=0;a<t;a++)r[a]=n[a];let s=e;for(let a=1;a<t;a++,s*=e)r[a]*=s;const o=1-e;s=o;for(let a=t-2;a>=0;a--,s*=o)r[a]*=s;return r}static getBezierBasisDerivatives(t,e,r){const i=t-1;(r=this.getBezierBasisValues(t-1,e,r))[t-1]=i*r[t-2];for(let n=t-2;n>0;n--)r[n]=i*(r[n-1]-r[n]);return r[0]=-i*r[0],r}}e.PascalCoefficients=PascalCoefficients,PascalCoefficients._allRows=[]},"./lib/numerics/Polynomials.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/Geometry.js"),o=r("./lib/geometry3d/GrowableFloat64Array.js");class Degree2PowerPolynomial{constructor(t=0,e=0,r=0){this.coffs=[t,e,r]}static solveQuadratic(t,e,r){const i=s.Geometry.conditionalDivideFraction(e,t),n=s.Geometry.conditionalDivideFraction(r,t);if(void 0!==i&&void 0!==n){const t=i*i-4*n;if(t>0){const e=Math.sqrt(t);return[.5*(-i-e),.5*(-i+e)]}if(t<0)return;const e=-.5*i;return[e,e]}const o=s.Geometry.conditionalDivideFraction(-r,e);if(void 0!==o)return[o]}addConstant(t){this.coffs[0]+=t}addSquaredLinearTerm(t,e,r=1){this.coffs[0]+=r*(t*t),this.coffs[1]+=r*(2*t*e),this.coffs[2]+=r*(e*e)}realRoots(){const t=Degree2PowerPolynomial.solveQuadratic(this.coffs[2],this.coffs[1],this.coffs[0]);if(t&&t.length>1&&t[0]>t[1]){const e=t[0];t[0]=t[1],t[1]=e}return t}evaluate(t){return this.coffs[0]+t*(this.coffs[1]+t*this.coffs[2])}evaluateDerivative(t){return this.coffs[1]+2*t*this.coffs[2]}tryGetVertexFactorization(){const t=s.Geometry.conditionalDivideFraction(-this.coffs[1],2*this.coffs[2]);if(void 0!==t){const e=this.evaluate(t);return{c:this.coffs[2],x0:t,y0:e}}}static fromRootsAndC2(t,e,r=1){return new Degree2PowerPolynomial(r*t*e,-r*(t+e),r)}}e.Degree2PowerPolynomial=Degree2PowerPolynomial;class Degree3PowerPolynomial{constructor(t=0,e=0,r=0,i=1){this.coffs=[t,e,r,i]}addConstant(t){this.coffs[0]+=t}addSquaredLinearTerm(t,e,r=1){this.coffs[0]+=r*(t*t),this.coffs[1]+=r*(2*t*e),this.coffs[2]+=r*(e*e)}evaluate(t){return this.coffs[0]+t*(this.coffs[1]+t*(this.coffs[2]+t*this.coffs[3]))}evaluateDerivative(t){return this.coffs[1]+t*(2*this.coffs[2]+3*t*this.coffs[3])}static fromRootsAndC3(t,e,r,i=1){return new Degree3PowerPolynomial(-i*t*e*r,i*(t*e+e*r+t*r),-i*(t+e+r),i)}}e.Degree3PowerPolynomial=Degree3PowerPolynomial;class Degree4PowerPolynomial{constructor(t=0,e=0,r=0,i=0,n=0){this.coffs=[t,e,r,i,n]}addConstant(t){this.coffs[0]+=t}evaluate(t){return this.coffs[0]+t*(this.coffs[1]+t*(this.coffs[2]+t*(this.coffs[3]+t*this.coffs[4])))}evaluateDerivative(t){return this.coffs[1]+t*(2*this.coffs[2]+t*(3*this.coffs[3]+4*t*this.coffs[4]))}static fromRootsAndC4(t,e,r,i,n=1){return new Degree4PowerPolynomial(n*(t*e*r*i),-n*(t*e*r+t*e*i+t*r*i+e*r*i),n*(t*e+t*r+t*i+e*r+e*i+r*i),-n*(t+e+r+i),n)}}e.Degree4PowerPolynomial=Degree4PowerPolynomial;e.TorusImplicit=class TorusImplicit{constructor(t,e){this.majorRadius=t,this.minorRadius=e}boxSize(){return Math.abs(this.majorRadius)+Math.abs(this.minorRadius)}implicitFunctionScale(){const t=this.boxSize();return 0===t?1:1/(t*t*t*t)}evaluateImplicitFunctionXYZ(t,e,r){const i=t*t+e*e,n=r*r,s=this.majorRadius*this.majorRadius,o=i+n+(s-this.minorRadius*this.minorRadius);return(o*o-4*s*i)*this.implicitFunctionScale()}evaluateImplicitFunctionPoint(t){return this.evaluateImplicitFunctionXYZ(t.x,t.y,t.z)}evaluateImplicitFunctionXYZW(t,e,r,i){const n=t*t+e*e,s=r*r,o=i*i,a=this.majorRadius*this.majorRadius,c=n+s+o*(a-this.minorRadius*this.minorRadius);return(c*c-4*o*a*n)*this.implicitFunctionScale()}evaluateThetaPhi(t,e){const r=Math.cos(t),i=Math.sin(t),s=this.majorRadius+this.minorRadius*Math.cos(e),o=this.minorRadius*Math.sin(e);return n.Point3d.create(r*s,i*s,o)}evaluateDerivativesThetaPhi(t,e,r,i){const s=Math.cos(t),o=Math.sin(t),a=this.minorRadius*Math.cos(e),c=this.minorRadius*Math.sin(e),l=this.majorRadius+a;n.Vector3d.create(-l*o,l*s,0,r),n.Vector3d.create(-s*c,-o*c,a,i)}evaluateThetaPhiDistance(t,e,r){const i=Math.cos(t),s=Math.sin(t),o=this.majorRadius+r*Math.cos(e),a=r*Math.sin(e);return n.Point3d.create(i*o,s*o,a)}xyzToThetaPhiDistance(t){const e=t.magnitudeXY(),r=s.Geometry.conditionalDivideFraction(this.majorRadius,e);let i,o;r?(i=!0,o=n.Point3d.create(r*t.x,r*t.y,0)):(i=!1,o=n.Point3d.create(t.x,t.y,0));const a=i?Math.atan2(t.y,t.x):0,c=n.Vector3d.createStartEnd(o,t).magnitude(),l=e-this.majorRadius;let d,h;return 0===t.z&&0===l?(h=0,d=!1):(h=Math.atan2(t.z,l),d=!0),{theta:a,phi:h,distance:c,rho:e,safePhi:i&&d}}};e.SphereImplicit=class SphereImplicit{constructor(t){this.radius=t}evaluateImplicitFunction(t,e,r){return t*t+e*e+r*r-this.radius*this.radius}evaluateImplicitFunctionXYZW(t,e,r,i){return t*t+e*e+r*r-this.radius*this.radius*i*i}xyzToThetaPhiR(t){const e=t.x*t.x+t.y*t.y,r=Math.sqrt(e),i=Math.sqrt(e+t.z*t.z);let n,s,o;return 0===i?(n=s=0,o=!1):(s=Math.atan2(t.z,r),0!==e?(n=Math.atan2(t.y,t.x),o=!0):(n=0,o=!1)),{thetaRadians:n,phiRadians:s,r:i,valid:o}}evaluateThetaPhi(t,e){const r=this.radius*Math.cos(t),i=this.radius*Math.sin(t),s=Math.cos(e),o=Math.sin(e);return n.Point3d.create(r*s,i*s,this.radius*o)}evaluateDerivativesThetaPhi(t,e,r,i){const s=this.radius*Math.cos(t),o=this.radius*Math.sin(t),a=Math.cos(e),c=Math.sin(e);n.Vector3d.create(-o*a,s*a,0,r),n.Vector3d.create(-s*c,-o*c,this.radius*a,i)}};class AnalyticRoots{static isZero(t){return Math.abs(t)<this._EQN_EPS}static isSmallRatio(t,e,r=1e-9,i=8e-16){return Math.abs(t)<=r||Math.abs(t)<i*Math.abs(e)}static cbrt(t){return t>0?Math.pow(t,1/3):t<0?-Math.pow(-t,1/3):0}static safeDivide(t,e,r,i=0,n){return Math.abs(r)>this._safeDivideFactor*Math.abs(e)?(t[n]=e/r,!0):(t[n]=i,!1)}static checkRootProximity(t,e){return 0===e?t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):e>0&&e+1<t.length?t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)&&t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)}static newtonMethodAdjustment(t,e,r){let i=t[r],n=0;for(let s=r-1;s>=0;s--)n=i+e*n,i=t[s]+e*i;if(Math.abs(n)>=1e-14*(1+Math.abs(e)))return i/n}static improveRoots(t,e,r,i){for(let n=0;n<r.length;n++){let s=this.newtonMethodAdjustment(t,r.atUncheckedIndex(n),e);if(void 0===s||0===s)continue;const o=r.atUncheckedIndex(n);let a=0,c=0;for(;void 0!==s&&0!==s&&a<10;){if(Math.abs(s)<1e-10*(1+Math.abs(r.atUncheckedIndex(n)))){if(++c>1)break}else c=0;const l=r.atUncheckedIndex(n)-s;if(r.reassign(n,l),i&&!this.checkRootProximity(r,n)){r.reassign(n,o);break}s=this.newtonMethodAdjustment(t,r.atUncheckedIndex(n),e),a++}}}static appendSolution(t,e){void 0!==t&&e.push(t)}static append2Solutions(t,e,r){r.push(t),r.push(e)}static appendLinearRoot(t,e,r){AnalyticRoots.appendSolution(s.Geometry.conditionalDivideFraction(-t,e),r)}static mostDistantFromMean(t){if(!t||0===t.length)return 0;let e=0;for(let n=0;n<t.length;n++)e+=t.atUncheckedIndex(n);e/=t.length;let r=0,i=t.atUncheckedIndex(0);for(let n=0;n<t.length;n++){const s=Math.abs(t.atUncheckedIndex(n)-e);s>r&&(r=s,i=t.atUncheckedIndex(n))}return i}static appendQuadraticRoots(t,e){const r=s.Geometry.conditionalDivideFraction(1,t[2]);if(!r)return void this.appendLinearRoot(t[0],t[1],e);const i=.5*t[1]*r,n=i*i-t[0]*r;if(this.isZero(n))this.appendSolution(-i,e);else if(!(n<0))if(n>0){const t=Math.sqrt(n);this.append2Solutions(t-i,-t-i,e)}else;}static addConstant(t,e){for(let r=0;r<e.length;r++)e.reassign(r,e.atUncheckedIndex(r)+t)}static appendCubicRootsUnsorted(t,e){let r,i,n,o,a,c,l,d;const h=s.Geometry.conditionalDivideFraction(1,t[3]);if(!h)return void this.appendQuadraticRoots(t,e);r=t[2]*h,i=t[1]*h,n=t[0]*h;const u=r/-3;if((d=(c=.5*(2/27*r*(o=r*r)-1/3*r*i+n))*c+(l=(a=(3*i-o)/9)*a*a))>=0&&this.isZero(d)){if(this.isZero(c))return e.push(u),e.push(u),void e.push(u);{const t=this.cbrt(-c);return t<0?(e.push(u+2*t),e.push(u-t),void e.push(u-t)):(e.push(u-t),e.push(u-t),void e.push(u+2*t))}}if(d<=0){const r=1/3*Math.acos(-c/Math.sqrt(-l)),i=2*Math.sqrt(-a);return e.push(u+i*Math.cos(r)),e.push(u-i*Math.cos(r+Math.PI/3)),e.push(u-i*Math.cos(r-Math.PI/3)),void this.improveRoots(t,3,e,!1)}{const r=Math.sqrt(d),i=this.cbrt(r-c),n=-this.cbrt(r+c);return e.push(u+i+n),void this.improveRoots(t,3,e,!1)}}static appendCubicRoots(t,e){this.appendCubicRootsUnsorted(t,e),e.sort()}static appendQuarticRoots(t,e){const r=new Float64Array(4);let i,n,s,a,c,l,d,h,u,f;const g=new Float64Array(1);if(!this.safeDivide(g,1,t[4],0,0))return void this.appendCubicRoots(t,e);s=t[3]*g[0],a=t[2]*g[0],c=t[1]*g[0],l=t[0]*g[0];const p=-.25*s;h=-3/8*(d=s*s)+a,u=.125*d*s-.5*s*a+c,f=-3/256*d*d+1/16*d*a-.25*s*c+l;const m=new o.GrowableFloat64Array;if(this.isZero(f))return r[0]=u,r[1]=h,r[2]=0,r[3]=1,this.appendCubicRootsUnsorted(r,e),e.push(0),void this.addConstant(p,e);{r[0]=.5*f*h-1/8*u*u,r[1]=-f,r[2]=-.5*h,r[3]=1,this.appendCubicRootsUnsorted(r,m);const t=this.mostDistantFromMean(m);if(i=t*t-f,n=2*t-h,this.isSmallRatio(i,f))i=0;else{if(!(i>0))return;i=Math.sqrt(i)}if(this.isSmallRatio(n,h))n=0;else{if(!(n>0)){for(let t=0;t<m.length;t++)e.push(m.atUncheckedIndex(t));return}n=Math.sqrt(n)}r[0]=t-i,r[1]=u<0?-n:n,r[2]=1,this.appendQuadraticRoots(r,e),r[0]=t+i,r[1]=u<0?n:-n,r[2]=1,this.appendQuadraticRoots(r,e)}this.addConstant(p,e),e.sort(),this.improveRoots(t,4,e,!0)}static appendCosSinRadians(t,e,r,i,n){r&&r.push(t),i&&i.push(e),n&&n.push(Math.atan2(e,t))}static appendImplicitLineUnitCircleIntersections(t,e,r,i,n,s,o=1e-14){let a;const c=e*e+r*r;let l=0;if(a=o<0?0:2*o,c<=0)l=0===t?-2:-1;else{const o=-t/c,d=1-t*t/c;if(d<-a){const a=Math.sqrt(c),d=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*r,i,n,s),this.appendCosSinRadians(e*d,r*d,i,n,s),l=0}else if(d<a){const a=Math.sqrt(c),d=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*r,i,n,s),this.appendCosSinRadians(e*d,r*d,i,n,s),l=1}else{const t=Math.sqrt(d/c),a=o*e,h=o*r;this.appendCosSinRadians(a-t*r,h+t*e,i,n,s),this.appendCosSinRadians(a+t*r,h-t*e,i,n,s),l=2}}return l}}e.AnalyticRoots=AnalyticRoots,AnalyticRoots._EQN_EPS=1e-9,AnalyticRoots._safeDivideFactor=1e-14;class PowerPolynomial{static degreeKnownEvaluate(t,e,r){if(e<0)return 0;let i=t[e];for(let n=e-1;n>=0;n--)i=r*i+t[n];return i}static evaluate(t,e){const r=t.length-1;return this.degreeKnownEvaluate(t,r,e)}static accumulate(t,e,r){let i=t.length-1;const n=e.length-1;for(let s=0;s<=n;s++)t[s]+=r*e[s];for(;i>=0&&0===t[i];)i--;return i}static zero(t){for(let e=0;e<t.length;e++)t[e]=0}}e.PowerPolynomial=PowerPolynomial;class TrigPolynomial{static solveAngles(t,e,r,i){let n,s=Math.abs(r);i.length=0;const a=this._smallAngle;for(let o=0;o<=e;o++)(n=Math.abs(t[o]))>s&&(s=n);const c=a*s;let l=e;for(;l>0&&Math.abs(t[l])<=c;)l--;const d=new o.GrowableFloat64Array;if(-1===l);else if(0===l||(1===l?d.push(-t[0]/t[1]):2===l?AnalyticRoots.appendQuadraticRoots(t,d):3===l?AnalyticRoots.appendCubicRoots(t,d):4===l&&AnalyticRoots.appendQuarticRoots(t,d)),d.length>0){for(let t=0;t<d.length;t++){const e=PowerPolynomial.evaluate(this.S,d.atUncheckedIndex(t)),r=PowerPolynomial.evaluate(this.C,d.atUncheckedIndex(t));i.push(Math.atan2(e,r))}l<e&&i.push(-.5*Math.PI)}return i.length>0}static solveUnitCircleImplicitQuadricIntersection(t,e,r,i,n,o,a){const c=new Float64Array(5);PowerPolynomial.zero(c);let l=2;s.Geometry.hypotenuseXYZ(t,e,r)>TrigPolynomial._coefficientRelTol*s.Geometry.hypotenuseXYZ(i,n,o)?(PowerPolynomial.accumulate(c,this.CW,i),PowerPolynomial.accumulate(c,this.SW,n),PowerPolynomial.accumulate(c,this.WW,o),PowerPolynomial.accumulate(c,this.SS,r),PowerPolynomial.accumulate(c,this.CC,t),PowerPolynomial.accumulate(c,this.SC,e),l=4):(PowerPolynomial.accumulate(c,this.C,i),PowerPolynomial.accumulate(c,this.S,n),PowerPolynomial.accumulate(c,this.W,o),l=2);let d=0;return d=Math.max(d,Math.abs(t),Math.abs(r),Math.abs(e),Math.abs(i),Math.abs(n),Math.abs(o)),this.solveAngles(c,l,d,a)}static solveUnitCircleEllipseIntersection(t,e,r,i,n,s,o,a){a.length=0;const c=r*r+i*i,l=2*(r*n+i*s),d=n*n+s*s,h=2*(r*t+i*e),u=2*(n*t+s*e),f=t*t+e*e-1,g=this.solveUnitCircleImplicitQuadricIntersection(c,l,d,h,u,f,o);for(const p of o){const o=Math.cos(p),c=Math.sin(p),l=t+r*o+n*c,d=e+i*o+s*c;a.push(Math.atan2(d,l))}return g}static solveUnitCircleHomogeneousEllipseIntersection(t,e,r,i,n,s,o,a,c,l,d){d.length=0;const h=i*i+n*n-s*s,u=2*(i*o+n*a-s*c),f=o*o+a*a-c*c,g=2*(i*t+n*e-s*r),p=2*(o*t+a*e-c*r),m=t*t+e*e-r*r,y=this.solveUnitCircleImplicitQuadricIntersection(h,u,f,g,p,m,l);for(const P of l){const r=Math.cos(P),s=Math.sin(P),c=t+i*r+o*s,l=e+n*r+a*s;d.push(Math.atan2(l,c))}return y}}e.TrigPolynomial=TrigPolynomial,TrigPolynomial._smallAngle=1e-11,TrigPolynomial.S=Float64Array.from([0,2,-2]),TrigPolynomial.C=Float64Array.from([1,-2]),TrigPolynomial.W=Float64Array.from([1,-2,2]),TrigPolynomial.CW=Float64Array.from([1,-4,6,-4]),TrigPolynomial.SW=Float64Array.from([0,2,-6,8,-4]),TrigPolynomial.SC=Float64Array.from([0,2,-6,4]),TrigPolynomial.SS=Float64Array.from([0,0,4,-8,4]),TrigPolynomial.CC=Float64Array.from([1,-4,4]),TrigPolynomial.WW=Float64Array.from([1,-4,8,-8,4]),TrigPolynomial.CCminusSS=Float64Array.from([1,-4,0,8,-4]),TrigPolynomial._coefficientRelTol=1e-12;class SmallSystem{static lineSegment2dXYTransverseIntersectionUnbounded(t,e,r,i,n){const o=e.x-t.x,a=e.y-t.y,c=i.x-r.x,l=i.y-r.y,d=r.x-t.x,h=r.y-t.y,u=s.Geometry.crossProductXYXY(o,a,c,l),f=s.Geometry.crossProductXYXY(d,h,c,l),g=s.Geometry.crossProductXYXY(o,a,d,h),p=s.Geometry.conditionalDivideFraction(f,u),m=s.Geometry.conditionalDivideFraction(g,u);return void 0!==p&&void 0!==m?(n.set(p,-m),!0):(n.set(0,0),!1)}static lineSegmentXYUVTransverseIntersectionUnbounded(t,e,r,i,n,o,a,c,l){const d=n-t,h=o-e,u=s.Geometry.crossProductXYXY(r,i,a,c),f=s.Geometry.crossProductXYXY(d,h,a,c),g=s.Geometry.crossProductXYXY(r,i,d,h),p=s.Geometry.conditionalDivideFraction(f,u),m=s.Geometry.conditionalDivideFraction(g,u);return void 0!==p&&void 0!==m?(l.set(p,-m),!0):(l.set(0,0),!1)}static lineSegment3dXYTransverseIntersectionUnbounded(t,e,r,i,n){const o=e.x-t.x,a=e.y-t.y,c=i.x-r.x,l=i.y-r.y,d=r.x-t.x,h=r.y-t.y,u=s.Geometry.crossProductXYXY(o,a,c,l),f=s.Geometry.crossProductXYXY(d,h,c,l),g=s.Geometry.crossProductXYXY(o,a,d,h),p=s.Geometry.conditionalDivideFraction(f,u),m=s.Geometry.conditionalDivideFraction(g,u);return void 0!==p&&void 0!==m?(n.set(p,-m),!0):(n.set(0,0),!1)}static lineSegment3dHXYTransverseIntersectionUnbounded(t,e,r,n,o){const a=s.Geometry.tripleProduct(t.x,e.x,r.x,t.y,e.y,r.y,t.w,e.w,r.w),c=s.Geometry.tripleProduct(t.x,e.x,n.x,t.y,e.y,n.y,t.w,e.w,n.w),l=s.Geometry.conditionalDivideFraction(-a,c-a);if(void 0!==l){const a=s.Geometry.tripleProduct(r.x,n.x,t.x,r.y,n.y,t.y,r.w,n.w,t.w),c=s.Geometry.tripleProduct(r.x,n.x,e.x,r.y,n.y,e.y,r.w,n.w,e.w),d=s.Geometry.conditionalDivideFraction(-a,c-a);if(void 0!==d)return i.Vector2d.create(d,l,o)}}static lineSegment3dHXYClosestPointUnbounded(t,e,r){const i=e.x*t.w-t.x*e.w,n=e.y*t.w-t.y*e.w,o=s.Geometry.tripleProduct(t.x,-n,r.x,t.y,i,r.y,t.w,0,r.w),a=s.Geometry.tripleProduct(e.x,-n,r.x,e.y,i,r.y,e.w,0,r.w);return s.Geometry.conditionalDivideFraction(-o,a-o)}static lineSegment3dXYClosestPointUnbounded(t,e,r){const i=e.x-t.x,n=e.y-t.y,o=i*i+n*n,a=i*(r.x-t.x)+n*(r.y-t.y);return s.Geometry.conditionalDivideFraction(a,o)}static lineSegment3dClosestPointUnbounded(t,e,r){const i=e.x-t.x,n=e.y-t.y,o=e.z-t.z,a=i*i+n*n+o*o,c=i*(r.x-t.x)+n*(r.y-t.y)+o*(r.z-t.z);return s.Geometry.conditionalDivideFraction(c,a)}static lineSegment3dClosestApproachUnbounded(t,e,r,i,n){return this.ray3dXYZUVWClosestApproachUnbounded(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,r.x,r.y,r.z,i.x-r.x,i.y-r.y,i.z-r.z,n)}static ray3dXYZUVWClosestApproachUnbounded(t,e,r,i,n,o,a,c,l,d,h,u,f){const g=a-t,p=c-e,m=l-r,y=s.Geometry.hypotenuseSquaredXYZ(i,n,o),P=s.Geometry.hypotenuseSquaredXYZ(d,h,u),x=s.Geometry.dotProductXYZXYZ(i,n,o,d,h,u),_=s.Geometry.dotProductXYZXYZ(g,p,m,i,n,o),v=s.Geometry.dotProductXYZXYZ(g,p,m,d,h,u);return SmallSystem.linearSystem2d(y,-x,x,-P,_,v,f)}static linearSystem2d(t,e,r,i,n,o,a){const c=s.Geometry.crossProductXYXY(t,r,e,i),l=s.Geometry.crossProductXYXY(n,o,e,i),d=s.Geometry.crossProductXYXY(t,r,n,o),h=s.Geometry.conditionalDivideFraction(l,c),u=s.Geometry.conditionalDivideFraction(d,c);return void 0!==h&&void 0!==u?(a.set(h,u),!0):(a.set(0,0),!1)}static linearSystem3d(t,e,r,i,o,a,c,l,d,h,u,f,g){const p=s.Geometry.tripleProduct(t,i,c,e,o,l,r,a,d),m=s.Geometry.tripleProduct(h,u,f,e,o,l,r,a,d),y=s.Geometry.tripleProduct(t,i,c,h,u,f,r,a,d),P=s.Geometry.tripleProduct(h,u,f,e,o,l,h,u,f),x=s.Geometry.conditionalDivideFraction(m,p),_=s.Geometry.conditionalDivideFraction(y,p),v=s.Geometry.conditionalDivideFraction(P,p);if(void 0!==x&&void 0!==_&&void 0!==_)return n.Vector3d.create(x,_,v,g)}static eliminateFromPivot(t,e,r,i){const n=t.length;let o=s.Geometry.conditionalDivideFraction(r[e],t[e]);if(void 0===o)return!1;o*=i;for(let s=e+1;s<n;s++)r[s]+=o*t[s];return!0}static solveBilinearPair(t,e,r,n,o,a,c,l){const d=s.Geometry.crossProductXYXY(t,o,r,c),h=s.Geometry.crossProductXYXY(e,a,r,c)+s.Geometry.crossProductXYXY(t,o,n,l),u=s.Geometry.crossProductXYXY(e,a,n,l),f=Degree2PowerPolynomial.solveQuadratic(u,h,d);if(void 0===f)return;const g=[];for(const p of f){const d=s.Geometry.conditionalDivideFraction(-(t+e*p),r+n*p),h=s.Geometry.conditionalDivideFraction(-(o+a*p),c+l*p);void 0!==d?g.push(i.Point2d.create(p,d)):void 0!==h&&g.push(i.Point2d.create(p,h))}return g}}e.SmallSystem=SmallSystem;class BilinearPolynomial{constructor(t,e,r,i){this.a=t,this.b=e,this.c=r,this.d=i}evaluate(t,e){return this.a+this.b*t+e*(this.c+this.d*t)}static createUnitSquareValues(t,e,r,i){return new BilinearPolynomial(t,e,e,i-e-r)}static solvePair(t,e,r,i){return SmallSystem.solveBilinearPair(t.a-e,t.b,t.c,t.d,r.a-i,r.b,r.c,r.d)}}e.BilinearPolynomial=BilinearPolynomial},"./lib/numerics/Quadrature.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class Quadrature{static mapWeights(t,e,r,i,n,s){const o=r.length;for(let a=0;a<o;a++)n[a]=t+e*r[a],s[a]=e*i[a];return o}static setupGauss1(t,e,r,i){return Quadrature.mapWeights(t,e-t,Quadrature.gaussX1Interval01,Quadrature.gaussW1Interval01,r,i)}static setupGauss2(t,e,r,i){return Quadrature.mapWeights(t,e-t,Quadrature.gaussX2Interval01,Quadrature.gaussW2Interval01,r,i)}static setupGauss3(t,e,r,i){return Quadrature.mapWeights(t,e-t,Quadrature.gaussX3Interval01,Quadrature.gaussW3Interval01,r,i)}static setupGauss5(t,e,r,i){return Quadrature.mapWeights(t,e-t,Quadrature.gaussX5Interval01,Quadrature.gaussW5Interval01,r,i)}static setupGauss4(t,e,r,i){return Quadrature.mapWeights(t,e-t,Quadrature.gaussX4Interval01,Quadrature.gaussW4Interval01,r,i)}static sum1(t,e,r,i){let n=0;for(let s=0;s<r;s++)n+=e[s]*i(t[s]);return n}}e.Quadrature=Quadrature,Quadrature.gaussX1Interval01=new Float64Array([.5]),Quadrature.gaussW1Interval01=new Float64Array([1]),Quadrature.gaussX2Interval01=new Float64Array([.21132486540518708,.7886751345948129]),Quadrature.gaussW2Interval01=new Float64Array([.5,.5]),Quadrature.gaussX3Interval01=new Float64Array([.1127016653792583,.5,.8872983346207417]),Quadrature.gaussW3Interval01=new Float64Array([.2777777777777778,.4444444444444444,.2777777777777778]),Quadrature.gaussX4Interval01=new Float64Array([.06943184420297371,.33000947820757187,.6699905217924281,.9305681557970262]),Quadrature.gaussW4Interval01=new Float64Array([.17392742256872692,.3260725774312731,.3260725774312731,.17392742256872692]),Quadrature.gaussX5Interval01=new Float64Array([.04691007703066802,.23076534494715845,.5,.7692346550528415,.9530899229693319]),Quadrature.gaussW5Interval01=new Float64Array([.11846344252809454,.23931433524968324,.28444444444444444,.23931433524968324,.11846344252809454]);e.GaussMapper=class GaussMapper{constructor(t){switch(this.gaussX=new Float64Array(7),this.gaussW=new Float64Array(7),(t>5||t<1)&&(t=5),t){case 1:this.mapXAndWFunction=Quadrature.setupGauss1;break;case 2:this.mapXAndWFunction=Quadrature.setupGauss2;break;case 3:this.mapXAndWFunction=Quadrature.setupGauss3;break;case 4:this.mapXAndWFunction=Quadrature.setupGauss4;break;default:this.mapXAndWFunction=Quadrature.setupGauss5}}mapXAndW(t,e){return this.mapXAndWFunction(t,e,this.gaussX,this.gaussW)}}},"./lib/numerics/Range1dArray.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js"),n=r("./lib/geometry3d/GrowableFloat64Array.js"),s=r("./lib/Geometry.js");class Range1dArray{static advanceIntervalDifference(t,e,r,n){const s=e.length;let o=t.low,a=t.high;for(;r<s;){const t=e[r];if(t.high<o)r++;else{if(!(t.high<=a)){t.low<a&&(a=t.low);break}t.low>o&&n.push(i.Range1d.createXX(o,t.low)),o=t.high,r++}}return o<a&&n.push(i.Range1d.createXX(o,a)),n}static differenceSorted(t,e){const r=t.length,i=[];for(let n=0;n<r;n++)Range1dArray.advanceIntervalDifference(t[n],e,0,i);return i}static advanceIntervalIntersection(t,e,r){return e.low>t.high||(e.high>=t.high?(r.push(i.Range1d.createXX(e.low,t.high)),!0):(r.push(i.Range1d.createXX(e.low,e.high)),!1))}static intersectSorted(t,e){let r=0,i=0;const n=t.length,s=e.length,o=[];for(;r<n&&i<s;){const n=t[r],s=e[i];n.low<=s.low?Range1dArray.advanceIntervalIntersection(n,s,o)?r++:i++:Range1dArray.advanceIntervalIntersection(s,n,o)?i++:r++}return o}static advanceIntervalUnion(t,e,r){if(r>=e.length)return!1;const i=e[r];return!(i.low>t.high)&&(i.high>t.high&&(t.high=i.high),!0)}static unionSorted(t,e){const r=t.length,i=e.length;let n=0,s=0;const o=[];for(;n<r&&s<i;){const r=t[n],i=e[s];let a;r.low<=i.low?(a=r.clone(),n++):(a=i.clone(),s++);let c=!0;do{const r=Range1dArray.advanceIntervalUnion(a,t,n),i=Range1dArray.advanceIntervalUnion(a,e,s);r&&n++,i&&s++,r||i||(c=!1)}while(c);o.push(a)}for(;n<r;)o.push(t[n++]);for(;s<i;)o.push(e[s++]);return o}static paritySorted(t,e){const r=[];for(const i of t)r.push(i.clone());for(const i of e)r.push(i.clone());return r.sort(o),Range1dArray.simplifySortParity(r,!0),r}static sort(t){t.sort(o)}static simplifySortUnion(t,e=!1){if(t.length<2)return;t.sort(o);let r=0,i=!1;for(let n=0;n<t.length;n++){if(n===t.length-1){i&&(e&&t[n].low===t[n].high||(t[r++]=t[n]));break}t[n+1].low>t[n].high?e&&t[n].low===t[n].high||(t[r++]=t[n]):(t[n+1].low=t[n].low,t[n+1].high=Math.max(t[n].high,t[n+1].high),i=!0)}t.length=r}static simplifySortParity(t,e=!1){const r=[];for(const i of t)i.low!==i.high&&(r.push(i.low),r.push(i.high));const n=r.length;r.sort((t,e)=>t<e?-1:t>e?1:0);let s,o,a=0;for(let c=0;c<n;c+=2)if(s=r[c],o=r[c+1],e){for(;c+2<n&&r[c+2]===o;)o=r[(c+=2)+1];o>s&&i.Range1d.createXX(s,o,t[a++])}else i.Range1d.createXX(s,o,t[a++]);t.length=a}static testUnion(t,e){return this.countContainingRanges(t,e)>0}static testParity(t,e){let r=!1;for(const i of t)i.containsX(e)&&(r=!r);return r}static countContainingRanges(t,e){let r=0;for(const i of t)i.containsX(e)&&r++;return r}static getBreaks(t,e,r=!1,i=!1,s=!0){e||(e=new n.GrowableFloat64Array(2*t.length)),s&&e.clear();for(const n of t)e.push(n.low),e.push(n.high);return r&&e.sort(),i&&e.compressAdjacentDuplicates(),e}static appendFractionalPoints(t,e,r,i,n,o,a,c){const l=t.length;if(l>0){void 0!==e&&c.push(t[0].fractionToPoint(e));for(let e=0;e<l;e++)void 0===r||!i&&t[e].low===t[e].high||c.push(t[e].fractionToPoint(r)),e>1&&void 0!==n&&(o||t[e].low!==t[e].high)&&c.push(s.Geometry.interpolate(t[e-1].high,n,t[e].low));void 0!==a&&c.push(t[l-1].fractionToPoint(a))}return c}static firstLowToLastHigh(t){return 0===t.length?i.Range1d.createNull():i.Range1d.createXX(t[0].low,t[t.length-1].high)}static sumLengths(t){let e=0;for(const r of t)e+=r.length();return e}static isSorted(t,e=!0){const r=t.length;if(e){for(let i=0;i+1<r;i++)if(t[i].high>=t[i+1].low)return!1}else for(let i=0;i+1<r;i++)if(t[i].high>t[i+1].low)return!1;return!0}}function o(t,e){return t.low<e.low?-1:t.low>e.low?1:t.high<e.high?-1:t.high>e.high?1:0}e.Range1dArray=Range1dArray,e.compareRange1dLexicalLowHigh=o},"./lib/numerics/TriDiagonalSystem.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js");var s;!function(t){t[t.RawMatrix=0]="RawMatrix",t[t.FactorOK=1]="FactorOK",t[t.FactorFailed=2]="FactorFailed"}(s||(s={}));class TriDiagonalSystem{constructor(t){this._aLeft=new Float64Array(t),this._aDiag=new Float64Array(t),this._aRight=new Float64Array(t),this._b=new Float64Array(t),this._x=new Float64Array(t),this.reset()}reset(){this._dataState=s.RawMatrix;const t=this._aDiag.length;for(let e=0;e<t;e++)this._aLeft[e]=this._aRight[e]=this._aDiag[e]=this._b[e]=this._x[e]=0}setRow(t,e,r,i){this._aLeft[t]=e,this._aDiag[t]=r,this._aRight[t]=i}addToRow(t,e,r,i){this._aLeft[t]+=e,this._aDiag[t]+=r,this._aRight[t]+=i}setB(t,e){this._b[t]=e}addToB(t,e){this._b[t]+=e}getB(t){return this._b[t]}setX(t,e){this._x[t]=e}getX(t){return this._x[t]}order(){return this._aDiag.length}multiplyAX(){if(this._dataState===s.FactorFailed)return!1;if(this._dataState===s.FactorOK){const t=this._aDiag.length-1;for(let e=0;e<t;e++)this._b[e]=this._aDiag[e]*this._x[e]+this._aRight[e]*this._x[e+1];this._b[t]=this._aDiag[t]*this._x[t];for(let e=t;e>0;e--)this._b[e]+=this._aLeft[e]*this._b[e-1];return!0}{const t=this._aDiag.length,e=t-1;let r;for(this._b[0]=this._aDiag[0]*this._x[0]+this._aRight[0]*this._x[1],r=1;r<e;r++)this._b[r]=this._aLeft[r]*this._x[r-1]+this._aDiag[r]*this._x[r]+this._aRight[r]*this._x[r+1];return this._b[e]=this._aLeft[e]*this._x[t-2]+this._aDiag[r]*this._x[e],!0}}multiplyAXPoints(t,e){for(e.length=0;e.length<t.length;)e.push(n.Point3d.create());if(e.length=t.length,this._dataState===s.FactorFailed)return!1;if(this._dataState===s.FactorOK){const r=this._aDiag.length-1;for(let i=0;i<r;i++)n.Point3d.createAdd2Scaled(t[i],this._aDiag[i],t[i+1],this._aRight[i],e[i]);n.Point3d.createScale(t[r],this._aDiag[r],e[r]);for(let t=r;t>0;t--)e[t].plusScaled(e[t-1],this._aLeft[t],e[t]);return!0}{const r=this._aDiag.length,i=r-1;let s;for(n.Point3d.createAdd2Scaled(t[0],this._aDiag[0],t[1],this._aRight[0],e[0]),s=1;s<i;s++)n.Point3d.createAdd3Scaled(t[s-1],this._aLeft[s],t[s],this._aDiag[s],t[s+1],this._aRight[s],e[s]);return n.Point3d.createAdd2Scaled(t[r-2],this._aLeft[i],t[i],this._aDiag[i],e[i]),!0}}defactor(){if(this._dataState===s.RawMatrix)return!0;if(this._dataState===s.FactorFailed)return!1;for(let t=this._aDiag.length-1;t>0;t--)this._aDiag[t]+=this._aLeft[t]*this._aRight[t-1],this._aLeft[t]*=this._aDiag[t-1];return this._dataState=s.RawMatrix,!0}factor(){if(this._dataState===s.FactorOK)return!0;if(this._dataState!==s.RawMatrix)return!1;this._dataState=s.FactorFailed;const t=this._aDiag.length-1;for(let e=0;e<t;e++){const t=i.Geometry.conditionalDivideFraction(this._aLeft[e+1],this._aDiag[e]);if(!t)return!1;this._aLeft[e+1]=t,this._aDiag[e+1]-=t*this._aRight[e]}return this._dataState=s.FactorOK,!0}factorAndBackSubstitute(){const t=this._aDiag.length,e=t-1;if(!this.factor())return!1;for(let r=0;r<t;r++)this._x[r]=this._b[r];for(let r=1;r<t;r++)this._x[r]-=this._aLeft[r]*this._x[r-1];this._x[e]/=this._aDiag[e];for(let r=e-1;r>=0;r--)this._x[r]=(this._x[r]-this._aRight[r]*this._x[r+1])/this._aDiag[r];return!0}factorAndBackSubstitutePointArrays(t,e){const r=this._aDiag.length;if(t.length<r)return!1;for(;e.length<r;)e.push(n.Point3d.create(0,0,0));e.length=r;const i=r-1;if(!this.factor())return!1;if(t!==e)for(let n=0;n<r;n++)e[n].setFrom(t[n]);let s,o;for(let n=1;n<r;n++)s=this._aLeft[n],e[n].x-=s*e[n-1].x,e[n].y-=s*e[n-1].y,e[n].z-=s*e[n-1].z;o=1/this._aDiag[i],e[i].x*=o,e[i].y*=o,e[i].z*=o;for(let n=i-1;n>=0;n--)s=this._aRight[n],o=1/this._aDiag[n],e[n].x=(e[n].x-s*e[n+1].x)*o,e[n].y=(e[n].y-s*e[n+1].y)*o,e[n].z=(e[n].z-s*e[n+1].z)*o;return!0}copy(){const t=this._aDiag.length,e=new TriDiagonalSystem(t);for(let r=0;r<t;r++)e._aLeft[r]=this._aLeft[r],e._aDiag[r]=this._aDiag[r],e._aRight[r]=this._aRight[r],e._x[r]=this._x[r],e._b[r]=this._b[r];return e._dataState=this._dataState,e}flatten(){const t=this._aDiag.length,e=[];for(let r=0;r<t;r++)e.push([r,[this._aLeft[r],this._aDiag[r],this._aRight[r]],this._x[r],this._b[r]]);return e}flattenWithPoints(t){const e=this._aDiag.length,r=[];for(let i=0;i<e;i++)r.push([i,[this._aLeft[i],this._aDiag[i],this._aRight[i]],this._x[i],t[i].toJSON()]);return r}}e.TriDiagonalSystem=TriDiagonalSystem},"./lib/numerics/UnionFind.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.UnionFindContext=class UnionFindContext{constructor(t=0){this._parentArray=[];for(let e=0;e<t;e++)this._parentArray.push(e)}get length(){return this._parentArray.length}isValidIndex(t){return 0<=t&&t<this._parentArray.length}addLeaf(){const t=this._parentArray.length;return this._parentArray.push(t),t}findRoot(t){if(!this.isValidIndex(t))return t;let e=t,r=this._parentArray[t];for(;r!==e;)e=r,r=this._parentArray[e];const i=e;for(e=t;e!==i;)r=this._parentArray[e],this._parentArray[e]=i,e=r;return i}mergeSubsets(t,e){if(!this.isValidIndex(t)||!this.isValidIndex(e))return t;const r=this.findRoot(t),i=this.findRoot(e);return r!==i&&(this._parentArray[r]=i),this.findRoot(t)}askParent(t){return this.isValidIndex(t)?this._parentArray[t]:t}countRoots(){let t=0;const e=this._parentArray.length;for(let r=0;r<e;r++)this._parentArray[r]===r&&t++;return t}countNonTrivialPaths(){let t=0;const e=this._parentArray.length;for(let r=0;r<e;r++){const e=this._parentArray[r];e!==r&&this._parentArray[e]!==e&&t++}return t}collectRootIndices(){const t=[],e=this._parentArray.length;for(let r=0;r<e;r++)this._parentArray[r]===r&&t.push(r);return t}}},"./lib/numerics/UsageSums.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js"),n=r("./lib/Geometry.js");class UsageSums{constructor(t=0){this._minMax=i.Range1d.createNull(),this._count=this._sumX=this._sumXX=0,this._origin=t}get count(){return this._count}get mean(){return this._count>0?this._sumX/this._count:0}get meanSquare(){return this._count>0?this._sumXX/this._count:0}get minMax(){return this._minMax.clone()}get standardDeviation(){if(this._count<1)return 0;const t=this.mean,e=this._sumXX,r=this._sumX;return Math.sqrt((e-2*t*r+this._count*t*t)/this._count)}clearSums(){this._count=this._sumX=this._sumXX=0,this._minMax.setNull()}get origin(){return this._origin}setOrigin(t){this._origin=t}shiftOriginAndSums(t){const e=t-this._origin;this._origin=t,this._sumXX=this._sumXX-2*e*this._sumX+this._count*e*e,this._sumX=this._sumX-this._count*e,this._minMax.cloneTranslated(-e,this._minMax)}accumulate(t){t-=this._origin,this._count+=1,this._sumX+=t,this._sumXX+=t*t,this._minMax.extendX(t)}accumulateArray(t){for(const e of t)this.accumulate(e)}clone(t){return t||(t=new UsageSums),this._minMax.clone(t._minMax),t._count=this._count,t._origin=this._origin,t._sumX=this._sumX,t._sumXX=this._sumXX,t}isAlmostEqual(t){return n.Geometry.isAlmostEqualNumber(this._sumX,t._sumX)&&n.Geometry.isAlmostEqualNumber(this._sumXX,t._sumXX)&&n.Geometry.isAlmostEqualNumber(this._origin,t._origin)&&this._count===t._count&&this._minMax.isAlmostEqual(t._minMax)}}e.UsageSums=UsageSums},"./lib/polyface/AuxData.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js"),n=r("./lib/geometry3d/PointHelpers.js");var s;!function(t){t[t.Scalar=0]="Scalar",t[t.Distance=1]="Distance",t[t.Vector=2]="Vector",t[t.Normal=3]="Normal"}(s=e.AuxChannelDataType||(e.AuxChannelDataType={}));class AuxChannelData{constructor(t,e){this.input=t,this.values=e}copyValues(t,e,r,i){for(let n=0;n<i;n++)this.values[e*i+n]=t.values[r*i+n]}clone(){return new AuxChannelData(this.input,this.values.slice())}isAlmostEqual(t,e){const r=e||1e-8;return Math.abs(this.input-t.input)<r&&n.NumberArray.isAlmostEqual(this.values,t.values,r)}}e.AuxChannelData=AuxChannelData;class AuxChannel{constructor(t,e,r,i){this.data=t,this.dataType=e,this.name=r,this.inputName=i}clone(){const t=[];for(const e of this.data)t.push(e.clone());return new AuxChannel(t,this.dataType,this.name,this.inputName)}isAlmostEqual(t,e){if(this.dataType!==t.dataType||this.name!==t.name||this.inputName!==t.inputName||this.data.length!==t.data.length)return!1;for(let r=0;r<this.data.length;r++)if(!this.data[r].isAlmostEqual(t.data[r],e))return!1;return!0}get isScalar(){return this.dataType===s.Distance||this.dataType===s.Scalar}get entriesPerValue(){return this.isScalar?1:3}get valueCount(){return 0===this.data.length?0:this.data[0].values.length/this.entriesPerValue}get scalarRange(){if(!this.isScalar)return;const t=i.Range1d.createNull();for(const e of this.data)t.extendArray(e.values);return t}}e.AuxChannel=AuxChannel;class PolyfaceAuxData{constructor(t,e){this.channels=t,this.indices=e}clone(){const t=[];for(const e of this.channels)t.push(e.clone());return new PolyfaceAuxData(t,this.indices.slice())}isAlmostEqual(t,e){if(!n.NumberArray.isExactEqual(this.indices,t.indices)||this.channels.length!==t.channels.length)return!1;for(let r=0;r<this.channels.length;r++)if(!this.channels[r].isAlmostEqual(t.channels[r],e))return!1;return!0}static isAlmostEqual(t,e,r){return t===e||!(!t||!e)&&t.isAlmostEqual(e,r)}createForVisitor(){const t=[];for(const e of this.channels){const r=[];for(const t of e.data)r.push(new AuxChannelData(t.input,[]));t.push(new AuxChannel(r,e.dataType,e.name,e.inputName))}return new PolyfaceAuxData(t,[])}}e.PolyfaceAuxData=PolyfaceAuxData},"./lib/polyface/BoxTopology.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js");class BoxTopology{}e.BoxTopology=BoxTopology,BoxTopology.points=[i.Point3d.create(0,0,0),i.Point3d.create(1,0,0),i.Point3d.create(0,1,0),i.Point3d.create(1,1,0),i.Point3d.create(0,0,1),i.Point3d.create(1,0,1),i.Point3d.create(0,1,1),i.Point3d.create(1,1,1)],BoxTopology.primaryCapId=-1,BoxTopology.cornerIndexCCW=[[1,0,2,3],[4,5,7,6],[0,1,5,4],[1,3,7,5],[3,2,6,7],[2,0,4,6]],BoxTopology.partnerFace=[[5,4,3,2],[2,3,4,5],[0,3,1,5],[0,4,1,2],[0,5,1,3],[0,2,1,4]],BoxTopology.faceId=[[BoxTopology.primaryCapId,0],[BoxTopology.primaryCapId,1],[0,0],[0,1],[0,2],[0,3]],BoxTopology.faceDirections=[[[0,1,2],[-1,1,-1]],[[0,1,2],[1,1,1]],[[0,2,1],[1,-1,1]],[[1,2,0],[1,1,1]],[[0,2,1],[-1,1,1]],[[1,2,0],[-1,1,-1]]],BoxTopology.axisEdgeVertex=[[[0,1],[2,3],[4,5],[6,7]],[[0,2],[1,3],[4,6],[5,7]],[[0,4],[1,5],[2,6],[3,7]]]},"./lib/polyface/FacetFaceData.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/Range.js"),o=r("./lib/polyface/Polyface.js");class FacetFaceData{constructor(t,e){this._paramDistanceRange=t,this._paramRange=e}get paramDistanceRange(){return this._paramDistanceRange}get paramRange(){return this._paramRange}static createNull(){return new FacetFaceData(s.Range2d.createNull(),s.Range2d.createNull())}clone(t){return t?(this._paramDistanceRange.clone(t._paramDistanceRange),this._paramRange.clone(t._paramRange),t):new FacetFaceData(this._paramDistanceRange.clone(),this._paramRange.clone())}setNull(){this._paramDistanceRange.setNull(),this._paramRange.setNull()}convertParamXYToDistance(t,e,r){r=r||i.Point2d.create();const n=this._paramRange.high.minus(this._paramRange.low);return r.x=0===n.x?t:this._paramDistanceRange.low.x+(t-this._paramRange.low.x)*(this._paramDistanceRange.high.x-this._paramDistanceRange.low.x)/n.x,r.y=0===n.y?e:this.paramDistanceRange.low.y+(e-this._paramRange.low.y)*(this._paramDistanceRange.high.y-this._paramDistanceRange.low.y)/n.y,r}convertParamXYToNormalized(t,e,r){r=r||i.Point2d.create();const n=this._paramRange.high.minus(this._paramRange.low);return r.x=0===n.x?t:(t-this._paramRange.low.x)/n.x,r.y=0===n.y?e:(e-this._paramRange.low.y)/n.y,r}convertParamToDistance(t,e){return this.convertParamXYToDistance(t.x,t.y,e)}convertParamToNormalized(t,e){return this.convertParamXYToNormalized(t.x,t.y,e)}scaleDistances(t){this._paramDistanceRange.low.x*=t,this._paramDistanceRange.low.y*=t,this._paramDistanceRange.high.x*=t,this._paramDistanceRange.high.y*=t}setParamDistanceRangeFromNewFaceData(t,e,r){const s=i.Point2d.create(),a=i.Point2d.create();this.setNull();let c=0;const l=o.IndexedPolyfaceVisitor.create(t,0);if(!l.moveToReadIndex(e)||r<=e)return!1;do{const t=l.numEdgesThisFacet,e=l.point,r=[],o=l.param,d=[];if(!o)return!1;o.extendRange(this._paramRange);const h=i.Vector2d.create(),u=i.Vector2d.create();for(let l=0;l<t;l++){if(r[2]=l,d[2]=l,l>1){o.vectorIndexIndex(d[1],d[0],h),o.vectorIndexIndex(d[1],d[2],u);const t=e.getPoint3dAtUncheckedPointIndex(r[0]).minus(e.getPoint3dAtUncheckedPointIndex(r[1])),l=e.getPoint3dAtUncheckedPointIndex(r[1]).minus(e.getPoint3dAtUncheckedPointIndex(r[2])),f=Math.abs(h.x*u.y-u.x*h.y);if(f){const e=n.Point3d.createFrom(t);e.scaleInPlace(u.y),e.addScaledInPlace(l,-h.y);const r=n.Point3d.createFrom(l);r.scaleInPlace(h.x),r.addScaledInPlace(t,-u.x);const o=i.Point2d.create(e.magnitude()/f,r.magnitude()/f);s.x+=o.x,s.y+=o.y,a.x+=o.x*o.x,a.y+=o.y*o.y,c++}}d[0]=d[1],d[1]=d[2],r[0]=r[1],r[1]=r[2]}}while(l.moveToNextFacet()&&l.currentReadIndex()<r);if(0!==c){const t=i.Point2d.create(s.x/c,s.y/c),e=i.Point2d.create(Math.sqrt(Math.abs(a.x/c-t.x*t.x)),Math.sqrt(Math.abs(a.y/c-t.y*t.y)));this._paramDistanceRange.low.set(0,0),this._paramDistanceRange.high.set((t.x+e.x)*(this._paramRange.high.x-this._paramRange.low.x),(t.y+e.y)*(this._paramRange.high.y-this._paramRange.low.y))}return!0}}e.FacetFaceData=FacetFaceData},"./lib/polyface/GreedyTriangulationBetweenLineStrings.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/Geometry.js"),s=r("./lib/polyface/TriangleCandidate.js"),o=r("./lib/geometry3d/Angle.js"),a=r("./lib/geometry3d/GrowableXYZArray.js"),c=r("./lib/geometry3d/IndexedCollectionInterval.js");class GreedyTriangulationBetweenLineStrings{constructor(t){this._turnRadians=t,this._xyzA=i.Point3d.create(),this._xyzB=i.Point3d.create(),this._forwardA=i.Vector3d.create(),this._forwardB=i.Vector3d.create(),this._vector1=i.Vector3d.create(),this._crossA=i.Vector3d.create(),this._crossB=i.Vector3d.create()}isForwardVector(t,e,r){if(t.dotProduct(e)<=0)return!1;const i=t.angleFromPerpendicular(r);return!(Math.abs(i.radians)>this._turnRadians)}isPlanarBase(t,e,r,n,s,o,a,c,l,d){return e+1<t.length&&n+1<r.length&&(t.getPoint3dAtUncheckedPointIndex(e,s),r.getPoint3dAtUncheckedPointIndex(n,c),t.vectorXYAndZIndex(s,e+1,a),r.vectorXYAndZIndex(c,n+1,d),i.Vector3d.createStartEnd(s,c,this._vector1),this._vector1.crossProduct(a,o),this._vector1.crossProduct(d,l),!s.isAlmostEqual(c)&&o.angleTo(l).radians<this._turnRadians)}advanceToPlanarLimit(t,e,r,i,n,s,o,a){for(e.setFrom(t,t.begin,r);e.end<t.end&&(e.points.vectorXYAndZIndex(i,e.end,this._vector1),this.isForwardVector(this._vector1,s,n))&&this.isForwardVector(this._vector1,a,o)&&(!(e.end>0)||(e.points.vectorIndexIndex(e.end-1,e.end,this._vector1),this.isForwardVector(this._vector1,s,n)));)e.end++}addGreedy(t,e,r,i=!1){for(t.restrictEnd(),e.restrictEnd();t.length>1&&e.length>1;)if(this._triangleA1=s.TriangleCandidate.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,1,this._triangleA1),this._triangleA2=s.TriangleCandidate.createFromIndexedXYZ(t.points,t.begin+1,t.points,t.begin+2,e.points,e.begin,2,this._triangleA2),this._triangleA3=s.TriangleCandidate.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin+1,3,this._triangleA3),this._triangleB1=s.TriangleCandidate.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,-1,this._triangleB1),this._triangleB2=s.TriangleCandidate.createFromIndexedXYZ(e.points,e.begin+2,e.points,e.begin+1,t.points,t.begin,-2,this._triangleB2),this._triangleB3=s.TriangleCandidate.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin+1,-3,this._triangleB3),this._bestTriangle=s.TriangleCandidate.copyWithLowerQuality(this._triangleA1,this._triangleB3,this._bestTriangle),this._workTriangle=s.TriangleCandidate.copyWithLowerQuality(this._triangleB1,this._triangleA3,this._workTriangle),s.TriangleCandidate.updateIfOtherHasHigherQuality(this._bestTriangle,this._workTriangle),this._bestTriangle.id>0){if(t.advanceBegin(),r(this._bestTriangle),i)return}else if(e.advanceBegin(),r(this._bestTriangle),i)return;if(t.isSingleton)for(;e.length>=2;)this._workTriangle=s.TriangleCandidate.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,0,this._workTriangle),r(this._workTriangle),e.advanceBegin();if(e.isSingleton)for(;t.length>=2;)this._workTriangle=s.TriangleCandidate.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,0,this._workTriangle),r(this._workTriangle),t.advanceBegin()}emitTriangles(t,e,r){this.emitTrianglesGo(l(t),l(e),r)}emitTrianglesGo(t,e,r){const i=c.IndexedXYZCollectionInterval.createComplete(t),n=c.IndexedXYZCollectionInterval.createComplete(e),s=c.IndexedXYZCollectionInterval.createComplete(t),o=c.IndexedXYZCollectionInterval.createComplete(e);for(;i.length>0&&n.length>0&&(i.length>1||n.length>1);)this.isPlanarBase(t,i.begin,e,n.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(this.advanceToPlanarLimit(i,s,i.begin+1,this._xyzA,this._crossA,this._forwardA,this._crossB,this._forwardB),this.advanceToPlanarLimit(n,o,n.begin+1,this._xyzB,this._crossB,this._forwardB,this._crossA,this._forwardA),this.addGreedy(s,o,r),i.advanceToTail(s),n.advanceToTail(o)):this.isPlanarBase(t,i.begin+1,e,n.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(s.setFrom(i,i.begin,i.begin+2),o.setFrom(n,n.begin,n.begin+1),this.addGreedy(s,o,r),i.advanceToTail(s),n.advanceToTail(o)):this.isPlanarBase(t,i.begin,e,n.begin+1,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(s.setFrom(i,i.begin,i.begin+1),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(s,o,r),i.advanceToTail(s),n.advanceToTail(o)):i.length>1&&n.length>1?(s.setFrom(i,i.begin,i.begin+2),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(s,o,r,!0),i.advanceToHead(s),n.advanceToHead(o)):i.length>1?(s.setFrom(i,i.begin,i.begin+2),o.setFrom(n),this.addGreedy(s,o,r),i.advanceToTail(s),n.advanceToTail(o)):n.length>1&&(s.setFrom(i),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(s,o,r),i.advanceToTail(s),n.advanceToTail(o));this.addGreedy(i,n,r)}static createContext(t=this.defaultNearColinearAngle){return new GreedyTriangulationBetweenLineStrings(t.radians)}}function l(t,e=n.Geometry.smallMetricDistance){let r=!1;const i=t.length;for(let n=0;n+1<i;n++)if(t.distanceIndexIndex(n,n+1)<=e){r=!0;break}if(!r)return t;const s=new a.GrowableXYZArray(i);s.pushXYZ(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0));let o=0;for(let n=1;n<i;n++)t.distanceIndexIndex(o,n)>e&&(s.pushXYZ(t.getXAtUncheckedPointIndex(n),t.getYAtUncheckedPointIndex(n),t.getZAtUncheckedPointIndex(n)),o=n);return t.distanceIndexIndex(0,i-1)<=e&&(s.pop(),s.pushFromGrowableXYZArray(s,0)),s}e.GreedyTriangulationBetweenLineStrings=GreedyTriangulationBetweenLineStrings,GreedyTriangulationBetweenLineStrings.defaultNearColinearAngle=o.Angle.createDegrees(15)},"./lib/polyface/IndexedEdgeMatcher.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class SortableEdge extends Float64Array{get vertexIndexA(){return this[0]}get vertexIndexB(){return this[1]}get facetIndex(){return this[2]}get isLowHigh(){return this[0]<this[1]}get lowVertexIndex(){return this[0]<this[1]?this[0]:this[1]}get highVertexIndex(){return this[0]>this[1]?this[0]:this[1]}static areDirectedPartners(t,e){return t[0]===e[1]&&t[1]===e[0]}static areUndirectedPartners(t,e){return t[0]===e[0]&&t[1]===e[1]||t[0]===e[1]&&t[1]===e[0]}get isNullEdge(){return this[0]===this[1]}static lessThan(t,e){const r=t.lowVertexIndex,i=e.lowVertexIndex;if(r<i)return-1;if(i<r)return 1;const n=t.highVertexIndex,s=e.highVertexIndex;return n<s?-1:s<n?1:t.vertexIndexA-e.vertexIndexA}constructor(t,e,r){super(3),this[0]=t,this[1]=e,this[2]=r}toJSON(){return[this[0],this[1],this[2]]}static clusterToJSON(t){if(t instanceof SortableEdge)return t.toJSON();const e=[];for(const r of t)e.push(r.toJSON())}static clusterArrayToJSON(t){const e=[];for(const r of t)e.push(SortableEdge.clusterToJSON(r));return e}}e.SortableEdge=SortableEdge;e.IndexedEdgeMatcher=class IndexedEdgeMatcher{constructor(){this.edges=[]}addEdge(t,e,r){const i=new SortableEdge(t,e,r);return this.edges.push(i),i}addPath(t,e,r=!0){if(0===t.length)return;const i=t.length-1;for(let n=0;n<i;n++)this.addEdge(t[n],t[n+1],e);r&&this.addEdge(t[i],t[0],e)}sort(){this.edges.sort(SortableEdge.lessThan)}collectSortableEdgeCluster(t,e,r){if(void 0!==r&&e>t)if(e===t+1)r.push(this.edges[t]);else{const i=[];for(let r=t;r<e;r++)i.push(this.edges[r]);r.push(i)}}sortAndCollectClusters(t,e,r,i){this.sort(),t&&(t.length=0),e&&(e.length=0),r&&(r.length=0),i&&(i.length=0);const n=this.edges.length;let s;for(let o=0;o<n;o+=s){const a=this.edges[o];s=1;for(let t=o+1;t<n&&SortableEdge.areUndirectedPartners(a,this.edges[t]);t++)s++;this.edges[o].isNullEdge?this.collectSortableEdgeCluster(o,o+s,r):2===s&&SortableEdge.areDirectedPartners(a,this.edges[o+1])?this.collectSortableEdgeCluster(o,o+s,t):1===s?this.collectSortableEdgeCluster(o,o+1,e):this.collectSortableEdgeCluster(o,o+s,i)}}}},"./lib/polyface/Polyface.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/PointHelpers.js"),o=r("./lib/geometry3d/GrowableFloat64Array.js"),a=r("./lib/geometry3d/GrowableXYZArray.js"),c=r("./lib/curve/GeometryQuery.js"),l=r("./lib/polyface/PolyfaceData.js"),d=r("./lib/polyface/FacetFaceData.js"),h=r("./lib/Geometry.js"),u=r("./lib/geometry3d/GrowableXYArray.js");function f(t,e,r){return void 0!==t&&void 0!==e&&void 0!==r}class Polyface extends c.GeometryQuery{constructor(t){super(),this.geometryCategory="polyface",this.data=t}get twoSided(){return this.data.twoSided}set twoSided(t){this.data.twoSided=t}static areIndicesValid(t,e,r,i,n){if(void 0===t&&void 0===i)return!0;if(!t||!i)return!1;if(e<0||e>=t.length)return!1;if(r<e||r>t.length)return!1;for(let s=e;s<r;s++)if(t[s]<0||t[s]>=n)return!1;return!0}}e.Polyface=Polyface;class IndexedPolyface extends Polyface{constructor(t,e,r){super(t),e?this._facetStart=e.slice():(this._facetStart=[],this._facetStart.push(0)),this._facetToFaceData=r?r.slice():[]}isSameGeometryClass(t){return t instanceof IndexedPolyface}isAlmostEqual(t){return t instanceof IndexedPolyface&&(this.data.isAlmostEqual(t.data)&&s.NumberArray.isExactEqual(this._facetStart,t._facetStart)&&s.NumberArray.isExactEqual(this._facetToFaceData,t._facetToFaceData))}get isEmpty(){return 0===this.data.pointCount||0===this.data.pointIndex.length}tryTransformInPlace(t){if(this.data.tryTransformInPlace(t)){t.matrix.determinant()<0&&(this.reverseIndices(),this.reverseNormals())}return!1}clone(){return new IndexedPolyface(this.data.clone(),this._facetStart.slice(),this._facetToFaceData.slice())}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}reverseIndices(){this.data.reverseIndices(this._facetStart)}reverseNormals(){this.data.reverseNormals()}tryGetFaceData(t){const e=this._facetToFaceData[t];if(!(e>=this.data.face.length))return this.data.face[e]}addIndexedPolyface(t,e,r){const i=f(this.data.param,t.data.param,t.data.paramIndex),s=f(this.data.normal,t.data.normal,t.data.normalIndex),a=new o.GrowableFloat64Array;a.ensureCapacity(t.data.pointCount);const c=t.data.point,l=n.Point3d.create();for(let n=0,o=t.data.point.length;n<o;n++)c.getPoint3dAtUncheckedPointIndex(n,l),r?(r.multiplyPoint3d(l,l),a.push(this.addPoint(l))):a.push(this.addPoint(l));const d=t._facetStart.length-1;for(let n=0;n<d;n++){const r=t._facetStart[n],i=t._facetStart[n+1];if(e)for(let e=i;e-- >r;)this.addPointIndex(a.atUncheckedIndex(t.data.pointIndex[e]),t.data.edgeVisible[e]);else for(let e=r;e<i;e++)this.addPointIndex(a.atUncheckedIndex(t.data.pointIndex[e]),t.data.edgeVisible[e]);this.terminateFacet(!1)}if(i){const r=this.data.param,i=r.length;r.pushFromGrowableXYArray(t.data.param);for(let n=0;n<t._facetStart.length;n++){const r=t._facetStart[n],s=t._facetStart[n+1];if(e)for(let e=s;e-- >r;)this.addParamIndex(i+t.data.paramIndex[e]);else for(let e=r;e<s;e++)this.addParamIndex(i+t.data.paramIndex[e])}}if(s&&t.data.normal){const i=this.data.normal.length,n=t.data.normal.length;for(let e=0;e<n;e++){const i=t.data.normal.getVector3dAtCheckedVectorIndex(e);r?(r.multiplyVector(i,i),this.addNormal(i)):this.addNormal(i)}for(let r=0;r<t._facetStart.length;r++){const n=t._facetStart[r],s=t._facetStart[r+1];if(e)for(let e=s;e-- >n;)this.addNormalIndex(i+t.data.normalIndex[e]);else for(let e=n;e<s;e++)this.addNormalIndex(i+t.data.normalIndex[e])}}if(this.data.color&&t.data.color&&t.data.colorIndex){const r=this.data.color.length;for(const e of t.data.color)this.addColor(e);for(let i=0;i<t._facetStart.length;i++){const n=t._facetStart[i],s=t._facetStart[i+1];if(e)for(let e=s;e-- >n;)this.addColorIndex(r+t.data.colorIndex[e-1]);else for(let e=n;e<s;e++)this.addColorIndex(r+t.data.colorIndex[e])}}if(0!==t.data.face.length){const e=this.data.face.length;for(const r of t.data.face){const t=r.clone();this.data.face.push(t)}for(const r of t._facetToFaceData)this._facetToFaceData.push(e+r)}}get zeroTerminatedIndexCount(){return this.data.pointIndex.length+this._facetStart.length-1}static create(t=!1,e=!1,r=!1,i=!1){return new IndexedPolyface(new l.PolyfaceData(t,e,r,i))}addPoint(t,e){if(void 0!==e){const r=this.data.point.distanceIndexToPoint(e,t);if(void 0!==r&&h.Geometry.isSmallMetricDistance(r))return e}return this.data.point.pushXYZ(t.x,t.y,t.z),this.data.point.length-1}addPointXYZ(t,e,r){return this.data.point.push(n.Point3d.create(t,e,r)),this.data.point.length-1}addParam(t){return this.data.param||(this.data.param=new u.GrowableXYArray),this.data.param.push(t),this.data.param.length-1}addParamUV(t,e,r,n){return this.data.param||(this.data.param=new u.GrowableXYArray),void 0!==r&&this.data.isAlmostEqualParamIndexUV(r,t,e)?r:void 0!==n&&this.data.isAlmostEqualParamIndexUV(n,t,e)?n:(this.data.param.push(i.Point2d.create(t,e)),this.data.param.length-1)}addNormal(t,e,r){if(void 0!==this.data.normal){let i;if(void 0!==e&&void 0!==(i=this.data.normal.distanceIndexToPoint(e,t))&&h.Geometry.isSmallMetricDistance(i))return e;if(void 0!==r&&void 0!==(i=this.data.normal.distanceIndexToPoint(r,t))&&h.Geometry.isSmallMetricDistance(i))return r;const n=this.data.normal.length-1;if(void 0!==(i=this.data.normal.distanceIndexToPoint(n,t))&&h.Geometry.isSmallMetricDistance(i))return n}return this.addNormalXYZ(t.x,t.y,t.z)}addNormalXYZ(t,e,r){return this.data.normal||(this.data.normal=new a.GrowableXYZArray),this.data.normal.pushXYZ(t,e,r),this.data.normal.length-1}addColor(t){return this.data.color||(this.data.color=[]),this.data.color.push(t),this.data.color.length-1}addPointIndex(t,e=!0){this.data.pointIndex.push(t),this.data.edgeVisible.push(e)}addNormalIndex(t){this.data.normalIndex||(this.data.normalIndex=[]),this.data.normalIndex.push(t)}addParamIndex(t){this.data.paramIndex||(this.data.paramIndex=[]),this.data.paramIndex.push(t)}addColorIndex(t){this.data.colorIndex||(this.data.colorIndex=[]),this.data.colorIndex.push(t)}cleanupOpenFacet(){this.data.trimAllIndexArrays(this.data.pointIndex.length)}terminateFacet(t=!0){const e=this._facetStart.length-1,r=this._facetStart[e],i=this.data.pointIndex.length;if(t){const t=[];if(i<r+2&&t.push("Less than 3 indices in open facet"),this.data.normalIndex&&this.data.normalIndex.length!==i&&t.push("normalIndex count must match pointIndex count"),this.data.paramIndex&&this.data.paramIndex.length!==i&&t.push("paramIndex count must equal pointIndex count"),this.data.colorIndex&&this.data.colorIndex.length!==i&&t.push("colorIndex count must equal pointIndex count"),this.data.edgeVisible.length!==i&&t.push("visibleIndex count must equal pointIndex count"),Polyface.areIndicesValid(this.data.normalIndex,r,i,this.data.normal,this.data.normal?this.data.normal.length:0)||t.push("invalid normal indices in open facet"),t.length>0)return this.cleanupOpenFacet(),t}this._facetStart.push(i)}get facetCount(){return this._facetStart.length-1}get faceCount(){return this.data.faceCount}get pointCount(){return this.data.pointCount}get colorCount(){return this.data.colorCount}get paramCount(){return this.data.paramCount}get normalCount(){return this.data.normalCount}numEdgeInFacet(t){return this.isValidFacetIndex(t)?this._facetStart[t+1]-this._facetStart[t]:0}isValidFacetIndex(t){return t>=0&&t+1<this._facetStart.length}facetIndex0(t){return this._facetStart[t]}facetIndex1(t){return this._facetStart[t+1]}createVisitor(t=0){return IndexedPolyfaceVisitor.create(this,t)}range(t,e){return this.data.range(e,t)}extendRange(t,e){this.data.range(t,e)}getFaceDataByFacetIndex(t){return this.data.face[this._facetToFaceData[t]]}setNewFaceData(t=0){const e=this._facetToFaceData.length;if(e>=this._facetStart.length)return!1;0===t&&(t=this._facetStart.length);const r=d.FacetFaceData.createNull(),i=IndexedPolyfaceVisitor.create(this,0);if(!i.moveToReadIndex(e))return!1;const n=void 0!==this.data.param,s=r.paramRange.isNull&&n;do{s&&void 0!==i.param&&i.param.extendRange(r.paramRange)}while(i.moveToNextFacet()&&i.currentReadIndex()<t);n&&0!==this.data.param.length&&r.paramDistanceRange.isNull&&r.setParamDistanceRangeFromNewFaceData(this,e,t),this.data.face.push(r);const o=this.data.face.length-1;for(let a=this._facetToFaceData.length;a<t;a++)this._facetToFaceData.push(0===this._facetStart[a]?0:o);return!0}dispatchToGeometryHandler(t){return t.handleIndexedPolyface(this)}}e.IndexedPolyface=IndexedPolyface;class IndexedPolyfaceVisitor extends l.PolyfaceData{constructor(t,e){super(t.data.normalCount>0,t.data.paramCount>0,t.data.colorCount>0,t.twoSided),this._polyface=t,this._numWrap=e,t.data.auxData&&(this.auxData=t.data.auxData.createForVisitor()),this.reset(),this._numEdges=0,this._nextFacetIndex=0,this._currentFacetIndex=-1}clientPolyface(){return this._polyface}setNumWrap(t){this._numWrap=t}get numEdgesThisFacet(){return this._numEdges}static create(t,e){return new IndexedPolyfaceVisitor(t,e)}moveToReadIndex(t){return!!this._polyface.isValidFacetIndex(t)&&(this._currentFacetIndex=t,this._nextFacetIndex=t+1,this._numEdges=this._polyface.numEdgeInFacet(t),this.resizeAllDataArrays(this._numEdges+this._numWrap),this.gatherIndexedData(this._polyface.data,this._polyface.facetIndex0(this._currentFacetIndex),this._polyface.facetIndex1(this._currentFacetIndex),this._numWrap),!0)}moveToNextFacet(){return this._nextFacetIndex!==this._currentFacetIndex?this.moveToReadIndex(this._nextFacetIndex):(this._nextFacetIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextFacetIndex=0}tryGetDistanceParameter(t,e){if(t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const r=this._polyface.tryGetFaceData(this._currentFacetIndex);return r?r.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}tryGetNormalizedParameter(t,e){if(t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const r=this._polyface.tryGetFaceData(this._currentFacetIndex);return r?r.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}currentReadIndex(){return this._currentFacetIndex}clientPointIndex(t){return this.pointIndex[t]}clientParamIndex(t){return this.paramIndex?this.paramIndex[t]:-1}clientNormalIndex(t){return this.normalIndex?this.normalIndex[t]:-1}clientColorIndex(t){return this.colorIndex?this.colorIndex[t]:-1}clientAuxIndex(t){return this.auxData?this.auxData.indices[t]:-1}clearArrays(){void 0!==this.point&&(this.point.length=0),void 0!==this.param&&(this.param.length=0),void 0!==this.normal&&(this.normal.length=0),void 0!==this.color&&(this.color.length=0)}pushDataFrom(t,e){this.point.pushFromGrowableXYZArray(t.point,e),this.color&&t.color&&e<t.color.length&&this.color.push(t.color[e]),this.param&&t.param&&e<t.param.length&&this.param.pushFromGrowableXYArray(t.param,e),this.normal&&t.normal&&e<t.normal.length&&this.normal.pushFromGrowableXYZArray(t.normal,e)}pushInterpolatedDataFrom(t,e,r,i){this.point.pushInterpolatedFromGrowableXYZArray(t.point,e,r,i),this.color&&t.color&&e<t.color.length&&i<t.color.length&&this.color.push(function(t,e,r){e=h.Geometry.clamp(e,0,1);const i=g(t,e,r,0),n=g(t,e,r,8),s=g(t,e,r,16),o=g(t,e,r,24);return i|n|s|o}(t.color[e],r,t.color[i])),this.param&&t.param&&e<t.param.length&&i<t.param.length&&this.param.pushInterpolatedFromGrowableXYArray(t.param,e,r,i),this.normal&&t.normal&&e<t.normal.length&&i<t.normal.length&&this.normal.pushInterpolatedFromGrowableXYZArray(t.normal,e,r,i)}}function g(t,e,r,i){return t=t>>>i&255,r=r>>>i&255,(255&Math.floor(t+e*(r-t)))<<i}e.IndexedPolyfaceVisitor=IndexedPolyfaceVisitor},"./lib/polyface/PolyfaceBuilder.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/polyface/Polyface.js"),n=r("./lib/geometry3d/GrowableFloat64Array.js"),s=r("./lib/geometry3d/Point2dVector2d.js"),o=r("./lib/geometry3d/Point3dVector3d.js"),a=r("./lib/geometry3d/Transform.js"),c=r("./lib/geometry3d/Matrix3d.js"),l=r("./lib/polyface/BoxTopology.js"),d=r("./lib/curve/StrokeOptions.js"),h=r("./lib/curve/CurveCollection.js"),u=r("./lib/Geometry.js"),f=r("./lib/curve/LineString3d.js"),g=r("./lib/topology/Graph.js"),p=r("./lib/geometry3d/GeometryHandler.js"),m=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),y=r("./lib/curve/CurvePrimitive.js"),P=r("./lib/curve/Query/StrokeCountChain.js"),x=r("./lib/curve/ParityRegion.js"),_=r("./lib/geometry3d/Range.js"),v=r("./lib/curve/ConstructCurveBetweenCurves.js"),S=r("./lib/curve/Query/CylindricalRange.js"),C=r("./lib/geometry3d/GrowableXYZArray.js"),A=r("./lib/geometry3d/Segment1d.js"),w=r("./lib/geometry3d/BilinearPatch.js"),b=r("./lib/geometry3d/FrameBuilder.js"),I=r("./lib/topology/Triangulation.js"),T=r("./lib/geometry3d/PolygonOps.js"),M=r("./lib/solid/SweepContour.js"),R=r("./lib/geometry3d/Point3dArrayCarrier.js"),F=r("./lib/polyface/GreedyTriangulationBetweenLineStrings.js");class FacetSector{constructor(t=!1,e=!1,r=!1){this.xyz=o.Point3d.create(),this.normalIndex=-1,this.uvIndex=-1,this.xyzIndex=-1,t&&(this.normal=o.Vector3d.create()),e&&(this.uv=s.Point2d.create(),this.uvIndex=-1),r&&(this.sectionDerivative=o.Vector3d.create())}copyContentsFrom(t){this.xyz.setFromPoint3d(t.xyz),this.xyzIndex=t.xyzIndex,this.normal&&this.normal.setFromVector3d(t.normal),this.normalIndex=t.normalIndex,this.uv&&this.uv.setFrom(t.uv),this.uvIndex=t.uvIndex,this.sectionDerivative&&this.sectionDerivative.setFrom(t.sectionDerivative)}loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,e,r,i,n){e.getPoint3dAtCheckedPointIndex(t,this.xyz),i&&void 0!==n&&(this.uv=s.Point2d.create(i.atUncheckedIndex(t),n)),this.xyzIndex=-1,this.normalIndex=-1,this.uvIndex=-1,void 0!==this.sectionDerivative&&void 0!==r&&r.getVector3dAtCheckedVectorIndex(t,this.sectionDerivative)}static suppressSmallUnitVectorComponents(t){Math.abs(t.x)<1e-15&&(t.x=0),Math.abs(t.y)<1e-15&&(t.y=0),Math.abs(t.z)<1e-15&&(t.z=0)}static computeNormalsAlongRuleLine(t,e){if(t.sectionDerivative&&e.sectionDerivative){const r=FacetSector._edgeVector;o.Vector3d.createStartEnd(t.xyz,e.xyz,r),t.sectionDerivative.crossProduct(r,t.normal),e.sectionDerivative.crossProduct(r,e.normal),t.normal.normalizeInPlace(),e.normal.normalizeInPlace(),FacetSector.suppressSmallUnitVectorComponents(t.normal),FacetSector.suppressSmallUnitVectorComponents(e.normal)}}}FacetSector._edgeVector=o.Vector3d.create();class UVSurfaceOps{constructor(){}static createLinestringOnUVLine(t,e,r,i,n,s,a=!1,c=!1){const l=f.LineString3d.create(),d=o.Point3d.create();let h,g,p;const m=s+1;for(let o=0;o<m;o++)h=o/s,g=u.Geometry.interpolate(e,h,i),p=u.Geometry.interpolate(r,h,n),t.uvFractionToPoint(g,p,d),l.addPoint(d),a&&l.addUVParamAsUV(g,p),c&&l.addFraction(h);return l}}e.UVSurfaceOps=UVSurfaceOps;class PolyfaceBuilder extends p.NullGeometryHandler{constructor(t){super(),this._options=t||d.StrokeOptions.createForFacets(),this._polyface=i.IndexedPolyface.create(this._options.needNormals,this._options.needParams,this._options.needColors,this._options.needTwoSided),this._reversed=!1}get options(){return this._options}get reversedFlag(){return this._reversed}claimPolyface(t=!0){return t&&this._polyface.data.compress(),this._polyface}toggleReversedFacetFlag(){this._reversed=!this._reversed}static create(t){return new PolyfaceBuilder(t)}addTransformedUnitBox(t){const e=this._polyface.data.pointCount;for(const r of l.BoxTopology.points)this._polyface.addPoint(t.multiplyPoint3d(r));for(const r of l.BoxTopology.cornerIndexCCW){for(const t of r)this._polyface.addPointIndex(e+t);this._polyface.terminateFacet()}}addTriangleFan(t,e,r){const i=e.numPoints();if(i>2){r&&this.toggleReversedFacetFlag();const n=this.findOrAddPoint(t);let s=this.findOrAddPointInLineString(e,0),o=0;for(let t=1;t<i;t++)o=this.findOrAddPointInLineString(e,t),this.addIndexedTrianglePointIndexes(n,s,o),s=o;r&&this.toggleReversedFacetFlag()}}addTrianglesInUncheckedConvexPolygon(t,e){const r=t.numPoints();if(r>2){let i,n;e&&this.toggleReversedFacetFlag(),this._options.needNormals&&(i=t.quickUnitNormal(PolyfaceBuilder._workVectorFindOrAdd),e&&i.scaleInPlace(-1),n=this._polyface.addNormal(i));const s=this._options.needParams?t.packedUVParams:void 0;let o=-1,a=-1,c=-1;s&&(o=this.findOrAddParamInGrowableXYArray(s,0),a=this.findOrAddParamInGrowableXYArray(s,1));const l=this.findOrAddPointInLineString(t,0);let d=this.findOrAddPointInLineString(t,1),h=0,u=r;t.isPhysicallyClosed&&u--;for(let e=2;e<u;e++,d=h,a=c)h=this.findOrAddPointInLineString(t,e),this.addIndexedTrianglePointIndexes(l,d,h,!1),void 0!==n&&this.addIndexedTriangleNormalIndexes(n,n,n),s&&(c=this.findOrAddParamInGrowableXYArray(s,e),this.addIndexedTriangleParamIndexes(o,a,c)),this._polyface.terminateFacet();e&&this.toggleReversedFacetFlag()}}findOrAddPoint(t){return this._polyface.addPoint(t)}findOrAddParamXY(t,e){return this._polyface.addParamUV(t,e)}findOrAddPointInLineString(t,e,r,i){const n=t.pointAt(e,PolyfaceBuilder._workPointFindOrAddA);if(n)return r&&r.multiplyPoint3d(n,n),this._polyface.addPoint(n,i)}findOrAddPointInGrowableXYZArray(t,e,r,i){const n=t.getPoint3dAtCheckedPointIndex(e,PolyfaceBuilder._workPointFindOrAddA);if(n)return r&&r.multiplyPoint3d(n,n),this._polyface.addPoint(n,i)}findOrAddNormalInGrowableXYZArray(t,e,r,i){const n=t.getVector3dAtCheckedVectorIndex(e,PolyfaceBuilder._workVectorFindOrAdd);if(n)return r&&r.multiplyVector(n,n),this._polyface.addNormal(n,i)}findOrAddParamInGrowableXYArray(t,e){if(!t)return;const r=t.getPoint2dAtUncheckedPointIndex(e,PolyfaceBuilder._workUVFindOrAdd);return r?this._polyface.addParam(r):void 0}findOrAddParamInLineString(t,e,r,i,n){const s=t.fractions&&e<t.fractions.length?t.fractions.atUncheckedIndex(e):e/t.points.length;return this._polyface.addParamUV(s,r,i,n)}findOrAddNormalInLineString(t,e,r,i,n){const s=t.packedSurfaceNormals;if(s){const t=s.getVector3dAtCheckedVectorIndex(e,PolyfaceBuilder._workVectorFindOrAdd);if(t)return r&&r.multiplyVector(t,t),this._polyface.addNormal(t,i,n)}}findOrAddNormalnLineString(t,e,r,i,n){return this.findOrAddNormalInLineString(t,e,r,i,n)}findOrAddPointXYZ(t,e,r){return this._polyface.addPointXYZ(t,e,r)}getUVTransformForTriangleFacet(t,e,r){const i=t.vectorTo(e),n=t.vectorTo(r),s=c.Matrix3d.createRigidFromColumns(i,n,u.AxisOrder.XYZ);return a.Transform.createOriginAndMatrix(t,s).inverse()}getNormalForTriangularFacet(t,e,r){const i=t.vectorTo(e),n=t.vectorTo(r);let s=i.crossProduct(n).normalize();return s=s||o.Vector3d.create()}addQuadFacet(t,e,r){t instanceof C.GrowableXYZArray&&(t=t.getPoint3dArray());const i=this.options.needParams,n=this.options.needNormals;let o,a,c,l,d,h,u,f,g,p,m,y;if(i)if(void 0!==e&&e.length>3)o=e[0],a=e[1],c=e[2],l=e[3];else{const e=this.getUVTransformForTriangleFacet(t[0],t[1],t[2]);void 0===e?o=a=c=l=s.Point2d.createZero():(o=s.Point2d.createFrom(e.multiplyPoint3d(t[0])),a=s.Point2d.createFrom(e.multiplyPoint3d(t[1])),c=s.Point2d.createFrom(e.multiplyPoint3d(t[2])),l=s.Point2d.createFrom(e.multiplyPoint3d(t[3])))}if(n&&(void 0!==r&&r.length>3?(d=r[0],h=r[1],u=r[2],f=r[3]):(d=this.getNormalForTriangularFacet(t[0],t[1],t[2]),h=this.getNormalForTriangularFacet(t[0],t[1],t[2]),u=this.getNormalForTriangularFacet(t[0],t[1],t[2]),f=this.getNormalForTriangularFacet(t[0],t[1],t[2]))),this._options.shouldTriangulate){const e=t[0].vectorTo(t[2]),r=t[1].vectorTo(t[3]);e.magnitude()>=r.magnitude()?(this.addTriangleFacet([t[0],t[1],t[2]],i?[o,a,c]:void 0,n?[d,h,u]:void 0),this.addTriangleFacet([t[0],t[2],t[3]],i?[o,c,l]:void 0,n?[d,u,f]:void 0)):(this.addTriangleFacet([t[0],t[1],t[3]],i?[o,a,l]:void 0,n?[d,h,f]:void 0),this.addTriangleFacet([t[1],t[2],t[3]],i?[a,c,l]:void 0,n?[h,u,f]:void 0))}else i&&(g=this._polyface.addParam(o),p=this._polyface.addParam(a),m=this._polyface.addParam(c),y=this._polyface.addParam(l),this.addIndexedQuadParamIndexes(g,p,y,m)),n&&(g=this._polyface.addNormal(d),p=this._polyface.addNormal(h),m=this._polyface.addNormal(u),y=this._polyface.addNormal(f),this.addIndexedQuadNormalIndexes(g,p,y,m)),g=this.findOrAddPoint(t[0]),p=this.findOrAddPoint(t[1]),m=this.findOrAddPoint(t[2]),y=this.findOrAddPoint(t[3]),this.addIndexedQuadPointIndexes(g,p,y,m)}addIndexedQuadPointIndexes(t,e,r,i,n=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(r),this._polyface.addPointIndex(i),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(i),this._polyface.addPointIndex(r)),n&&this._polyface.terminateFacet()}addIndexedQuadParamIndexes(t,e,r,i){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(r),this._polyface.addParamIndex(i),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(i),this._polyface.addParamIndex(r))}addIndexedQuadNormalIndexes(t,e,r,i){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(r),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(r))}addTriangleFacet(t,e,r){if(t.length<3)return;let i,n,o,a,c,l;if(t instanceof C.GrowableXYZArray?(a=t.getPoint3dAtCheckedPointIndex(0),c=t.getPoint3dAtCheckedPointIndex(1),l=t.getPoint3dAtCheckedPointIndex(2)):(a=t[0],c=t[1],l=t[2]),this._options.needParams){if(e&&e.length>=3)i=this._polyface.addParam(e[0]),n=this._polyface.addParam(e[1]),o=this._polyface.addParam(e[2]);else{const t=this.getUVTransformForTriangleFacet(a,c,l);i=this._polyface.addParam(s.Point2d.createFrom(t?t.multiplyPoint3d(a):void 0)),n=this._polyface.addParam(s.Point2d.createFrom(t?t.multiplyPoint3d(c):void 0)),o=this._polyface.addParam(s.Point2d.createFrom(t?t.multiplyPoint3d(c):void 0))}this.addIndexedTriangleParamIndexes(i,n,o)}if(this._options.needNormals){if(void 0!==r&&r.length>2)i=this._polyface.addNormal(r[0]),n=this._polyface.addNormal(r[1]),o=this._polyface.addNormal(r[2]);else{const t=this.getNormalForTriangularFacet(a,c,l);i=this._polyface.addNormal(t),n=this._polyface.addNormal(t),o=this._polyface.addNormal(t)}this.addIndexedTriangleNormalIndexes(i,n,o)}i=this.findOrAddPoint(a),n=this.findOrAddPoint(c),o=this.findOrAddPoint(l),this.addIndexedTrianglePointIndexes(i,n,o)}addIndexedTrianglePointIndexes(t,e,r,i=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(r),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(r)),i&&this._polyface.terminateFacet()}addIndexedTriangleParamIndexes(t,e,r){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(r),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(r))}addIndexedTriangleNormalIndexes(t,e,r){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(r),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(r))}setSectorIndices(t){t.xyzIndex=this.findOrAddPoint(t.xyz),t.normal&&(t.normalIndex=this._polyface.addNormal(t.normal)),t.uv&&(t.uvIndex=this._polyface.addParam(t.uv))}addSectorQuadA01B01(t,e,r,i){t.xyz.isAlmostEqual(e.xyz)&&r.xyz.isAlmostEqual(i.xyz)||(this._options.needNormals&&this.addIndexedQuadNormalIndexes(t.normalIndex,e.normalIndex,r.normalIndex,i.normalIndex),this._options.needParams&&this.addIndexedQuadParamIndexes(t.uvIndex,e.uvIndex,r.uvIndex,i.uvIndex),this.addIndexedQuadPointIndexes(t.xyzIndex,e.xyzIndex,r.xyzIndex,i.xyzIndex),this._polyface.terminateFacet())}addBetweenLineStringsWithRuleEdgeNormals(t,e,r,i,n=!1){const s=t.packedPoints,o=r.packedPoints,a=t.packedDerivatives,c=r.packedDerivatives,l=t.fractions,d=r.fractions,h=this._options.needNormals,u=this._options.needParams,f=new FacetSector(h,u,h),g=new FacetSector(h,u,h),p=new FacetSector(h,u,h),m=new FacetSector(h,u,h),y=new FacetSector(h,u,h),P=new FacetSector(h,u,h),x=s.length;if(!(x<2||x!==o.length)){f.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,s,a,l,e),p.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,o,c,d,i),h&&FacetSector.computeNormalsAlongRuleLine(f,p),this.setSectorIndices(f),this.setSectorIndices(p),y.copyContentsFrom(f),P.copyContentsFrom(p);for(let t=1;t<x;t++)g.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,s,a,l,e),m.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,o,a,d,i),FacetSector.computeNormalsAlongRuleLine(g,m),this.setSectorIndices(g),this.setSectorIndices(m),this.addSectorQuadA01B01(f,g,p,m),f.copyContentsFrom(g),p.copyContentsFrom(m);n&&this.addSectorQuadA01B01(f,y,p,P)}}addBetweenLineStringsWithStoredIndices(t,e){const r=t.pointIndices,i=e.pointIndices;let n=t.normalIndices,s=e.normalIndices;this._options.needNormals||(n=void 0,s=void 0);let o=t.paramIndices,a=e.paramIndices;this._options.needParams||(o=void 0,a=void 0);const c=r.length;for(let l=1;l<c;l++)r.atUncheckedIndex(l-1)===r.atUncheckedIndex(l)&&i.atUncheckedIndex(l-1)===i.atUncheckedIndex(l)||(this.addIndexedQuadPointIndexes(r.atUncheckedIndex(l-1),r.atUncheckedIndex(l),i.atUncheckedIndex(l-1),i.atUncheckedIndex(l)),n&&s&&this.addIndexedQuadNormalIndexes(n.atUncheckedIndex(l-1),n.atUncheckedIndex(l),s.atUncheckedIndex(l-1),s.atUncheckedIndex(l)),o&&a&&this.addIndexedQuadParamIndexes(o.atUncheckedIndex(l-1),o.atUncheckedIndex(l),a.atUncheckedIndex(l-1),a.atUncheckedIndex(l)),this._polyface.terminateFacet())}addBetweenTransformedLineStrings(t,e,r,i=!1){if(t instanceof f.LineString3d){const n=t.points.length;let s=this.findOrAddPointInLineString(t,0,e),o=this.findOrAddPointInLineString(t,0,r);const a=s,c=o;let l=0,d=0;for(let i=1;i<n;i++)l=this.findOrAddPointInLineString(t,i,e),d=this.findOrAddPointInLineString(t,i,r),this.addIndexedQuadPointIndexes(s,l,o,d),s=l,o=d;i&&this.addIndexedQuadPointIndexes(s,a,o,c)}else{const i=t.children;if(i)for(const t of i)this.addBetweenTransformedLineStrings(t,e,r)}}addBetweenStrokeSetPair(t,e,r,i){if(t instanceof f.LineString3d&&r instanceof f.LineString3d)this.addBetweenLineStringsWithRuleEdgeNormals(t,e,r,i,!1);else if(t instanceof x.ParityRegion&&r instanceof x.ParityRegion){if(t.children.length===r.children.length)for(let n=0;n<t.children.length;n++)this.addBetweenStrokeSetPair(t.children[n],e,r.children[n],i)}else if(t instanceof h.CurveChain&&r instanceof h.CurveChain){const n=t.children,s=r.children;if(n.length===s.length)for(let t=0;t<n.length;t++){const r=n[t],o=s[t];r instanceof f.LineString3d&&o instanceof f.LineString3d&&this.addBetweenLineStringsWithRuleEdgeNormals(r,e,o,i)}}}addCone(t){let e=16;this._options&&(e=this._options.applyTolerancesToArc(t.getMaxRadius()));let r=1;const i=t.strokeConstantVSection(0,e,this._options),n=t.strokeConstantVSection(1,e,this._options);if(this._options){const t=C.GrowableXYZArray.distanceRangeBetweenCorrespondingPoints(i.packedPoints,n.packedPoints);r=this._options.applyMaxEdgeLength(1,t.low)}const s=t.maxIsoParametricDistance();this.addUVGridBody(t,e,r,A.Segment1d.create(0,s.x),A.Segment1d.create(0,s.y)),this.endFace(),t.capped&&(u.Geometry.isSmallMetricDistance(t.getRadiusA())||(this.addTrianglesInUncheckedConvexPolygon(i,!0),this.endFace()),u.Geometry.isSmallMetricDistance(t.getRadiusB())||(this.addTrianglesInUncheckedConvexPolygon(n,!1),this.endFace()))}addTorusPipe(t,e,r){const i=t.getThetaFraction(),n=u.Geometry.clamp(u.Geometry.resolveNumber(e,8),4,64),s=u.Geometry.clamp(u.Geometry.resolveNumber(r,Math.ceil(16*i)),2,64);this.toggleReversedFacetFlag();const o=t.maxIsoParametricDistance();if(this.addUVGridBody(t,n,s,A.Segment1d.create(0,o.x),A.Segment1d.create(0,o.y)),this.toggleReversedFacetFlag(),t.capped&&i<1){const e=t.getConstructiveFrame(),r=t.getMinorRadius(),i=t.getMajorRadius(),s=2*r,o=i-r,c=i+r,l=-r,d=a.Transform.createRowValues(s,0,0,o,0,0,-1,0,0,s,0,l),h=e.multiplyTransformTransform(d).inverse();if(h){const e=UVSurfaceOps.createLinestringOnUVLine(t,0,0,1,0,n,!1,!0);e.computeUVFromXYZTransform(h),this.addTrianglesInUncheckedConvexPolygon(e,!1)}const u=t.getSweepAngle().radians,f=Math.cos(u),g=Math.sin(u),p=a.Transform.createRowValues(-f*s,0,-g,c*f,-g*s,0,f,c*g,0,s,0,l),m=e.multiplyTransformTransform(p).inverse();if(m){const e=UVSurfaceOps.createLinestringOnUVLine(t,1,1,0,1,n,!1,!0);e.computeUVFromXYZTransform(m),this.addTrianglesInUncheckedConvexPolygon(e,!1)}}}addLinearSweepLineStringsXYZOnly(t,e){if(t instanceof f.LineString3d){const r=t;let i=o.Point3d.create(),n=o.Point3d.create(),s=0,a=0,c=0,l=0;const d=r.numPoints();for(let t=0;t<d;t++)n=(i=r.pointAt(t,i)).plus(e,n),a=this.findOrAddPoint(i),l=this.findOrAddPoint(n),t>0&&this.addIndexedQuadPointIndexes(s,a,c,l),s=a,c=l}else if(t instanceof h.CurveChain)for(const r of t.children)this.addLinearSweepLineStringsXYZOnly(r,e)}addRotationalSweep(t){const e=t.getCurves(),r=P.StrokeCountSection.createForParityRegionOrChain(e,this._options).getStrokes(),i=t.cloneAxisRay(),n=S.CylindricalRangeQuery.computeMaxVectorFromRay(i,r),s=i.direction.crossProduct(n);this._options.needNormals&&S.CylindricalRangeQuery.buildRotationalNormalsInLineStrings(r,i,s);const o=n.magnitude(),a=Math.abs(o*t.getSweep().radians);let c=d.StrokeOptions.applyAngleTol(this._options,1,t.getSweep().radians,void 0);c=d.StrokeOptions.applyMaxEdgeLength(this._options,c,a);for(let l=1;l<=c;l++){const e=t.getFractionalRotationTransform((l-1)/c),i=t.getFractionalRotationTransform(l/c);this.addBetweenRotatedStrokeSets(r,e,l-1,i,l)}if(t.capped){const e=t.getSweepContourRef();e.purgeFacets(),e.emitFacets(this,!0,void 0),e.emitFacets(this,!1,t.getFractionalRotationTransform(1))}}addTriangulatedRegion(t){const e=M.SweepContour.createForLinearSweep(t);e&&e.emitFacets(this,!0,void 0)}applyStrokeCountsToCurvePrimitives(t){const e=this._options;if(t instanceof y.CurvePrimitive)t.computeStrokeCountForOptions(e);else if(t instanceof h.CurveCollection){const e=t.children;if(e)for(const t of e)this.applyStrokeCountsToCurvePrimitives(t)}}addBetweenStrokeSetsWithRuledNormals(t,e,r){const i=[t],n=[0];for(let s=1;s<r;s++){const o=s/r,a=v.ConstructCurveBetweenCurves.interpolateBetween(t,s/r,e);i.push(a),n.push(o)}i.push(e),n.push(1);for(let s=0;s<r;s++)this.addBetweenStrokeSetPair(i[s],n[s],i[s+1],n[s+1])}createIndicesInLineString(t,e,r){const i=t.numPoints();{const e=t.ensureEmptyPointIndices(),n=this.findOrAddPointInLineString(t,0,r);if(e.push(n),i>1){let s,o=n;for(let n=1;n+1<i;n++)s=this.findOrAddPointInLineString(t,n,r,o),e.push(s),o=s;s=this.findOrAddPointInLineString(t,i-1,r,n),e.push(s)}}if(this._options.needNormals&&void 0!==t.packedSurfaceNormals){const e=t.ensureEmptyNormalIndices(),n=this.findOrAddNormalInLineString(t,0,r);e.push(n);let s,o=n;if(i>1){for(let n=1;n+1<i;n++)s=this.findOrAddNormalInLineString(t,n,r,o),e.push(s),o=s;s=this.findOrAddNormalInLineString(t,i-1,r,n,o),e.push(s)}}if(this._options.needParams&&void 0!==t.packedUVParams){const r=t.ensureEmptyUVIndices(),n=this.findOrAddParamInLineString(t,0,e);r.push(n);let s,o=n;if(i>1){for(let n=1;n+1<i;n++)s=this.findOrAddParamInLineString(t,n,e,o),r.push(s),o=s;s=this.findOrAddParamInLineString(t,i-1,e,o,n),r.push(s)}}}addBetweenRotatedStrokeSets(t,e,r,i,n){if(t instanceof f.LineString3d){const s=t.cloneTransformed(e);this.createIndicesInLineString(s,r);const o=t.cloneTransformed(i);this.createIndicesInLineString(o,n),this.addBetweenLineStringsWithStoredIndices(s,o)}else if(t instanceof x.ParityRegion)for(let s=0;s<t.children.length;s++)this.addBetweenRotatedStrokeSets(t.children[s],e,r,i,n);else if(t instanceof h.CurveChain){const s=t.children;for(let t=0;t<s.length;t++){const o=s[t];o instanceof f.LineString3d&&this.addBetweenRotatedStrokeSets(o,e,r,i,n)}}}addLinearSweep(t){const e=t.getCurvesRef(),r=P.StrokeCountSection.createForParityRegionOrChain(e,this._options).getStrokes(),i=t.cloneSweepVector(),n=a.Transform.createTranslation(i),s=r.cloneTransformed(n),o=this._options.applyMaxEdgeLength(1,i.magnitude());if(this.addBetweenStrokeSetsWithRuledNormals(r,s,o),t.capped&&e.isAnyRegionType){const e=t.getSweepContourRef();e.purgeFacets(),e.emitFacets(this,!0,void 0),e.emitFacets(this,!1,n)}}addRuledSweep(t){const e=t.sweepContoursRef();let r,i;const n=[];for(let s=0;s<e.length;s++)n.push(P.StrokeCountSection.createForParityRegionOrChain(e[s].curves,this._options));if(P.StrokeCountSection.enforceStrokeCountCompatibility(n)){P.StrokeCountSection.enforceCompatibleDistanceSums(n);for(let t=0;t<e.length;t++){if((i=n[t].getStrokes())||(i=e[t].curves.cloneStroked()),t>0&&r&&i){const t=_.Range1d.createNull();if(P.StrokeCountSection.extendDistanceRangeBetweenStrokes(r,i,t)&&!t.isNull){const e=this._options.applyMaxEdgeLength(1,t.high);this.addBetweenStrokeSetsWithRuledNormals(r,i,e)}}r=i}}return t.capped&&e[0].curves.isAnyRegionType&&(e[0].purgeFacets(),e[0].emitFacets(this,!0,void 0),e[e.length-1].purgeFacets(),e[e.length-1].emitFacets(this,!1,void 0)),!0}addSphere(t,e){const r=e||this._options.defaultCircleStrokes,i=u.Geometry.clampToStartEnd(Math.abs(r*t.latitudeSweepFraction),1,Math.ceil(.5*r)),n=t.strokeConstantVSection(0,r,this._options);t.capped&&!u.Geometry.isSmallMetricDistance(n.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(n,!0),this.endFace());const s=t.maxIsoParametricDistance();this.addUVGridBody(t,r,i,A.Segment1d.create(0,s.x),A.Segment1d.create(0,s.y)),this.endFace();const o=t.strokeConstantVSection(1,r,this._options);t.capped&&!u.Geometry.isSmallMetricDistance(o.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(o,!1),this.endFace())}addBox(t){const e=t.getCorners(),r=u.Geometry.maxXY(t.getBaseX(),t.getBaseX()),i=u.Geometry.maxXY(t.getBaseY(),t.getTopY());let n=0;for(let d=0;d<4;d++)n=u.Geometry.maxXY(n,e[d].distance(e[d+4]));const s=this._options.applyMaxEdgeLength(1,r),o=this._options.applyMaxEdgeLength(1,i),a=this._options.applyMaxEdgeLength(1,n),c=A.Segment1d.create(0,r),l=A.Segment1d.create(0,n);this.addUVGridBody(w.BilinearPatch.create(e[0],e[1],e[4],e[5]),s,a,c,l),c.shift(r),this.addUVGridBody(w.BilinearPatch.create(e[1],e[3],e[5],e[7]),o,a,c,l),c.shift(i),this.addUVGridBody(w.BilinearPatch.create(e[3],e[2],e[7],e[6]),s,a,c,l),c.shift(r),this.addUVGridBody(w.BilinearPatch.create(e[2],e[0],e[6],e[4]),o,a,c,l),this.endFace(),t.capped&&(c.set(0,r),l.set(0,i),this.addUVGridBody(w.BilinearPatch.create(e[4],e[5],e[6],e[7]),s,o,c,l),this.endFace(),c.set(0,r),l.set(0,i),this.addUVGridBody(w.BilinearPatch.create(e[2],e[3],e[0],e[1]),s,o,c,l),this.endFace())}addPolygon(t,e){for(void 0===e&&(e=t.length);e>1&&t[e-1].isAlmostEqual(t[0]);)e--;let r=0;if(this._reversed)for(let i=e;--i>=0;)r=this.findOrAddPoint(t[i]),this._polyface.addPointIndex(r);else for(let i=0;i<e;i++)r=this.findOrAddPoint(t[i]),this._polyface.addPointIndex(r);this._polyface.terminateFacet()}addPolygonGrowableXYZArray(t){let e=t.length;for(;e>1&&u.Geometry.isSmallMetricDistance(t.distanceIndexIndex(0,e-1));)e--;let r=0;if(this._reversed)for(let i=e;--i>=0;)r=this.findOrAddPointInGrowableXYZArray(t,i),this._polyface.addPointIndex(r);else for(let i=0;i<e;i++)r=this.findOrAddPointInGrowableXYZArray(t,i),this._polyface.addPointIndex(r);this._polyface.terminateFacet()}addFacetFromGrowableArrays(t,e,r,i){let n=t.length;for(;n>1&&u.Geometry.isSmallMetricDistance(t.distanceIndexIndex(0,n-1));)n--;let s=0;if(e&&e.length<n&&(e=void 0),r&&r.length<n&&(r=void 0),i&&i.length<n&&(i=void 0),this._reversed)for(let o=n;--o>=0;)s=this.findOrAddPointInGrowableXYZArray(t,o),this._polyface.addPointIndex(s),e&&(s=this.findOrAddNormalInGrowableXYZArray(e,o),this._polyface.addNormalIndex(s)),r&&(s=this.findOrAddParamInGrowableXYArray(r,o),this._polyface.addParamIndex(s)),i&&(s=this._polyface.addColor(i[o]),this._polyface.addColorIndex(s));else for(let o=0;o<n;o++)s=this.findOrAddPointInGrowableXYZArray(t,o),this._polyface.addPointIndex(s),e&&(s=this.findOrAddNormalInGrowableXYZArray(e,o),this._polyface.addNormalIndex(s)),r&&(s=this.findOrAddParamInGrowableXYArray(r,o),this._polyface.addParamIndex(s)),i&&(s=this._polyface.addColor(i[o]),this._polyface.addColorIndex(s));this._polyface.terminateFacet()}addFacetFromVisitor(t){this.addFacetFromGrowableArrays(t.point,t.normal,t.param,t.color)}addIndexedPolyface(t,e,r){this._polyface.addIndexedPolyface(t,e,r)}endFace(){return this._polyface.setNewFaceData()}handleCone(t){return this.addCone(t)}handleTorusPipe(t){return this.addTorusPipe(t)}handleSphere(t){return this.addSphere(t)}handleBox(t){return this.addBox(t)}handleLinearSweep(t){return this.addLinearSweep(t)}handleRotationalSweep(t){return this.addRotationalSweep(t)}handleRuledSweep(t){return this.addRuledSweep(t)}addGeometryQuery(t){t.dispatchToGeometryHandler(this)}addGraph(t,e,r=g.HalfEdge.testNodeMaskNotExterior){let i=0;const n=this._options.needNormals;let s=0;n&&(s=this._polyface.addNormalXYZ(0,0,1)),t.announceFaceLoops((t,o)=>{if(r(o)&&o.countEdgesAroundFace()>2){let t=o;do{i=this.findOrAddPointXYZ(t.x,t.y,t.z),this._polyface.addPointIndex(i),e&&(i=this.findOrAddParamXY(t.x,t.y),this._polyface.addParamIndex(i)),n&&this._polyface.addNormalIndex(s),t=t.faceSuccessor}while(t!==o);this._polyface.terminateFacet()}return!0})}addGraphFaces(t,e){let r=0;for(const i of e){let t=i;do{r=this.findOrAddPointXYZ(t.x,t.y,t.z),this._polyface.addPointIndex(r),t=t.faceSuccessor}while(t!==i);this._polyface.terminateFacet()}}static graphToPolyface(t,e,r=g.HalfEdge.testNodeMaskNotExterior){const i=PolyfaceBuilder.create(e);return i.addGraph(t,i.options.needParams,r),i.endFace(),i.claimPolyface()}static graphFacesToPolyface(t,e){const r=PolyfaceBuilder.create();return r.addGraphFaces(t,e),r.endFace(),r.claimPolyface()}static polygonToTriangulatedPolyface(t,e){if(e||(e=b.FrameBuilder.createFrameWithCCWPolygon(t)),e){const r=e.multiplyInversePoint3dArray(t);T.PolygonOps.areaXY(r)<0&&r.reverse();const i=I.Triangulator.createTriangulatedGraphFromSingleLoop(r);if(i){const t=this.graphToPolyface(i);return t.tryTransformInPlace(e),t}}}addCoordinateFacets(t,e,r,i=!1){for(let n=0;n<t.length;n++){const i=e?e[n]:void 0,s=r?r[n]:void 0;3===t[n].length?this.addTriangleFacet(t[n],i,s):4===t[n].length&&this.addQuadFacet(t[n],i,s)}i&&this.endFace()}addUVGridBody(t,e,r,i,a){let c,l,d,h,u=new n.GrowableFloat64Array(e),f=new n.GrowableFloat64Array(e);const g=this._reversed,p=this.options.needNormals;p&&(d=new n.GrowableFloat64Array(e),h=new n.GrowableFloat64Array(e));const y=this.options.needParams;let P;y&&(c=new n.GrowableFloat64Array(e),l=new n.GrowableFloat64Array(e)),u.ensureCapacity(e),f.ensureCapacity(e);const x=s.Point2d.create(),_=o.Vector3d.create(),v=1/e,S=1/r,C=m.Plane3dByOriginAndVectors.createXYPlane();for(let n=0;n<=r;n++){f.clear(),p&&h.clear(),y&&l.clear();for(let r=0;r<=e;r++){const e=r*v,o=n*S;t.uvFractionToPointAndTangents(e,o,C),f.push(this._polyface.addPoint(C.origin)),p&&(C.vectorU.crossProduct(C.vectorV,_),_.normalizeInPlace(),g&&_.scaleInPlace(-1),h.push(this._polyface.addNormal(_))),y&&l.push(this._polyface.addParam(s.Point2d.create(i?i.fractionToPoint(e):e,a?a.fractionToPoint(o):o,x)))}if(n>0)for(let t=0;t<e;t++)this.addIndexedQuadPointIndexes(u.atUncheckedIndex(t),u.atUncheckedIndex(t+1),f.atUncheckedIndex(t),f.atUncheckedIndex(t+1),!1),p&&this.addIndexedQuadNormalIndexes(d.atUncheckedIndex(t),d.atUncheckedIndex(t+1),h.atUncheckedIndex(t),h.atUncheckedIndex(t+1)),y&&this.addIndexedQuadParamIndexes(c.atUncheckedIndex(t),c.atUncheckedIndex(t+1),l.atUncheckedIndex(t),l.atUncheckedIndex(t+1)),this._polyface.terminateFacet();P=f,f=u,u=P,y&&(P=l,l=c,c=P),p&&(P=h,h=d,d=P)}u.clear(),f.clear()}static pointsToTriangulatedPolyface(t){const e=I.Triangulator.createTriangulatedGraphFromPoints(t);if(e)return PolyfaceBuilder.graphToPolyface(e)}addGreedyTriangulationBetweenLineStrings(t,e){F.GreedyTriangulationBetweenLineStrings.createContext().emitTriangles(k(t),k(e),t=>{this.addTriangleFacet(t.points)})}}function k(t){return Array.isArray(t)?new R.Point3dArrayCarrier(t):t instanceof f.LineString3d?t.packedPoints:t}e.PolyfaceBuilder=PolyfaceBuilder,PolyfaceBuilder._workPointFindOrAddA=o.Point3d.create(),PolyfaceBuilder._workVectorFindOrAdd=o.Vector3d.create(),PolyfaceBuilder._workUVFindOrAdd=s.Point2d.create()},"./lib/polyface/PolyfaceClip.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/clipping/ClipPlane.js"),n=r("./lib/clipping/ConvexClipPlaneSet.js"),s=r("./lib/geometry3d/GrowableXYZArray.js"),o=r("./lib/polyface/PolyfaceBuilder.js"),a=r("./lib/geometry3d/Point3dVector3d.js"),c=r("./lib/topology/ChainMerge.js"),l=r("./lib/solid/SweepContour.js"),d=r("./lib/geometry3d/PolygonOps.js"),h=r("./lib/geometry3d/Range.js"),u=r("./lib/polyface/PolyfaceQuery.js"),f=r("./lib/polyface/multiclip/RangeSearch.js");e.PolyfaceClip=class PolyfaceClip{static clipPolyfaceClipPlaneWithClosureFace(t,e,r=!0,i=!0){const n=t.createVisitor(0),h=o.PolyfaceBuilder.create(),u=c.ChainMergeContext.create(),f=new s.GrowableXYZArray(10),g=a.Point3d.create(),p=a.Point3d.create();for(n.reset();n.moveToNextFacet();)e.clipConvexPolygonInPlace(n.point,f,r),n.point.length>2&&h.addPolygonGrowableXYZArray(n.point),this.collectEdgesOnPlane(n.point,e,u,g,p);if(i){const t=e.getPlane3d().getNormalRef().scale(-1);u.clusterAndMergeVerticesXYZ();const i=u.collectMaximalGrowableXYZArrays();d.PolygonOps.orientLoopsCCWForOutwardNormalInPlace(i,t);const n=l.SweepContour.createForPolygon(i,t);void 0!==n&&n.emitFacets(h,r)}return h.claimPolyface(!0)}static clipPolyfaceClipPlane(t,e,r=!0){return this.clipPolyfaceClipPlaneWithClosureFace(t,e,r,!1)}static clipPolyfaceConvexClipPlaneSet(t,e){const r=t.createVisitor(0),i=o.PolyfaceBuilder.create(),n=new s.GrowableXYZArray(10);for(r.reset();r.moveToNextFacet();)e.clipConvexPolygonInPlace(r.point,n),r.point.length>2&&i.addPolygonGrowableXYZArray(r.point);return i.claimPolyface(!0)}static clipPolyface(t,e){return e instanceof i.ClipPlane?this.clipPolyfaceClipPlane(t,e):e instanceof n.ConvexClipPlaneSet?this.clipPolyfaceConvexClipPlaneSet(t,e):void 0}static collectEdgesOnPlane(t,e,r,i,n){const s=t.length;if(s>1){t.getPoint3dAtUncheckedPointIndex(s-1,i);for(let o=0;o<s;o++)t.getPoint3dAtUncheckedPointIndex(o,n),e.isPointOn(i)&&e.isPointOn(n)&&r.addSegment(i,n),i.setFromPoint3d(n)}}static sectionPolyfaceClipPlane(t,e){const r=c.ChainMergeContext.create(),i=t.createVisitor(0),n=new s.GrowableXYZArray(10),o=a.Point3d.create(),l=a.Point3d.create();for(i.reset();i.moveToNextFacet();)e.clipConvexPolygonInPlace(i.point,n,!0),this.collectEdgesOnPlane(i.point,e,r,o,l);return r.clusterAndMergeVerticesXYZ(),r.collectMaximalChains()}static clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(t,e,r,o){const a=u.PolyfaceQuery.collectRangeLengthData(t),c=f.RangeSearch.create2dSearcherForRangeLengthData(a);if(!c)return;const l=h.Range3d.create();for(t.reset();t.moveToNextFacet();)t.point.setRange(l),c.addRange(l,t.currentReadIndex());const g=new s.GrowableXYZArray(10),p=new s.GrowableXYZArray(10),m=n.ConvexClipPlaneSet.createEmpty(),y=new s.GrowableXYZArray(10),P=new s.GrowableXYZArray(10),x=i.ClipPlane.createNormalAndPointXYZXYZ(0,0,1,0,0,0),_=h.Range1d.createNull();for(e.reset();e.moveToNextFacet();)e.point.setRange(l),n.ConvexClipPlaneSet.setPlaneAndXYLoopCCW(e.point,x,m),c.searchRange2d(l,(e,i)=>(t.moveToReadIndex(i),m.polygonClip(t.point,g,p),g.length>0&&(d.IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(x,g,y,P,_),y.length>0&&r&&r.addPolygonGrowableXYZArray(y),P.length>0&&o&&o.addPolygonGrowableXYZArray(P)),!0))}static computeCutFill(t,e){const r=t.createVisitor(),i=e.createVisitor(),n=o.PolyfaceBuilder.create(),s=o.PolyfaceBuilder.create();return n.toggleReversedFacetFlag(),this.clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(r,i,n,s),n.toggleReversedFacetFlag(),s.toggleReversedFacetFlag(),this.clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(i,r,s,n),{meshAUnderB:n.claimPolyface(),meshAOverB:s.claimPolyface()}}}},"./lib/polyface/PolyfaceData.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/geometry3d/Range.js"),o=r("./lib/geometry3d/PointHelpers.js"),a=r("./lib/geometry3d/GrowableXYZArray.js"),c=r("./lib/numerics/ClusterableArray.js"),l=r("./lib/polyface/AuxData.js"),d=r("./lib/geometry3d/GrowableXYArray.js"),h=r("./lib/Geometry.js");class PolyfaceData{constructor(t=!1,e=!1,r=!1,i=!1){this.point=new a.GrowableXYZArray,this.pointIndex=[],this.edgeVisible=[],this.face=[],t&&(this.normal=new a.GrowableXYZArray,this.normalIndex=[]),e&&(this.param=new d.GrowableXYArray,this.paramIndex=[]),r&&(this.color=[],this.colorIndex=[]),this._twoSided=i}get twoSided(){return this._twoSided}set twoSided(t){this._twoSided=t}clone(){const t=new PolyfaceData;return t.point=this.point.clone(),t.pointIndex=this.pointIndex.slice(),t.edgeVisible=this.edgeVisible.slice(),t.face=this.face.slice(),t.twoSided=this.twoSided,this.normal&&(t.normal=this.normal.clone()),this.param&&(t.param=this.param.clone()),this.color&&(t.color=this.color.slice()),this.normalIndex&&(t.normalIndex=this.normalIndex.slice()),this.paramIndex&&(t.paramIndex=this.paramIndex.slice()),this.colorIndex&&(t.colorIndex=this.colorIndex.slice()),this.auxData&&(t.auxData=this.auxData.clone()),t}isAlmostEqual(t){return!!a.GrowableXYZArray.isAlmostEqual(this.point,t.point)&&(!!o.NumberArray.isExactEqual(this.pointIndex,t.pointIndex)&&(!!a.GrowableXYZArray.isAlmostEqual(this.normal,t.normal)&&(!!o.NumberArray.isExactEqual(this.normalIndex,t.normalIndex)&&(!!d.GrowableXYArray.isAlmostEqual(this.param,t.param)&&(!!o.NumberArray.isExactEqual(this.paramIndex,t.paramIndex)&&(!!o.NumberArray.isExactEqual(this.color,t.color)&&(!!o.NumberArray.isExactEqual(this.colorIndex,t.colorIndex)&&(!!o.NumberArray.isExactEqual(this.edgeVisible,t.edgeVisible)&&!!l.PolyfaceAuxData.isAlmostEqual(this.auxData,t.auxData)))))))))}get requireNormals(){return void 0!==this.normal}get pointCount(){return this.point.length}get normalCount(){return this.normal?this.normal.length:0}get paramCount(){return this.param?this.param.length:0}get colorCount(){return this.color?this.color.length:0}get indexCount(){return this.pointIndex.length}get faceCount(){return this.face.length}getPoint(t){return this.point.getPoint3dAtCheckedPointIndex(t)}getNormal(t){return this.normal?this.normal.getVector3dAtCheckedVectorIndex(t):void 0}getParam(t){return this.param?this.param.getPoint2dAtCheckedPointIndex(t):void 0}getColor(t){return this.color?this.color[t]:0}getEdgeVisible(t){return this.edgeVisible[t]}copyPointTo(t,e){this.point.getPoint3dAtUncheckedPointIndex(t,e)}copyNormalTo(t,e){this.normal&&this.normal.getVector3dAtCheckedVectorIndex(t,e)}copyParamTo(t,e){this.param&&this.param.getPoint2dAtCheckedPointIndex(t,e)}isAlmostEqualParamIndexUV(t,e,r){return void 0!==this.param&&t>=0&&t<this.param.length&&(h.Geometry.isSameCoordinate(e,this.param.getXAtUncheckedPointIndex(t))&&h.Geometry.isSameCoordinate(r,this.param.getYAtUncheckedPointIndex(t)))}gatherIndexedData(t,e,r,i){const n=r-e,s=n+i;this.resizeAllDataArrays(s);for(let o=0;o<n;o++)this.point.transferFromGrowableXYZArray(o,t.point,t.pointIndex[e+o]);for(let o=0;o<i;o++)this.point.transferFromGrowableXYZArray(n+o,this.point,o);for(let o=0;o<n;o++)this.pointIndex[o]=t.pointIndex[e+o];for(let o=0;o<i;o++)this.pointIndex[n+o]=this.pointIndex[o];for(let o=0;o<n;o++)this.edgeVisible[o]=t.edgeVisible[e+o];for(let o=0;o<i;o++)this.edgeVisible[n+o]=this.edgeVisible[o];if(this.normal&&this.normalIndex&&t.normal&&t.normalIndex){for(let r=0;r<n;r++)this.normal.transferFromGrowableXYZArray(r,t.normal,t.normalIndex[e+r]);for(let t=0;t<i;t++)this.normal.transferFromGrowableXYZArray(n+t,this.normal,t);for(let r=0;r<n;r++)this.normalIndex[r]=t.normalIndex[e+r];for(let t=0;t<i;t++)this.normalIndex[n+t]=this.normalIndex[t]}if(this.param&&this.paramIndex&&t.param&&t.paramIndex){for(let r=0;r<n;r++)this.param.transferFromGrowableXYArray(r,t.param,t.paramIndex[e+r]);for(let t=0;t<i;t++)this.param.transferFromGrowableXYArray(n+t,this.param,t);for(let r=0;r<n;r++)this.paramIndex[r]=t.paramIndex[e+r];for(let t=0;t<i;t++)this.paramIndex[n+t]=this.paramIndex[t]}if(this.color&&this.colorIndex&&t.color&&t.colorIndex){for(let r=0;r<n;r++)this.color[r]=t.color[t.colorIndex[e+r]];for(let t=0;t<i;t++)this.color[n+t]=this.color[t];for(let r=0;r<n;r++)this.colorIndex[r]=t.colorIndex[e+r];for(let t=0;t<i;t++)this.colorIndex[n+t]=this.colorIndex[t]}if(this.auxData&&t.auxData&&this.auxData.channels.length===t.auxData.channels.length){for(let r=0;r<this.auxData.channels.length;r++){const s=this.auxData.channels[r],o=t.auxData.channels[r],a=s.entriesPerValue;if(s.data.length===o.data.length)for(let t=0;t<s.data.length;t++){const r=s.data[t],c=o.data[t];for(let t=0;t<n;t++)r.copyValues(c,t,e+t,a);for(let t=0;t<i;t++)r.copyValues(r,n+t,t,a)}}for(let r=0;r<n;r++)this.auxData.indices[r]=t.auxData.indices[e+r];for(let t=0;t<i;t++)this.auxData.indices[n+t]=this.auxData.indices[t]}}static trimArray(t,e){t&&e<t.length&&(t.length=e)}trimAllIndexArrays(t){if(PolyfaceData.trimArray(this.pointIndex,t),PolyfaceData.trimArray(this.paramIndex,t),PolyfaceData.trimArray(this.normalIndex,t),PolyfaceData.trimArray(this.colorIndex,t),PolyfaceData.trimArray(this.edgeVisible,t),this.auxData){PolyfaceData.trimArray(this.auxData.indices,t);for(const e of this.auxData.channels)for(const r of e.data)PolyfaceData.trimArray(r.values,e.entriesPerValue*t)}}resizeAllDataArrays(t){if(t>this.point.length){for(;this.point.length<t;)this.point.push(n.Point3d.create());for(;this.pointIndex.length<t;)this.pointIndex.push(-1);for(;this.edgeVisible.length<t;)this.edgeVisible.push(!1);if(this.normal)for(;this.normal.length<t;)this.normal.push(n.Vector3d.create());if(this.param)for(;this.param.length<t;)this.param.push(i.Point2d.create());if(this.color)for(;this.color.length<t;)this.color.push(0);if(this.auxData)for(const e of this.auxData.channels)for(const r of e.data)for(;r.values.length<t*e.entriesPerValue;)r.values.push(0)}else if(t<this.point.length&&(this.point.resize(t),this.edgeVisible.length=t,this.pointIndex.length=t,this.normal&&this.normal.resize(t),this.param&&this.param.resize(t),this.color&&(this.color.length=t),this.auxData))for(const e of this.auxData.channels)for(const r of e.data)r.values.length=t*e.entriesPerValue}range(t,e){return(t=t||s.Range3d.createNull()).extendArray(this.point,e),t}reverseIndices(t){t&&PolyfaceData.isValidFacetStartIndexArray(t)&&(PolyfaceData.reverseIndices(t,this.pointIndex,!0),PolyfaceData.reverseIndices(t,this.normalIndex,!0),PolyfaceData.reverseIndices(t,this.paramIndex,!0),PolyfaceData.reverseIndices(t,this.colorIndex,!0),PolyfaceData.reverseIndices(t,this.edgeVisible,!1))}reverseNormals(){this.normal&&this.normal.scaleInPlace(-1)}tryTransformInPlace(t){return this.point.multiplyTransformInPlace(t),this.normal&&!t.matrix.isIdentity&&this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),!0}compress(){const t=c.ClusterableArray.clusterGrowablePoint3dArray(this.point);this.point=t.growablePackedPoints,t.updateIndices(this.pointIndex)}static isValidFacetStartIndexArray(t){if(0===t.length)return!1;for(let e=0;e+1<t.length;e++)if(t[e]>=t[e+1])return!1;return!0}static reverseIndices(t,e,r){if(!e||0===e.length)return!0;if(e.length>0&&t[t.length-1]===e.length){for(let i=0;i+1<t.length;i++){let n=t[i],s=t[i+1];if(r)for(;s>n+2;){s--;const t=e[++n];e[n]=e[s],e[s]=t}else for(;s>n+1;){s--;const t=e[n];e[n]=e[s],e[s]=t,n++}}return!0}return!1}}e.PolyfaceData=PolyfaceData,PolyfaceData.planarityLocalRelTol=1e-13},"./lib/polyface/PolyfaceQuery.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/polyface/Polyface.js"),s=r("./lib/geometry4d/Matrix4d.js"),o=r("./lib/curve/CurveCollection.js"),a=r("./lib/curve/Loop.js"),c=r("./lib/curve/LineString3d.js"),l=r("./lib/geometry3d/PolygonOps.js"),d=r("./lib/geometry4d/MomentData.js"),h=r("./lib/polyface/IndexedEdgeMatcher.js"),u=r("./lib/geometry3d/Transform.js"),f=r("./lib/geometry3d/Segment1d.js"),g=r("./lib/polyface/PolyfaceBuilder.js"),p=r("./lib/Geometry.js"),m=r("./lib/curve/LineSegment3d.js"),y=r("./lib/topology/ChainMerge.js"),P=r("./lib/numerics/UnionFind.js"),x=r("./lib/curve/StrokeOptions.js"),_=r("./lib/polyface/RangeLengthData.js"),v=r("./lib/polyface/multiclip/XYPointBuckets.js"),S=r("./lib/geometry3d/Range.js");class PolyfaceQuery{static visitorToLoop(t){const e=c.LineString3d.createPoints(t.point.getPoint3dArray());return a.Loop.create(e)}static indexedPolyfaceToLoops(t){const e=o.BagOfCurves.create(),r=t.createVisitor(1);for(;r.moveToNextFacet();){const t=PolyfaceQuery.visitorToLoop(r);e.tryAddChild(t)}return e}static sumFacetAreas(t){let e=0;if(t instanceof n.Polyface)return PolyfaceQuery.sumFacetAreas(t.createVisitor(1));const r=t;for(r.reset();r.moveToNextFacet();)e+=l.PolygonOps.sumTriangleAreas(r.point.getPoint3dArray());return e}static sumTetrahedralVolumes(t,e){let r=0;if(t instanceof n.Polyface)return PolyfaceQuery.sumTetrahedralVolumes(t.createVisitor(0),e);let s=e;const o=t,a=i.Point3d.create(),c=i.Point3d.create(),l=i.Point3d.create();for(o.reset();o.moveToNextFacet();){void 0===s&&(s=o.point.getPoint3dAtUncheckedPointIndex(0)),o.point.getPoint3dAtUncheckedPointIndex(0,a);for(let t=1;t+1<o.point.length;t++)o.point.getPoint3dAtUncheckedPointIndex(t,c),o.point.getPoint3dAtUncheckedPointIndex(t+1,l),r+=s.tripleProductToPoints(a,c,l)}return r/6}static sumVolumeBetweenFacetsAndPlane(t,e){if(t instanceof n.Polyface)return PolyfaceQuery.sumVolumeBetweenFacetsAndPlane(t.createVisitor(0),e);const r=t,o=i.Point3d.create(),a=i.Point3d.create(),c=i.Point3d.create(),h=i.Vector3d.create(),u=e.getNormalRef();let f,g,p,m,y,P=0;const x=d.MomentData.create(void 0,!0),_=d.MomentData.create(void 0,!0),v=s.Matrix4d.createZero(),S=e.getProjectionToPlane();for(r.reset();r.moveToNextFacet();){r.point.getPoint3dAtUncheckedPointIndex(0,o),f=e.altitude(o),y=0;for(let t=1;t+1<r.point.length;t++)r.point.getPoint3dAtUncheckedPointIndex(t,a),r.point.getPoint3dAtUncheckedPointIndex(t+1,c),o.crossProductToPoints(a,c,h),g=e.altitude(a),p=e.altitude(c),y+=m=u.dotProduct(h),P+=m*(f+g+p);v.setZero(),r.point.multiplyTransformInPlace(S),l.PolygonOps.addSecondMomentAreaProducts(r.point,o,v),y>0?x.accumulateProductsFromOrigin(o,v,1):_.accumulateProductsFromOrigin(o,v,1)}return x.shiftOriginAndSumsToCentroidOfSums(),_.shiftOriginAndSumsToCentroidOfSums(),{volume:P/6,positiveProjectedFacetAreaMoments:d.MomentData.inertiaProductsToPrincipalAxes(x.origin,x.sums),negativeProjectedFacetAreaMoments:d.MomentData.inertiaProductsToPrincipalAxes(_.origin,_.sums)}}static sumFacetSecondAreaMomentProducts(t,e){if(t instanceof n.Polyface)return PolyfaceQuery.sumFacetSecondAreaMomentProducts(t.createVisitor(0),e);const r=s.Matrix4d.createZero(),i=t;for(i.reset();i.moveToNextFacet();)l.PolygonOps.addSecondMomentAreaProducts(i.point,e,r);return r}static sumFacetSecondVolumeMomentProducts(t,e){if(t instanceof n.Polyface)return PolyfaceQuery.sumFacetSecondVolumeMomentProducts(t.createVisitor(0),e);const r=s.Matrix4d.createZero(),i=t;for(i.reset();i.moveToNextFacet();)l.PolygonOps.addSecondMomentVolumeProducts(i.point,e,r);return r}static computePrincipalAreaMoments(t){const e=t.data.getPoint(0);if(!e)return;const r=PolyfaceQuery.sumFacetSecondAreaMomentProducts(t,e);return d.MomentData.inertiaProductsToPrincipalAxes(e,r)}static computePrincipalVolumeMoments(t){const e=t.data.getPoint(0);if(!e)return;const r=PolyfaceQuery.sumFacetSecondVolumeMomentProducts(t,e);return d.MomentData.inertiaProductsToPrincipalAxes(e,r)}static isPolyfaceClosedByEdgePairing(t){const e=new h.IndexedEdgeMatcher,r=t.createVisitor(1);for(r.reset();r.moveToNextFacet();){const t=r.pointCount-1;for(let i=0;i<t;i++)e.addEdge(r.clientPointIndex(i),r.clientPointIndex(i+1),r.currentReadIndex())}const i=[];return e.sortAndCollectClusters(void 0,i,void 0,i),0===i.length}static boundaryEdges(t,e=!0,r=!0,i=!0){const n=new h.IndexedEdgeMatcher,s=t.createVisitor(1);for(s.reset();s.moveToNextFacet();){const t=s.pointCount-1;for(let e=0;e<t;e++)n.addEdge(s.clientPointIndex(e),s.clientPointIndex(e+1),s.currentReadIndex())}const a=[],c=[],l=[];n.sortAndCollectClusters(void 0,a,l,c);const d=[];if(e&&a.length>0&&d.push(a),r&&c.length>0&&d.push(c),i&&l.length>0&&d.push(l),0===d.length)return;const u=new o.BagOfCurves;for(const o of d)for(const e of o){const r=e instanceof h.SortableEdge?e:e[0],i=r.vertexIndexA,n=r.vertexIndexB,s=t.data.getPoint(i),o=t.data.getPoint(n);s&&o&&u.tryAddChild(m.LineSegment3d.create(s,o))}return u}static announceSweepLinestringToConvexPolyfaceXY(t,e,r){const n=e.createVisitor(0),s=t.length,o=i.Point3d.create(),a=i.Point3d.create(),c=i.Point3d.create(),l=i.Point3d.create(),d=f.Segment1d.create(0,1),h=u.Transform.createIdentity();let g;for(n.reset();n.moveToNextFacet();)for(let i=1;i+1<n.point.length;i++)if(g=n.point.fillLocalXYTriangleFrame(0,i,i+1,h))for(let u=1;u<s;u++)if(t.getPoint3dAtCheckedPointIndex(u-1,o),t.getPoint3dAtCheckedPointIndex(u,a),g.multiplyInversePoint3d(o,c),g.multiplyInversePoint3d(a,l),d.set(0,1),d.clipBy01FunctionValuesPositive(c.x,l.x)&&d.clipBy01FunctionValuesPositive(c.y,l.y)&&d.clipBy01FunctionValuesPositive(1-c.x-c.y,1-l.x-l.y)){const i=c.interpolate(d.x0,l),s=c.interpolate(d.x1,l),f=h.multiplyPoint3d(i),g=h.multiplyPoint3d(s),m=h.multiplyXYZ(i.x,i.y,0),y=h.multiplyXYZ(s.x,s.y,0),P=p.Geometry.inverseInterpolate01(c.z,l.z);if(void 0!==P&&P>d.x0&&P<d.x1){const i=o.interpolate(P,a),s=i.clone();r(t,u-1,e,n.currentReadIndex(),[f,i,m],2,1),r(t,u-1,e,n.currentReadIndex(),[g,s,y],1,2)}else c.z>0?r(t,u-1,e,n.currentReadIndex(),[f,g,y,m],3,2):r(t,u-1,e,n.currentReadIndex(),[g,f,m,y],2,3)}}static partitionFacetIndicesByVertexConnectedComponent(t){if(t instanceof n.Polyface)return this.partitionFacetIndicesByVertexConnectedComponent(t.createVisitor(0));const e=new P.UnionFindContext(t.clientPolyface().data.point.length);for(t.reset();t.moveToNextFacet();){const r=t.pointIndex[0];for(const i of t.pointIndex)e.mergeSubsets(r,i)}const r=e.collectRootIndices(),i=[],s=r.length;for(let n=0;n<s;n++)i.push([]);for(t.reset();t.moveToNextFacet();){const n=t.pointIndex[0],o=e.findRoot(n);for(let e=0;e<s;e++)if(r[e]===o){i[e].push(t.currentReadIndex());break}}return i}static clonePartitions(t,e){if(t instanceof n.Polyface)return this.clonePartitions(t.createVisitor(0),e);t.setNumWrap(0);const r=[],i=x.StrokeOptions.createForFacets();i.needNormals=void 0!==t.normal,i.needParams=void 0!==t.param,i.needColors=void 0!==t.color,i.needTwoSided=t.twoSided;for(const n of e){const e=g.PolyfaceBuilder.create(i);t.reset();for(const r of n)t.moveToReadIndex(r),e.addFacetFromVisitor(t);r.push(e.claimPolyface(!0))}return r}static partitionFacetIndicesByEdgeConnectedComponent(t){if(t instanceof n.Polyface)return this.partitionFacetIndicesByEdgeConnectedComponent(t.createVisitor(0));t.setNumWrap(1);const e=new h.IndexedEdgeMatcher;t.reset();let r=0;for(;t.moveToNextFacet();){const i=t.pointCount-1;r++;for(let r=0;r<i;r++)e.addEdge(t.clientPointIndex(r),t.clientPointIndex(r+1),t.currentReadIndex())}const i=[];e.sortAndCollectClusters(i,i,i,i);const s=new P.UnionFindContext(r);for(const n of i)if(n instanceof h.SortableEdge);else{const t=n[0];for(let e=1;e<n.length;e++)s.mergeSubsets(t.facetIndex,n[e].facetIndex)}const o=s.collectRootIndices(),a=[],c=o.length;for(let n=0;n<c;n++)a.push([]);for(let n=0;n<r;n++){const t=s.findRoot(n);for(let e=0;e<c;e++)if(o[e]===t){a[e].push(n);break}}return a}static sweepLinestringToFacetsXYreturnSweptFacets(t,e){const r=g.PolyfaceBuilder.create();return this.announceSweepLinestringToConvexPolyfaceXY(t,e,(t,e,i,n,s)=>{4===s.length?r.addQuadFacet(s):3===s.length&&r.addTriangleFacet(s)}),r.claimPolyface(!0)}static sweepLinestringToFacetsXYReturnLines(t,e){const r=[];return this.announceSweepLinestringToConvexPolyfaceXY(t,e,(t,e,i,n,s,o,a)=>{r.push(m.LineSegment3d.create(s[o],s[a]))}),r}static sweepLinestringToFacetsXYReturnChains(t,e){const r=y.ChainMergeContext.create();return this.announceSweepLinestringToConvexPolyfaceXY(t,e,(t,e,i,n,s,o,a)=>{r.addSegment(s[o],s[a])}),r.clusterAndMergeVerticesXYZ(),r.collectMaximalChains()}static collectRangeLengthData(t){if(t instanceof n.Polyface)return this.collectRangeLengthData(t.createVisitor(0));const e=new _.RangeLengthData;for(t.reset();t.moveToNextFacet();)e.accumulateGrowableXYZArrayRange(t.point);return e}static cloneWithTVertexFixup(t){const e=t.createVisitor(1),r=t.createVisitor(0),n=v.XYPointBuckets.create(t.data.point,30),s=g.PolyfaceBuilder.create(),o=S.Range3d.createNull(),a=i.Point3d.create(),c=i.Point3d.create(),l=i.Point3d.create(),d=m.LineSegment3d.create(a,c);for(e.reset();e.moveToNextFacet();){r.clearArrays();for(let i=0;i+1<e.point.length;i++){let s;if(e.point.getPoint3dAtUncheckedPointIndex(i,a),e.point.getPoint3dAtUncheckedPointIndex(i+1,c),r.pushDataFrom(e,i),o.setNull(),m.LineSegment3d.create(a,c,d),o.extend(a),o.extend(c),n.announcePointsInRange(o,(e,r,i,n)=>{t.data.point.getPoint3dAtUncheckedPointIndex(e,l);const o=d.closestPoint(l,!1);return void 0!==o&&o.fraction>=0&&o.fraction<1&&!o.point.isAlmostEqual(a)&&!o.point.isAlmostEqual(c)&&(void 0===s&&(s=[]),o.a=e,s.push(o)),!0}),void 0!==s){s.sort((t,e)=>t.fraction-e.fraction);for(const t of s)r.pushInterpolatedDataFrom(e,i,t.fraction,i+1)}}s.addFacetFromGrowableArrays(r.point,r.normal,r.param,r.color)}return s.claimPolyface()}static cloneWithColinearEdgeFixup(t){const e=t.createVisitor(2),r=t.createVisitor(0),n=g.PolyfaceBuilder.create(),s=i.Vector3d.create(),o=i.Vector3d.create(),a=t.data.point.length,c=new Int32Array(a);for(e.reset();e.moveToNextFacet();)for(let t=0;t+2<e.point.length;t++){e.point.vectorIndexIndex(t,t+1,s),e.point.vectorIndexIndex(t+1,t+2,o);const r=e.clientPointIndex(t+1);if(c[r]>=0){s.angleTo(o).isAlmostZero?c[r]++:c[r]=-1}}for(e.reset();e.moveToNextFacet();){r.clearArrays();for(let t=0;t+2<e.point.length;t++){c[e.clientPointIndex(t)]<0&&r.pushDataFrom(e,t)}r.point.length>2&&n.addFacetFromGrowableArrays(r.point,r.normal,r.param,r.color)}return n.claimPolyface()}}e.PolyfaceQuery=PolyfaceQuery},"./lib/polyface/RangeLengthData.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js"),n=r("./lib/numerics/UsageSums.js");e.RangeLengthData=class RangeLengthData{constructor(){this.range=i.Range3d.createNull(),this.xSums=new n.UsageSums,this.ySums=new n.UsageSums,this.zSums=new n.UsageSums,this._workRange=i.Range3d.createNull()}accumulateGrowableXYZArrayRange(t){t.setRange(this._workRange),this.range.extendRange(this._workRange),this.xSums.accumulate(this._workRange.xLength()),this.ySums.accumulate(this._workRange.yLength()),this.zSums.accumulate(this._workRange.zLength())}}},"./lib/polyface/TriangleCandidate.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/Geometry.js"),s=r("./lib/geometry3d/BarycentricTriangle.js");class TriangleCandidate extends s.BarycentricTriangle{constructor(t,e,r,i,n,s){super(t,e,r),this._isValid=s,this._quality=n,this.id=i}setFrom(t){return super.setFrom(t),this._isValid=t._isValid,this._quality=t._quality,this.id=t.id,this}static createFromIndexedXYZ(t,e,r,n,s,o,a,c){c||(c=new TriangleCandidate(i.Point3d.create(),i.Point3d.create(),i.Point3d.create(),a,0,!1)),c.id=a;let l=0;return void 0!==t.getPoint3dAtCheckedPointIndex(e,c.points[0])&&l++,void 0!==r.getPoint3dAtCheckedPointIndex(n,c.points[1])&&l++,void 0!==s.getPoint3dAtCheckedPointIndex(o,c.points[2])&&l++,3===l?c.updateAspectRatio():c.markInvalid(),c}get isValid(){return this._isValid}markInvalid(t){this._isValid=!1,void 0!==t&&(this._quality=t)}updateAspectRatio(){this._quality=super.aspectRatio,this._isValid=this._quality>0}clone(t){return t?t.setFrom(this):new TriangleCandidate(this.points[0].clone(),this.points[1].clone(),this.points[2].clone(),this.id,this._quality,this._isValid)}static copyWithLowerQuality(t,e,r){if(r=t.clone(r),e.isValid){const i=t.dotProductOfCrossProductsFromOrigin(e);r._quality=n.Geometry.minXY(t.aspectRatio,e.aspectRatio),i<0&&(r._quality-=1)}return r}static updateIfOtherHasHigherQuality(t,e){e.isValid&&e._quality>t._quality&&t.setFrom(e)}}e.TriangleCandidate=TriangleCandidate},"./lib/polyface/multiclip/GriddedRaggedRange2dSet.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/polyface/multiclip/LinearSearchRange2dArray.js");class GriddedRaggedRange2dSet{constructor(t,e,r){this._range=t,this._numXEdge=e,this._numYEdge=r,this._rangesInBlock=[];for(let i=0;i<this._numYEdge;i++){const t=[];for(let e=0;e<this._numXEdge;e++)t.push(void 0);this._rangesInBlock.push(t)}}static create(t,e,r){if(!(e<1||r<1||t.isNull||t.isSinglePoint))return new GriddedRaggedRange2dSet(t.clone(),e,r)}xIndex(t){const e=(t-this._range.low.x)/(this._range.high.x-this._range.low.x);return Math.floor(e*this._numXEdge)}yIndex(t){const e=(t-this._range.low.y)/(this._range.high.y-this._range.low.y);return Math.floor(e*this._numXEdge)}getBlock(t,e){if(t>=0&&t<this._numXEdge&&e>=0&&e<this._numYEdge)return this._rangesInBlock[e][t]||(this._rangesInBlock[e][t]=new i.LinearSearchRange2dArray),this._rangesInBlock[e][t]}conditionalInsert(t,e){if(t.isNull)return!1;if(!this._range.containsRange(t))return!1;const r=this.xIndex(t.low.x),i=this.xIndex(t.high.x),n=this.yIndex(t.low.y),s=this.yIndex(t.high.y);if(r!==i&&r+1!==i)return!1;if(n!==s&&n+1!==s)return!1;const o=this.getBlock(r,n);return!!o&&(o.addRange(t,e),!0)}searchXYInIndexedBlock(t,e,r,i,n){const s=this.getBlock(t,e);return!s||s.searchXY(r,i,n)}searchRange2dInIndexedBlock(t,e,r,i){const n=this.getBlock(t,e);return!n||n.searchRange2d(r,i)}searchXY(t,e,r){const i=this.xIndex(t),n=this.yIndex(e);return this.searchXYInIndexedBlock(i,n,t,e,r)&&this.searchXYInIndexedBlock(i-1,n,t,e,r)&&this.searchXYInIndexedBlock(i,n-1,t,e,r)&&this.searchXYInIndexedBlock(i-1,n-1,t,e,r)}searchRange2d(t,e){const r=this.xIndex(t.low.x)-1,i=this.xIndex(t.high.x),n=this.yIndex(t.low.y)-1,s=this.yIndex(t.high.y);for(let o=r;o<=i;o++)for(let r=n;r<=s;r++)if(!this.searchRange2dInIndexedBlock(o,r,t,e))return!1;return!0}visitChildren(t,e){for(const r of this._rangesInBlock)for(const i of r)i&&e(t,i)}}e.GriddedRaggedRange2dSet=GriddedRaggedRange2dSet},"./lib/polyface/multiclip/GriddedRaggedRange2dSetWithOverflow.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/polyface/multiclip/LinearSearchRange2dArray.js"),n=r("./lib/polyface/multiclip/GriddedRaggedRange2dSet.js");class GriddedRaggedRange2dSetWithOverflow{constructor(t,e){this._gridSet=t,this._overflowSet=e}static create(t,e,r){const s=n.GriddedRaggedRange2dSet.create(t.clone(),e,r);if(s)return new GriddedRaggedRange2dSetWithOverflow(s,new i.LinearSearchRange2dArray)}searchXY(t,e,r){return this._gridSet.searchXY(t,e,r)&&this._overflowSet.searchXY(t,e,r)}searchRange2d(t,e){return this._gridSet.searchRange2d(t,e)&&this._overflowSet.searchRange2d(t,e)}addRange(t,e){t.isNull||this._gridSet.conditionalInsert(t,e)||this._overflowSet.addRange(t,e)}visitChildren(t,e){e(t,this._overflowSet),this._gridSet.visitChildren(t+1,e)}}e.GriddedRaggedRange2dSetWithOverflow=GriddedRaggedRange2dSetWithOverflow},"./lib/polyface/multiclip/LinearSearchRange2dArray.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js");e.LinearSearchRange2dArray=class LinearSearchRange2dArray{constructor(){this._rangeArray=[],this._isDirty=!1,this._compositeRange=i.Range2d.createNull()}updateForSearch(){this._isDirty=!1}totalRange(t){return t=t||i.Range2d.createNull(),this._compositeRange.clone(t)}addRange(t,e){this._isDirty=!0;const r=i.Range2d.createNull();r.tag=e,r.extendXY(t.low.x,t.low.y),r.extendXY(t.high.x,t.high.y),this._compositeRange.extendRange(r),this._rangeArray.push(r)}searchXY(t,e,r){this._isDirty&&this.updateForSearch();for(const i of this._rangeArray)if(i.containsXY(t,e)&&!r(i,i.tag))return!1;return!0}searchRange2d(t,e){this._isDirty&&this.updateForSearch();for(const r of this._rangeArray)if(r.intersectsRange(t)&&!e(r,r.tag))return!1;return!0}}},"./lib/polyface/multiclip/RangeSearch.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js"),n=r("./lib/Geometry.js"),s=r("./lib/polyface/multiclip/GriddedRaggedRange2dSetWithOverflow.js"),o=r("./lib/polyface/multiclip/LinearSearchRange2dArray.js");class RangeSearch{static create2dSearcherForRangeLengthData(t,e=RangeSearch.defaultRangesPerBlockEdge,r=RangeSearch.defaultStandardDeviationAdjustment){if(t.xSums.count<RangeSearch.smallCountLimit)return new o.LinearSearchRange2dArray;const n=this.estimateGridBlockCount(t.range.xLength(),t.xSums,e,r),a=this.estimateGridBlockCount(t.range.yLength(),t.ySums,e,r);return n<2&&a<2?new o.LinearSearchRange2dArray:s.GriddedRaggedRange2dSetWithOverflow.create(i.Range2d.createFrom(t.range),n,a)}static estimateGridBlockCount(t,e,r=RangeSearch.defaultRangesPerBlockEdge,i=RangeSearch.defaultStandardDeviationAdjustment){if(e.count<1)return 1;const s=r*(e.mean+i*e.standardDeviation),o=n.Geometry.conditionalDivideFraction(t,s);return void 0===o?1:Math.ceil(o)}}e.RangeSearch=RangeSearch,RangeSearch.smallCountLimit=40,RangeSearch.defaultRangesPerBlockEdge=4,RangeSearch.defaultStandardDeviationAdjustment=1},"./lib/polyface/multiclip/XYPointBuckets.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Range.js"),n=r("./lib/Geometry.js"),s=r("./lib/geometry3d/Point3dVector3d.js");class XYIndexGrid{constructor(t,e,r){this._range=t,this._numXEdge=Math.max(e,1),this._numYEdge=Math.max(r,1),this._data=[];for(let i=0;i<r;i++){const t=[];for(let r=0;r<e;r++)t.push(void 0);this._data.push(t)}}get numXEdge(){return this._numXEdge}get numYEdge(){return this._numYEdge}xIndex(t){const e=(t-this._range.low.x)/(this._range.high.x-this._range.low.x),r=Math.floor(e*this._numXEdge);return r<0?0:r>this._numXEdge-1?this._numXEdge-1:r}yIndex(t){const e=(t-this._range.low.y)/(this._range.high.y-this._range.low.y),r=Math.floor(e*this._numYEdge);return r<0?0:r>this._numYEdge-1?this._numYEdge-1:r}static createWithEstimatedCounts(t,e,r){if(t.low.x>=t.high.x||t.low.y>=t.high.y)return;const n=i.Range2d.createXYXY(t.low.x,t.low.y,t.high.x,t.high.y),s=n.xLength(),o=n.yLength();let a,c;return o>s?(c=Math.ceil(Math.sqrt(o*e/(r*s))),a=Math.ceil(e/c)):(a=Math.ceil(Math.sqrt(s*e/(r*o))),c=Math.ceil(e/(a*r))),new XYIndexGrid(n,a,c)}addDataAtXY(t,e,r){const i=this.xIndex(t),n=this.yIndex(e);let s=this._data[n][i];s||(s=[],this._data[n][i]=s),s.push(r)}getDataAtXY(t,e){const r=this.xIndex(t),i=this.yIndex(e);return this._data[i][r]}getDataAtIndex(t,e){if(!(t<0)&&!(t>=this._numXEdge)&&!(e<0)&&!(e>=this._numYEdge))return this._data[e][t]}isValidIndex(t,e){return!(t<0)&&(!(t>=this._numXEdge)&&(!(e<0)&&!(e>=this._numYEdge)))}}e.XYIndexGrid=XYIndexGrid;class XYPointBuckets{constructor(t,e){this._points=t,this._buckets=e}get indexGrid(){return this._buckets}static create(t,e){const r=t.length;if(t.length<1)return;const i=t.getRange();i.expandInPlace(1e3*n.Geometry.smallMetricDistance);const o=XYIndexGrid.createWithEstimatedCounts(i,t.length,e);if(void 0===o)return;const a=new XYPointBuckets(t,o),c=s.Point3d.create();for(let n=0;n<r;n++)t.getPoint3dAtUncheckedPointIndex(n,c),o.addDataAtXY(c.x,c.y,n);return a}announcePointsInRange(t,e){const r=this._buckets.xIndex(t.low.x),i=this._buckets.xIndex(t.high.x),n=this._buckets.yIndex(t.low.y),s=this._buckets.yIndex(t.high.y),o=this._points.length;for(let a=r;a<=i;a++)for(let r=n;r<=s;r++){const i=this._buckets.getDataAtIndex(a,r);if(void 0!==i)for(const r of i)if(r<o){const i=this._points.getXAtUncheckedPointIndex(r),n=this._points.getYAtUncheckedPointIndex(r),s=this._points.getZAtUncheckedPointIndex(r);if(t.containsXY(i,n)&&!e(r,i,n,s))return}}}}e.XYPointBuckets=XYPointBuckets},"./lib/serialization/DeepCompare.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.DeepCompare=class DeepCompare{constructor(t=1e-12){this.typeCounts={numbers:0,arrays:0,functions:0,objects:0,strings:0,booleans:0,undefined:0},this.propertyCounts={},this.errorTracker=[],this.numberRelTol=t}compareNumber(t,e){return Math.abs(e-t)<this.numberRelTol*(1+Math.abs(t)+Math.abs(e))?this.announce(!0):(this.errorTracker.unshift(e),this.errorTracker.unshift(t),this.errorTracker.unshift("In "+this.errorTracker[this.errorTracker.length-1]+" property: Mismatched values"),this.announce(!1))}compareArray(t,e){if(t.length!==e.length){const r={},i={};for(const t of e)if("object"===typeof t&&"function"!==typeof t&&!Array.isArray(t))for(const e in t)t.hasOwnProperty(e)&&(i.hasOwnProperty(e)||(i[e]=0),i[e]++);this.errorTracker.unshift(i);for(const e of t)if("object"===typeof e&&"function"!==typeof e&&!Array.isArray(e))for(const t in e)e.hasOwnProperty(t)&&(r.hasOwnProperty(t)||(r[t]=0),r[t]++);return this.errorTracker.unshift(r),this.errorTracker.unshift("Mismatched array lengths a: ["+t.length+"] b: ["+e.length+"]"),this.announce(!1)}let r=!0;for(let i=0;i<t.length;i++)if(!(r=r&&this.compareInternal(t[i],e[i]))){this.errorTracker.unshift("["+i.toString()+"]");break}return this.announce(r)}compareObject(t,e){if(null==t&&null==e)return this.announce(!0);if(Object.keys(t).length!==Object.keys(e).length)return this.errorTracker.unshift("Mismatched property lists ["+Object.keys(t)+"]["+Object.keys(e)+"]"),this.announce(!1);let r=!0;for(const i in t)if(t.hasOwnProperty(i)){if(this.propertyCounts.hasOwnProperty(i)||(this.propertyCounts[i]=0),this.propertyCounts[i]++,!e.hasOwnProperty(i))return this.errorTracker.unshift("Property "+i+" of A not in B"),this.errorTracker.unshift(t),this.errorTracker.unshift(e),this.announce(!1);if(!(r=r&&this.compareInternal(t[i],e[i]))){this.errorTracker.unshift(i);break}}return this.announce(r)}announce(t){return!!t}compare(t,e,r){return void 0!==r&&(this.numberRelTol=r),this.errorTracker.length=0,this.typeCounts.numbers=this.typeCounts.arrays=this.typeCounts.functions=this.typeCounts.objects=this.typeCounts.strings=this.typeCounts.booleans=this.typeCounts.undefined=0,this.propertyCounts={},this.compareInternal(t,e)}compareInternal(t,e){return typeof t!==typeof e?this.announce(!1):"number"===typeof t&&"number"===typeof e?(this.typeCounts.numbers++,this.compareNumber(t,e)):Array.isArray(t)&&Array.isArray(e)?(this.typeCounts.arrays++,this.compareArray(t,e)):"function"===typeof t&&"function"===typeof e?(this.typeCounts.functions++,!0):"object"===typeof t&&"object"===typeof e?(this.typeCounts.objects++,t===e||this.compareObject(t,e)):"string"===typeof t&&"string"===typeof e?(this.typeCounts.strings++,t===e):"boolean"===typeof t&&"boolean"===typeof e?(this.typeCounts.booleans++,t===e):"undefined"===typeof t&&"undefined"===typeof e?(this.typeCounts.undefined++,!0):this.announce(!1)}}},"./lib/serialization/GeometrySamples.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/AngleSweep.js"),s=r("./lib/geometry3d/Angle.js"),o=r("./lib/geometry3d/Plane3dByOriginAndUnitNormal.js"),a=r("./lib/geometry3d/Ray3d.js"),c=r("./lib/geometry3d/Point2dVector2d.js"),l=r("./lib/geometry3d/Point3dVector3d.js"),d=r("./lib/geometry3d/Segment1d.js"),h=r("./lib/geometry3d/Transform.js"),u=r("./lib/geometry3d/Matrix3d.js"),f=r("./lib/geometry3d/Range.js"),g=r("./lib/geometry4d/Map4d.js"),p=r("./lib/geometry4d/Matrix4d.js"),m=r("./lib/geometry4d/Point4d.js"),y=r("./lib/curve/UnionRegion.js"),P=r("./lib/curve/CurveCollection.js"),x=r("./lib/curve/ParityRegion.js"),_=r("./lib/curve/Loop.js"),v=r("./lib/curve/Path.js"),S=r("./lib/polyface/Polyface.js"),C=r("./lib/bspline/BSplineCurve.js"),A=r("./lib/bspline/BSplineSurface.js"),w=r("./lib/solid/Sphere.js"),b=r("./lib/solid/Cone.js"),I=r("./lib/solid/Box.js"),T=r("./lib/solid/TorusPipe.js"),M=r("./lib/solid/LinearSweep.js"),R=r("./lib/solid/RotationalSweep.js"),F=r("./lib/solid/RuledSweep.js"),k=r("./lib/curve/LineSegment3d.js"),X=r("./lib/curve/Arc3d.js"),Y=r("./lib/curve/TransitionSpiral.js"),V=r("./lib/curve/LineString3d.js"),D=r("./lib/curve/PointString3d.js"),z=r("./lib/clipping/ClipPlane.js"),B=r("./lib/clipping/ConvexClipPlaneSet.js"),O=r("./lib/geometry3d/GrowableFloat64Array.js"),E=r("./lib/geometry3d/GrowableXYZArray.js"),G=r("./lib/clipping/UnionOfConvexClipPlaneSets.js"),j=r("./lib/bspline/BSplineCurve3dH.js"),L=r("./lib/bspline/BezierCurve3d.js"),N=r("./lib/bspline/BezierCurve3dH.js"),Z=r("./lib/curve/CurveChainWithDistanceIndex.js"),U=r("./lib/bspline/KnotVector.js"),W=r("./lib/curve/CoordinateXYZ.js");class Sample{static createPoint3dLattice(t,e,r){const i=[];for(let n=t;n<=r;n+=e)for(let s=t;s<=r;s+=e)for(let o=t;o<=r;o+=e)i.push(l.Point3d.create(o,s,n));return i}static createPoint2dLattice(t,e,r){const i=[];for(let n=t;n<=r;n+=e)for(let s=t;s<=r;s+=e)i.push(c.Point2d.create(s,n));return i}static createNonZeroVectors(){return[l.Vector3d.create(1,0,0),l.Vector3d.create(0,1,0),l.Vector3d.create(0,0,1),l.Vector3d.create(-1,0,0),l.Vector3d.create(0,-1,0),l.Vector3d.create(0,0,-1),l.Vector3d.createPolar(1,s.Angle.createDegrees(20)),l.Vector3d.createSpherical(1,s.Angle.createDegrees(20),s.Angle.createDegrees(10)),l.Vector3d.createPolar(2,s.Angle.createDegrees(20)),l.Vector3d.createSpherical(2,s.Angle.createDegrees(20),s.Angle.createDegrees(10)),l.Vector3d.create(2,3,0)]}static createRange3ds(){return[f.Range3d.createXYZXYZ(0,0,0,1,1,1),f.Range3d.createXYZ(1,2,3),f.Range3d.createXYZXYZ(-2,-3,1,200,301,8)]}static createRectangleXY(t,e,r,i,n=0){return[l.Point3d.create(t,e,n),l.Point3d.create(t+r,e,n),l.Point3d.create(t+r,e+i,n),l.Point3d.create(t,e+i,n),l.Point3d.create(t,e,n)]}static pushMove(t,e,r,i=0){0===t.length&&t.push(l.Point3d.create(0,0,0));const n=t[t.length-1];0===e&&0===r&&0===i||t.push(l.Point3d.create(n.x+e,n.y+r,n.z+i))}static pushClosure(t){t.length>0&&t.push(t[t.length-1].clone())}static createUnitCircle(t){const e=[],r=i.Geometry.safeDivideFraction(2*Math.PI,t-1,0);for(let i=0;i<t;i++){const t=i*r;e.push(l.Point3d.create(Math.cos(t),Math.sin(t),0))}return e}static createLShapedPolygon(t,e,r,i,n,s,o=0){return[l.Point3d.create(t,e,o),l.Point3d.create(t+r,e,o),l.Point3d.create(t+r,e+s),l.Point3d.create(t+n,e+s),l.Point3d.create(t+n,e+i,o),l.Point3d.create(t,e+i,o),l.Point3d.create(t,e,o)]}static createClipPlanes(){const t=z.ClipPlane.createNormalAndDistance(l.Vector3d.create(1,0,0),2),e=t.cloneNegated(),r=e.clone();return r.setFlags(!0,!0),[t,e,r,z.ClipPlane.createNormalAndDistance(l.Vector3d.create(3,4,0),2),z.ClipPlane.createEdgeXY(l.Point3d.create(1,0,0),l.Point3d.create(24,32,0))]}static createClipPlaneSets(){const t=[],e=B.ConvexClipPlaneSet.createXYBox(0,0,1,1);t.push(G.UnionOfConvexClipPlaneSets.createConvexSets([e.clone()]));const r=B.ConvexClipPlaneSet.createXYBox(-1,0,0,1),i=B.ConvexClipPlaneSet.createXYBox(0,-1,1,0);return t.push(G.UnionOfConvexClipPlaneSets.createConvexSets([e.clone(),i.clone()])),t.push(G.UnionOfConvexClipPlaneSets.createConvexSets([e.clone(),r.clone(),i.clone()])),t}static createBsplineCurves(t=!1){const e=[];for(const r of[2,3,4,5]){const t=[];for(const e of[0,1,2,3,4,5,7])t.push(l.Point3d.create(e,.1*(1+e*e),0));const i=C.BSplineCurve3d.createUniformKnots(t,r);e.push(i)}if(t){const t=[1,2,2,3,4,5,5,6,7,7,8];for(const r of[3,4]){const i=8,n=[];for(let t=0;t<i;t++)n.push(l.Point3d.create(t,t*t,0));const s=[];for(let t=0;t<r-1;t++)s.push(0);const o=i-r;for(let e=0;e<o;e++)s.push(t[e]);const a=s[s.length-1]+1;for(let t=0;t<r-1;t++)s.push(a);const c=C.BSplineCurve3d.create(n,s,r);c&&e.push(c)}}return e}static createBspline3dHCurves(){const t=[];for(const e of[0,.125])for(const r of[2,3,4,5]){const i=[];for(const t of[0,1,2,3,4,5,7])i.push(m.Point4d.create(t,.1*(1+t*t),0,1+e*Math.sin(t*Math.PI*.25)));const n=j.BSplineCurve3dH.createUniformKnots(i,r);t.push(n)}return t}static createBspline3dHArcs(){const t=[],e=s.Angle.degreesToRadians(60),r=Math.cos(e),i=Math.sin(e),n=[m.Point4d.create(1,0,0,1),m.Point4d.create(r,i,0,r),m.Point4d.create(-r,i,0,1),m.Point4d.create(-1,0,0,r),m.Point4d.create(-r,-i,0,1),m.Point4d.create(r,-i,0,r),m.Point4d.create(1,0,0,1)],o=j.BSplineCurve3dH.create(n,[0,0,1,1,2,2,3,3],3);return t.push(o),t}static createBsplineArc90SectionToXYZWArrays(t,e,r,i,n){const s=Math.sqrt(.5),o=l.Point3d.create();u.Matrix3d.xyzPlusMatrixTimesCoordinates(t,e,r,0,0,o);const a=[];a.push([o.x,o.y,o.z,1]);const c=[1,1,-1,-1,1],d=[1,0,-1,0,1];for(let l=0;l<4;l++)u.Matrix3d.xyzPlusMatrixTimesCoordinates(t,e,r*c[l+1],i*c[l],0,o),a.push([o.x,o.y,o.z,s]),u.Matrix3d.xyzPlusMatrixTimesCoordinates(t,e,r*d[l+1],i*d[l],0,o),a.push([o.x,o.y,o.z,1]);if(n)for(const l of a){const t=l[3];l[0]*=t,l[1]*=t,l[2]*=t}return a}static createMixedBsplineCurves(){const t=Sample.createBsplineCurves(),e=Sample.createBspline3dHCurves(),r=[];for(const i of t)r.push(i);for(const i of e)r.push(i);return r}static createPlane(t,e,r,i,n,s){const a=l.Point3d.create(t,e,r),c=l.Vector3d.create(i,n,s).normalize();if(c){const t=o.Plane3dByOriginAndUnitNormal.create(a,c);if(t)return t}return Sample.createPlane(t,e,r,i,n,1)}static createRay(t,e,r,i,n,s){return a.Ray3d.create(l.Point3d.create(t,e,r),l.Vector3d.create(i,n,s).normalize())}static createLineStrings(){return[V.LineString3d.createPoints([l.Point3d.create(0,0,0),l.Point3d.create(1,0,0)]),V.LineString3d.createPoints([l.Point3d.create(0,0,0),l.Point3d.create(1,0,0),l.Point3d.create(1,1,0)]),V.LineString3d.createPoints([l.Point3d.create(0,0,0),l.Point3d.create(1,0,0),l.Point3d.create(1,1,0),l.Point3d.create(2,2,0)])]}static createMatrix3dArray(){return[u.Matrix3d.createIdentity(),u.Matrix3d.createRotationAroundVector(l.Vector3d.create(1,0,0),s.Angle.createDegrees(10)),u.Matrix3d.createRotationAroundVector(l.Vector3d.create(1,-2,5),s.Angle.createDegrees(-6)),u.Matrix3d.createUniformScale(2),u.Matrix3d.createRotationAroundVector(l.Vector3d.create(1,2,3),s.Angle.createDegrees(49)),u.Matrix3d.createScale(1,1,-1),u.Matrix3d.createScale(2,3,4)]}static createInvertibleTransforms(){return[h.Transform.createIdentity(),h.Transform.createTranslationXYZ(1,2,0),h.Transform.createTranslationXYZ(1,2,3),h.Transform.createFixedPointAndMatrix(l.Point3d.create(4,1,-2),u.Matrix3d.createUniformScale(2)),h.Transform.createFixedPointAndMatrix(l.Point3d.create(4,1,-2),u.Matrix3d.createRotationAroundVector(l.Vector3d.create(1,2,3),s.Angle.createRadians(10)))]}static createScaleSkewMatrix3d(){return[u.Matrix3d.createRowValues(1,0,0,0,1,0,0,0,1),u.Matrix3d.createRowValues(5,0,0,0,6,0,0,0,7),u.Matrix3d.createRowValues(5,2,0,0,6,0,0,0,7),u.Matrix3d.createRowValues(5,0,2,0,6,0,0,0,7),u.Matrix3d.createRowValues(5,0,0,1,6,0,0,0,7),u.Matrix3d.createRowValues(5,0,0,0,6,1,0,0,7),u.Matrix3d.createRowValues(5,0,0,0,6,0,1,0,7),u.Matrix3d.createRowValues(5,0,0,0,6,0,0,1,7),u.Matrix3d.createRowValues(5,2,3,2,6,1,-1,2,7)]}static createSingularMatrix3d(){const t=l.Vector3d.create(2,3,6),e=l.Vector3d.create(-1,5,2),r=t.plus(e),i=l.Vector3d.createZero();return[u.Matrix3d.createZero(),u.Matrix3d.createColumns(t,i,i),u.Matrix3d.createColumns(i,t,i),u.Matrix3d.createColumns(i,i,i),u.Matrix3d.createColumns(t,e,i),u.Matrix3d.createColumns(i,t,e),u.Matrix3d.createColumns(e,i,i),u.Matrix3d.createColumns(t,e,r),u.Matrix3d.createColumns(t,r,e),u.Matrix3d.createColumns(r,e,t),u.Matrix3d.createColumns(t,e,t),u.Matrix3d.createColumns(t,t,e),u.Matrix3d.createColumns(e,e,t)]}static createRigidTransforms(t=4){const e=t/3,r=t/4;return[h.Transform.createIdentity(),h.Transform.createTranslationXYZ(1*e,2*e,3*e),h.Transform.createFixedPointAndMatrix(l.Point3d.create(0,0,0),u.Matrix3d.createRotationAroundVector(l.Vector3d.unitY(),s.Angle.createDegrees(10))),h.Transform.createFixedPointAndMatrix(l.Point3d.create(4*r,1*r,2*-r),u.Matrix3d.createRotationAroundVector(l.Vector3d.create(1,2,3),s.Angle.createDegrees(10))),h.Transform.createFixedPointAndMatrix(l.Point3d.create(4*r,1*r,2*-r),u.Matrix3d.createRotationAroundVector(l.Vector3d.create(-2,1,4),s.Angle.createDegrees(35)))]}static createMessyRigidTransform(t){return h.Transform.createFixedPointAndMatrix(t||l.Point3d.create(1,2,3),u.Matrix3d.createRotationAroundVector(l.Vector3d.create(.3,-.2,1.2),s.Angle.createDegrees(15.7)))}static createRigidAxes(){return[u.Matrix3d.createIdentity(),u.Matrix3d.createRotationAroundVector(l.Vector3d.unitX(),s.Angle.createDegrees(10)),u.Matrix3d.createRotationAroundVector(l.Vector3d.unitY(),s.Angle.createDegrees(10)),u.Matrix3d.createRotationAroundVector(l.Vector3d.unitZ(),s.Angle.createDegrees(10)),u.Matrix3d.createRotationAroundVector(l.Vector3d.create(1,2,3),s.Angle.createDegrees(10))]}static createMatrix4ds(t=!1){const e=[];let r;for(r of Sample.createInvertibleTransforms())e.push(p.Matrix4d.createTransform(r));return t&&e.push(p.Matrix4d.createRowValues(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)),e}static createMap4ds(){const t=[];let e;for(e of Sample.createInvertibleTransforms()){const r=e.inverse();if(r){const i=g.Map4d.createTransform(e,r);i&&t.push(i)}}return t}static createSimplePaths(t=!1){const e=l.Point3d.create(0,0,0),r=l.Point3d.create(10,0,0),i=[r,l.Point3d.create(0,10,0),l.Point3d.create(6,10,0),l.Point3d.create(6,10,0),l.Point3d.create(0,10,0)],s=k.LineSegment3d.create(e,r),o=l.Vector3d.unitX(3),a=l.Vector3d.unitY(3),c=X.Arc3d.create(r.minus(o),o,a,n.AngleSweep.createStartEndDegrees(0,90)),d=[v.Path.create(s),v.Path.create(s,c),v.Path.create(k.LineSegment3d.create(e,r),V.LineString3d.create(i)),Sample.createCappedArcPath(4,0,180)];return t&&d.push(v.Path.create(k.LineSegment3d.create(l.Point3d.create(0,0,0),l.Point3d.create(10,0,0)),k.LineSegment3d.create(l.Point3d.create(10,10,0),l.Point3d.create(5,0,0)))),d}static createLineArcPaths(){const t=[];for(const e of[0,-1,1])for(const r of[15,11,20,9,7]){const i=l.Point3d.create(0,e,0),n=l.Point3d.create(10,0,0),s=l.Point3d.create(r,5,0),o=l.Point3d.create(10,10,0),a=l.Point3d.create(0,10+e,0),c=v.Path.create();c.tryAddChild(V.LineString3d.create(i,n,s,o,a)),t.push(c);const d=v.Path.create();d.tryAddChild(k.LineSegment3d.create(i,n)),d.tryAddChild(X.Arc3d.createCircularStartMiddleEnd(n,l.Point3d.create(r,5,0),o)),d.tryAddChild(k.LineSegment3d.create(o,a)),t.push(d)}return t}static createSimplePointStrings(){const t=[[l.Point3d.create(0,10,0)],[l.Point3d.create(6,10,0)],[l.Point3d.create(6,10,0),[l.Point3d.create(6,10,0)]]];return[D.PointString3d.create(l.Point3d.create(1,2,0)),D.PointString3d.create(l.Point3d.create(0,0,0),l.Point3d.create(10,0,0)),D.PointString3d.create(l.Point3d.create(10,0,0),l.Point3d.create(10,5,0)),D.PointString3d.create(t)]}static createSimpleLoops(){const t=l.Point3d.create(0,0,0),e=l.Point3d.create(10,0,0),r=l.Point3d.create(10,5,0),i=l.Point3d.create(0,5,0);return[_.Loop.create(V.LineString3d.create(t,e,r,i,t)),_.Loop.create(X.Arc3d.createUnitCircle()),_.Loop.create(k.LineSegment3d.create(t,e),k.LineSegment3d.create(e,r),k.LineSegment3d.create(r,i),k.LineSegment3d.create(i,t)),Sample.createCappedArcLoop(4,-90,90)]}static createSquareWave(t,e,r,i,n,s){const o=[t.clone()];for(let a=0;a<n;a++)this.pushMove(o,e,0),this.pushMove(o,0,r),this.pushMove(o,i,0),this.pushMove(o,0,-r);return this.pushMove(o,e,0),0!==s&&(this.pushMove(o,0,s),o.push(l.Point3d.create(t.x,t.y+s)),o.push(o[0].clone())),o}static createInterpolatedPoints(t,e,r,i,n,s){r<2&&(r=2),void 0===i&&(i=[]),void 0===n&&(n=0),void 0===s&&(s=r);for(let o=n;o<=s;o++)i.push(t.interpolate(o/r,e));return i}static appendSawTooth(t,e,r,i,n,s){for(let o=0;o<s;o++)this.pushMove(t,e,0,0),this.pushMove(t,r,i,0),this.pushMove(t,n,0,0),this.pushMove(t,r,-i,0);return t}static appendVariableSawTooth(t,e,r,i,n,s,o){let a=1;for(let c=0;c<s;c++)this.appendSawTooth(t,a*e,a*r,i,a*n,1),a*=o;return t}static createBidirectionalSawtooth(t,e,r,i,n,s,o,a,c,l,d){const h=[t.clone()],u=h[0].x;this.appendSawTooth(h,e,r,i,n,s),this.pushMove(h,e,0,0),this.pushMove(h,0,o);const f=h[h.length-1].x,g=Math.abs(a+2*c+d),p=Math.abs(f-u),m=Math.floor(Math.abs(p/g));this.appendSawTooth(h,-a,-c,l,-d,m);const y=h[h.length-1].x;return this.pushMove(h,u-y,0,0),h.push(h[0].clone()),h}static appendPhases(t,e,...r){const i=t.endPoint();0===t.numPoints()&&t.addPoint(i);for(let n=0;n<e;n++)for(const e of r)i.addInPlace(e),t.addPoint(i)}static createArcRegions(){const t=[],e=l.Point3d.create(0,0,0);for(const r of[n.AngleSweep.createStartEndDegrees(0,360),n.AngleSweep.createStartEndDegrees(-20,20),n.AngleSweep.createStartEndDegrees(0,90),n.AngleSweep.createStartEndDegrees(0,180)]){const i=X.Arc3d.createXY(l.Point3d.create(0,0),2,r);if(i.sweep.isFullCircle)t.push(_.Loop.create(i));else{const r=k.LineSegment3d.create(i.endPoint(),i.startPoint());t.push(_.Loop.create(i,r)),t.push(_.Loop.create(i,V.LineString3d.create(i.endPoint(),e,i.startPoint())))}}return t}static createSimpleXYPointLoops(){const t=[];return t.push(Sample.createRectangleXY(0,0,1,1)),t.push(Sample.createRectangleXY(0,0,4,3)),t.push(Sample.createLShapedPolygon(0,0,5,4,1,2)),t}static createSimpleParityRegions(t=!1){const e=l.Point3d.create(-5,0,0),r=l.Point3d.create(0,0,0),i=l.Point3d.create(4,2,0),s=l.Point3d.create(6,4,0),o=l.Point3d.create(5,5,0),a=l.Point3d.create(8,3,0),c=n.AngleSweep.createStartEndDegrees(0,-360),d=r.plusXYZ(10,0,0),h=d.plusXYZ(0,8,0),u=r.plusXYZ(0,8),f=[x.ParityRegion.create(_.Loop.create(V.LineString3d.create(r,d,h),X.Arc3d.createCircularStartMiddleEnd(h,u,r)),_.Loop.create(V.LineString3d.createRectangleXY(i,-3,2))),x.ParityRegion.create(_.Loop.create(X.Arc3d.createXY(e,2)),_.Loop.create(X.Arc3d.createXY(e,1,c))),x.ParityRegion.create(_.Loop.create(V.LineString3d.createRectangleXY(r,10,8)),_.Loop.create(V.LineString3d.createRectangleXY(i,-3,2))),x.ParityRegion.create(_.Loop.create(V.LineString3d.createRectangleXY(r,10,8)),_.Loop.create(V.LineString3d.createRectangleXY(i,-3,2)),_.Loop.create(X.Arc3d.createXY(s,.5,c))),x.ParityRegion.create(_.Loop.create(V.LineString3d.createRectangleXY(r,10,8)),_.Loop.create(V.LineString3d.createRectangleXY(i,-3,2)),_.Loop.create(X.Arc3d.createXY(s,.5,c)),_.Loop.create(V.LineString3d.createRectangleXY(o,-3,2))),x.ParityRegion.create(_.Loop.create(V.LineString3d.create(r,d,h),X.Arc3d.createCircularStartMiddleEnd(h,u,r)),_.Loop.create(V.LineString3d.createRectangleXY(i,-3,2)),_.Loop.create(X.Arc3d.create(a,l.Vector3d.create(-.5,0),l.Vector3d.create(0,2.5))),_.Loop.create(V.LineString3d.createRectangleXY(o,-3,2)))];if(t){const t=1;f.push(x.ParityRegion.create(_.Loop.create(k.LineSegment3d.create(r,d),C.BSplineCurve3d.createUniformKnots([d,l.Point3d.create(11,t),l.Point3d.create(11,2*t),l.Point3d.create(12,3*t),l.Point3d.create(11,4*t),h],3),X.Arc3d.createCircularStartMiddleEnd(h,u,r))))}return f}static createSimpleUnions(){const t=Sample.createSimpleParityRegions(),e=t[0].range();return[y.UnionRegion.create(_.Loop.create(V.LineString3d.createRectangleXY(l.Point3d.create(0,0,0),3,1)),_.Loop.create(V.LineString3d.createRectangleXY(l.Point3d.create(0,2,0),4,2))),y.UnionRegion.create(_.Loop.create(V.LineString3d.create(Sample.createRectangleXY(e.low.x,e.high.y+.5,e.xLength(),e.yLength()))),t[0])]}static createBagOfCurves(){const t=Sample.createSimpleParityRegions(),e=Sample.createSimpleLoops();return[P.BagOfCurves.create(e[0],t[0],k.LineSegment3d.createXYXY(0,1,4,2,1)),P.BagOfCurves.create(X.Arc3d.createUnitCircle()),P.BagOfCurves.create(k.LineSegment3d.create(l.Point3d.create(0,0,0),l.Point3d.create(1,1,0))),P.BagOfCurves.create(V.LineString3d.create(l.Point3d.create(0,0,0),l.Point3d.create(1,1,0),l.Point3d.create(2,1,0)))]}static createSmoothCurvePrimitives(t=1){return[k.LineSegment3d.create(l.Point3d.create(0,0,0),l.Point3d.create(t,0,0)),k.LineSegment3d.create(l.Point3d.create(0,0,0),l.Point3d.create(t,t,0)),X.Arc3d.create(l.Point3d.create(0,0,0),l.Vector3d.create(t,0,0),l.Vector3d.create(0,t,0),n.AngleSweep.createStartEndDegrees(0,90)),X.Arc3d.create(l.Point3d.create(0,0,0),l.Vector3d.create(t,0,0),l.Vector3d.create(0,t,0),n.AngleSweep.createStartEndDegrees(-40,270)),X.Arc3d.create(l.Point3d.create(0,0,0),l.Vector3d.create(t,.1*t,0),l.Vector3d.create(-.03*t,.3*t,0),n.AngleSweep.createStartEndDegrees(-40,270))]}static createSimpleIndexedPolyfaces(t){return[Sample.createTriangularUnitGridPolyface(l.Point3d.create(),l.Vector3d.unitX(),l.Vector3d.unitY(),3*t,2*t,!1,!1,!1),Sample.createTriangularUnitGridPolyface(l.Point3d.create(),l.Vector3d.unitX(),l.Vector3d.unitY(),3*t,2*t,!0,!1,!1),Sample.createTriangularUnitGridPolyface(l.Point3d.create(),l.Vector3d.unitX(),l.Vector3d.unitY(),3*t,2*t,!1,!0,!1),Sample.createTriangularUnitGridPolyface(l.Point3d.create(),l.Vector3d.unitX(),l.Vector3d.unitY(),3*t,2*t,!1,!1,!0),Sample.createTriangularUnitGridPolyface(l.Point3d.create(),l.Vector3d.unitX(),l.Vector3d.unitY(),3*t,2*t,!0,!0,!0)]}static createTriangularUnitGridPolyface(t,e,r,i,n,s=!1,o=!1,a=!1){const c=S.IndexedPolyface.create(o,s,a),l=e.crossProduct(r);o&&(l.normalizeInPlace(),c.addNormalXYZ(l.x,l.y,l.z));for(let u=0;u<n;u++)for(let n=0;n<i;n++)c.addPoint(t.plus2Scaled(e,n,r,u)),s&&c.addParamUV(n,u);let d=10,h=0;for(let u=0;u+1<n;u++)for(let t=0;t+1<i;t++){const e=i*u+t,r=e+1,n=e+i,l=n+1;c.addPointIndex(e,!0),c.addPointIndex(r,!0),c.addPointIndex(l,!1),a&&(h=c.addColor(d++),c.addColorIndex(h),c.addColorIndex(h),c.addColorIndex(h)),s&&(c.addParamIndex(e),c.addParamIndex(r),c.addParamIndex(l)),o&&(c.addNormalIndex(0),c.addNormalIndex(0),c.addNormalIndex(0)),c.terminateFacet(!1),c.addPointIndex(l,!0),c.addPointIndex(n,!0),c.addPointIndex(e,!1),a&&(c.addColorIndex(h),c.addColorIndex(h),c.addColorIndex(h)),s&&(c.addParamIndex(l),c.addParamIndex(n),c.addParamIndex(e)),o&&(c.addNormalIndex(0),c.addNormalIndex(0),c.addNormalIndex(0)),c.terminateFacet(!1)}return c}static createXYGrid(t,e,r=1,i=1){const n=[];for(let s=0;s<e;s++)for(let e=0;e<t;e++)n.push(l.Point3d.create(e*r,s*i,0));return n}static createXYGridBsplineSurface(t,e,r,i){return A.BSplineSurface3d.create(Sample.createXYGrid(t,e,1,1),t,r,void 0,e,i,void 0)}static createPseudoTorusBsplineSurface(t,e,r,i,n,s){const o=[],a=r+n-1,c=i+s-1,d=U.KnotVector.createUniformWrapped(r,n-1,0,1),h=U.KnotVector.createUniformWrapped(i,s-1,0,1),u=2*Math.PI/r,f=2*Math.PI/i;for(let p=0;p<c;p++){const r=p*f,i=Math.cos(r),n=Math.sin(r);for(let s=0;s<a;s++){const r=s*u,a=Math.cos(r),c=Math.sin(r),d=t+i*e;o.push(l.Point3d.create(d*a,d*c,n*e))}}const g=A.BSplineSurface3d.create(o,a,n,d.knots,c,s,h.knots);return g&&(g.setWrappable(0,U.BSplineWrapMode.OpenByAddingControlPoints),g.setWrappable(1,U.BSplineWrapMode.OpenByAddingControlPoints)),g}static createConeBsplineSurface(t,e,r,n,s){s<2&&(s=2);const o=[],a=s,c=[0,0,.25,.25,.5,.5,.75,.75,1,1],d=[],h=1/(s-1);for(let i=0;i<s;i++)d.push(i*h);const f=l.Point3d.create(),g=l.Vector3d.createStartEnd(t,e),p=u.Matrix3d.createRigidHeadsUp(g,i.AxisOrder.ZXY);let m,y,P;for(let l=0;l<a;l++)P=l*h,t.interpolate(P,e,f),m=y=i.Geometry.interpolate(r,P,n),o.push(Sample.createBsplineArc90SectionToXYZWArrays(f,p,m,y,!1));return A.BSplineSurface3dH.createGrid(o,A.WeightStyle.WeightsSeparateFromCoordinates,3,c,2,d)}static createWeightedXYGridBsplineSurface(t,e,r,n,s=1,o=1,a=1,c=1){const l=Sample.createXYGrid(t,e,1,1),d=[];for(let h=0;h<t;h++)for(let r=0;r<e;r++){const n=i.Geometry.interpolate(s,h/(t-1),o),l=i.Geometry.interpolate(a,h/(t-1),c);d.push(i.Geometry.interpolate(n,r/(e-1),l))}return A.BSplineSurface3dH.create(l,d,t,r,void 0,e,n,void 0)}static createSimpleLinearSweeps(){const t=[],e=_.Loop.create(V.LineString3d.createRectangleXY(l.Point3d.create(),2,3)),r=l.Vector3d.create(0,0,1.234),i=l.Vector3d.create(.1,.21,1.234);t.push(M.LinearSweep.create(e,r,!1)),t.push(M.LinearSweep.create(e,r,!0)),t.push(M.LinearSweep.create(e,i,!1)),t.push(M.LinearSweep.create(e,i,!0)),t.push(M.LinearSweep.create(Sample.createCappedArcLoop(5,-45,90),i,!0));for(const s of Sample.createSmoothCurvePrimitives()){const e=v.Path.create(s);t.push(M.LinearSweep.create(e,r,!1))}const n=[c.Point2d.create(0,0),c.Point2d.create(1,0),c.Point2d.create(1,1)];t.push(M.LinearSweep.createZSweep(n,1,3,!1)),t.push(M.LinearSweep.createZSweep(n,1,3,!0));return n.push(c.Point2d.create(1e-11,1e-11)),t.push(M.LinearSweep.createZSweep(n,1,3,!1)),t.push(M.LinearSweep.createZSweep(n,1,3,!0)),n.pop(),n.push(n[0]),t.push(M.LinearSweep.createZSweep(n,1,3,!1)),t.push(M.LinearSweep.createZSweep(n,1,3,!0)),t.push(M.LinearSweep.createZSweep(n,1,-3,!0)),t}static createCappedArcPrimitives(t,e,r){const i=X.Arc3d.create(l.Point3d.create(0,0,0),l.Vector3d.unitX(t),l.Vector3d.unitY(t),n.AngleSweep.createStartEndDegrees(e,r));return[i,k.LineSegment3d.create(i.fractionToPoint(1),i.fractionToPoint(0))]}static createCappedArcPath(t,e,r){return v.Path.createArray(Sample.createCappedArcPrimitives(t,e,r))}static createCappedArcLoop(t,e,r){return _.Loop.createArray(Sample.createCappedArcPrimitives(t,e,r))}static createSimpleRotationalSweeps(){const t=[],e=_.Loop.create(V.LineString3d.createRectangleXY(l.Point3d.create(1,0,0),2,3));for(const r of[a.Ray3d.createXYZUVW(0,0,0,0,1,0),a.Ray3d.createXYZUVW(5,0,0,0,1,0),a.Ray3d.createXYZUVW(-1,0,0,-1,1,0)])t.push(R.RotationalSweep.create(e,r,s.Angle.createDegrees(45),!1)),t.push(R.RotationalSweep.create(e,r,s.Angle.createDegrees(150),!0));return t}static createSpheres(t=!1){const e=[];e.push(w.Sphere.createCenterRadius(l.Point3d.create(0,0,0),1)),e.push(w.Sphere.createCenterRadius(l.Point3d.create(1,2,3),3));const r=w.Sphere.createCenterRadius(l.Point3d.create(1,2,3),2,n.AngleSweep.createStartEndDegrees(-45,80));r.capped=!0,e.push(r);const i=w.Sphere.createFromAxesAndScales(l.Point3d.create(1,2,3),u.Matrix3d.createRowValues(0,1,0,0,0,1,1,0,0),4,4,4,n.AngleSweep.createStartEndDegrees(-45,45),!0);return e.push(i),t&&e.push(w.Sphere.createDgnSphere(l.Point3d.create(1,2,3),l.Vector3d.unitX(),l.Vector3d.unitZ(),3,2,n.AngleSweep.createFullLatitude(),!1)),e}static createEllipsoids(){return[w.Sphere.createEllipsoid(h.Transform.createOriginAndMatrix(l.Point3d.create(0,0,0),u.Matrix3d.createRowValues(4,1,1,1,4,1,.5,.2,5)),n.AngleSweep.createFullLatitude(),!0)]}static createCones(){const t=[],e=l.Point3d.create(0,0,0),r=l.Point3d.create(0,0,5),i=l.Point3d.create(1,2,1),n=l.Point3d.create(2,3,8);return t.push(b.Cone.createAxisPoints(l.Point3d.create(0,0,0),l.Point3d.create(0,0,1),.5,.5,!1)),t.push(b.Cone.createAxisPoints(i,n,.5,.5,!1)),t.push(b.Cone.createAxisPoints(e,r,1,.2,!0)),t.push(b.Cone.createAxisPoints(i,n,.2,.5,!1)),t.push(b.Cone.createAxisPoints(e,n,1,0,!1)),t.push(b.Cone.createAxisPoints(r,e,0,1,!0)),t}static createTorusPipes(){const t=[],e=l.Point3d.create(1,2,3),r=u.Matrix3d.createRotationAroundVector(l.Vector3d.create(1,2,3),s.Angle.createRadians(10)),i=r.columnX(),n=r.columnY(),o=r.columnZ();return t.push(T.TorusPipe.createInFrame(h.Transform.createIdentity(),5,.8,s.Angle.create360(),!1)),t.push(T.TorusPipe.createInFrame(h.Transform.createIdentity(),5,1,s.Angle.createDegrees(90),!0)),t.push(T.TorusPipe.createDgnTorusPipe(e,i,n,10,1,s.Angle.createDegrees(180),!0)),t.push(T.TorusPipe.createDgnTorusPipe(e,n,o,10,1,s.Angle.createDegrees(45),!0)),t}static createBoxes(t=!0){const e=[],r=l.Point3d.create(1,2,3),i=u.Matrix3d.createRotationAroundVector(l.Vector3d.create(0,0,1),s.Angle.createDegrees(10)),n=i.columnX(),o=i.columnY(),a=u.Matrix3d.xyzPlusMatrixTimesCoordinates(r,i,0,0,5);e.push(I.Box.createDgnBox(r,l.Vector3d.unitX(),l.Vector3d.unitY(),a,3,2,3,2,t)),e.push(I.Box.createDgnBox(r,l.Vector3d.unitX(),l.Vector3d.unitY(),a,3,2,1.5,1,t)),e.push(I.Box.createDgnBox(r,n,o,a,3,2,1.5,1,t));const c=u.Matrix3d.createRotationAroundVector(l.Vector3d.create(0,1,0),s.Angle.createDegrees(10));return e.push(I.Box.createDgnBox(r,c.columnX(),c.columnY(),r.plusScaled(c.columnZ(),5),3,2,1.5,1,t)),e}static createRectangle(t,e,r,i,n=0,s=!1){const o=[l.Point3d.create(t,e,n),l.Point3d.create(r,e,n),l.Point3d.create(r,i,n),l.Point3d.create(t,i,n)];return s&&o.push(l.Point3d.create(t,e,n)),o}static createRectangleInRange2d(t,e=0,r=!1){const i=t.low.x,n=t.high.x,s=t.low.y,o=t.high.y;return this.createRectangle(i,s,n,o,e,r)}static createRuledSweeps(t=!1,e=!1){const r=[],i=_.Loop.create(V.LineString3d.create(this.createRectangleXY(0,0,3,2,0))),n=_.Loop.create(V.LineString3d.create(this.createRectangleXY(0,0,3,2.5,2))),s=_.Loop.create(V.LineString3d.create(this.createRectangleXY(0,0,4,3.5,4))),o=_.Loop.create(V.LineString3d.create(this.createRectangleXY(0,0,2,1,7))),a=[i,n,s];r.push(F.RuledSweep.create([i,n],!0)),r.push(F.RuledSweep.create([i,n,s],!0)),r.push(F.RuledSweep.create([i,n,s,o],!0)),r.push(F.RuledSweep.create(a,!1));const c=Sample.createSmoothCurvePrimitives();for(const l of c){const t=l.fractionToFrenetFrame(0);if(t){const e=t.matrix.columnZ();e.scaleInPlace(10);const i=l.cloneTransformed(h.Transform.createTranslation(e));r.push(F.RuledSweep.create([v.Path.create(l),v.Path.create(i)],!1))}}if(t){const t=_.Loop.create(V.LineString3d.create(this.createRectangleXY(0,0,5,6,0))),e=_.Loop.create(V.LineString3d.create(this.createRectangleXY(1,1,2,3,0))),i=x.ParityRegion.create(t,e),n=i.clone();n.tryTranslateInPlace(0,0,2),r.push(F.RuledSweep.create([i,n],!1))}if(e){const t=P.BagOfCurves.create(k.LineSegment3d.createXYZXYZ(1,1,0,3,1,0)),e=P.BagOfCurves.create(k.LineSegment3d.createXYZXYZ(1,1,1,3,1,1));r.push(F.RuledSweep.create([t,e],!1))}return r}static createGrowableArrayCountedSteps(t,e,r){const i=new O.GrowableFloat64Array(r);for(let n=0;n<r;n++)i.push(t+n*e);return i}static createGrowableArrayCirclePoints(t,e,r=!1,i=0,n=0,s){s||(s=new E.GrowableXYZArray),s.ensureCapacity(e+(r?1:0));const o=2*Math.PI/e;for(let a=0;a<e;a++){const e=a*o;s.push(l.Point3d.create(i+t*Math.cos(e),n+t*Math.sin(e)))}return s}static pushIfDistinct(t,e,r=1e-12){(0===t.length||t[t.length-1].distanceXY(e)>r)&&t.push(e)}static appendToFractalEval(t,e,r,i,n,s){const o=e.clone();Sample.pushIfDistinct(t,e);for(const a of i){const c=e.interpolatePerpendicularXY(a.x,r,s*a.y);n>0&&Sample.appendToFractalEval(t,o,c,i,n-1,s),Sample.pushIfDistinct(t,c),o.setFrom(c)}Sample.pushIfDistinct(t,r)}static createRecursiveFractalPolygon(t,e,r,i){const n=[];Sample.pushIfDistinct(n,t[0]);for(let s=0;s+1<t.length;s++)r>0&&Sample.appendToFractalEval(n,t[s],t[s+1],e,r-1,i),Sample.pushIfDistinct(n,t[s+1]);return n}static nonConvexQuadSimpleFractal(t,e){const r=[c.Point2d.create(),c.Point2d.create(.5,.1),c.Point2d.create(1,0)],i=[l.Point3d.create(0,0,0),l.Point3d.create(.6,.1,0),l.Point3d.create(1,.1,0),l.Point3d.create(.6,1,0),l.Point3d.create()];return Sample.createRecursiveFractalPolygon(i,r,t,e)}static createFractalDiamondConvexPattern(t,e){const r=[c.Point2d.create(),c.Point2d.create(.3,.05),c.Point2d.create(.5,.1),c.Point2d.create(.7,.04),c.Point2d.create(1,0)],i=[l.Point3d.create(0,-1,0),l.Point3d.create(1,0,0),l.Point3d.create(0,1,0),l.Point3d.create(-1,0,0),l.Point3d.create(0,-1,0)];return Sample.createRecursiveFractalPolygon(i,r,t,e)}static createFractalSquareReversingPattern(t,e){const r=[c.Point2d.create(),c.Point2d.create(.25,0),c.Point2d.create(.5,.2),c.Point2d.create(.75,-.1),c.Point2d.create(1,0)],i=[l.Point3d.create(),l.Point3d.create(1,0,0),l.Point3d.create(1,1,0),l.Point3d.create(0,1,0),l.Point3d.create(0,0,0)];return Sample.createRecursiveFractalPolygon(i,r,t,e)}static createFractalHatReversingPattern(t,e){const r=[c.Point2d.create(),c.Point2d.create(.25,0),c.Point2d.create(.25,.1),c.Point2d.create(.5,.1),c.Point2d.create(.5,-.1),c.Point2d.create(.75,-.1),c.Point2d.create(.75,0),c.Point2d.create(1,0)],i=[l.Point3d.create(),l.Point3d.create(1,0,0),l.Point3d.create(1,1,0),l.Point3d.create(0,1,0),l.Point3d.create(0,0,0)];return Sample.createRecursiveFractalPolygon(i,r,t,e)}static createFractalLReversingPattern(t,e){const r=[c.Point2d.create(),c.Point2d.create(.25,0),c.Point2d.create(.5,.2),c.Point2d.create(.75,-.1),c.Point2d.create(1,0)],i=[l.Point3d.create(),l.Point3d.create(1,0,0),l.Point3d.create(1,1,0),l.Point3d.create(2,2,0),l.Point3d.create(2,3,0),l.Point3d.create(0,3,0),l.Point3d.create()];return Sample.createRecursiveFractalPolygon(i,r,t,e)}static createFractalLMildConcavePatter(t,e){const r=[c.Point2d.create(),c.Point2d.create(.25,.05),c.Point2d.create(.5,.15),c.Point2d.create(.75,.05),c.Point2d.create(1,0)],i=[l.Point3d.create(),l.Point3d.create(1,0,0),l.Point3d.create(1,1,0),l.Point3d.create(2,2,0),l.Point3d.create(1.5,3,0),l.Point3d.create(0,3,0),l.Point3d.create()];return Sample.createRecursiveFractalPolygon(i,r,t,e)}static appendSplits(t,e,r,i){const n=t[t.length-1];for(let s=0;s<r;s++)t.push(n.interpolate(s/r,e));i&&t.push(e)}static createTriangleWithSplitEdges(t,e,r,i=!0,n=l.Point3d.create(0,0,0),s=l.Point3d.create(1,0,0),o=l.Point3d.create(0,1,0)){const a=[n.clone()];return Sample.appendSplits(a,s,t,!0),Sample.appendSplits(a,o,e,!0),Sample.appendSplits(a,n,r,i),a}static createCenteredBoxEdges(t=1,e=1,r=0,i=0,n=0,s=0,o){o||(o=[]);const a=i-t,c=n-e,d=s-r,h=i+t,u=n+e,f=s+r;for(const g of[d,f])o.push(V.LineString3d.create(l.Point3d.create(a,c,g),l.Point3d.create(h,c,g),l.Point3d.create(h,u,g),l.Point3d.create(a,u,g),l.Point3d.create(a,c,g)));return o.push(k.LineSegment3d.createXYZXYZ(a,c,d,a,c,f)),o.push(k.LineSegment3d.createXYZXYZ(h,c,d,h,c,f)),o.push(k.LineSegment3d.createXYZXYZ(h,u,d,h,u,f)),o.push(k.LineSegment3d.createXYZXYZ(a,u,d,a,u,f)),o}static createSimpleTransitionSpirals(){const t=100*Y.TransitionSpiral3d.averageCurvatureR0R1(0,1e3);return[Y.TransitionSpiral3d.create("clothoid",0,1e3,s.Angle.createDegrees(0),s.Angle.createRadians(t),void 0,void 0,h.Transform.createIdentity()),Y.TransitionSpiral3d.create("clothoid",0,1e3,s.Angle.createDegrees(0),void 0,100,void 0,h.Transform.createIdentity()),Y.TransitionSpiral3d.create("clothoid",0,1e3,void 0,s.Angle.createRadians(t),100,void 0,h.Transform.createIdentity()),Y.TransitionSpiral3d.create("clothoid",0,void 0,s.Angle.createDegrees(0),s.Angle.createRadians(t),100,void 0,h.Transform.createIdentity()),Y.TransitionSpiral3d.create("clothoid",void 0,1e3,s.Angle.createDegrees(0),s.Angle.createRadians(t),100,void 0,h.Transform.createIdentity()),Y.TransitionSpiral3d.create("clothoid",0,1e3,s.Angle.createDegrees(0),s.Angle.createRadians(t),void 0,d.Segment1d.create(0,.5),h.Transform.createOriginAndMatrix(l.Point3d.create(1,2,0),u.Matrix3d.createRotationAroundVector(l.Vector3d.unitZ(),s.Angle.createDegrees(15))))]}static createTwistingBezier(t,e,r,i,n,s,o){if(void 0!==o){const a=[];for(let c=0;c<t;c++){const l=n.fractionToRadians(c),d=s.fractionToRadians(c),h=o.fractionToPoint(c/(t-1));a.push(m.Point4d.create(h*(e+i*Math.cos(l)),h*(r+i*Math.sin(l)),h*Math.sin(d),h))}return N.BezierCurve3dH.create(a)}{const o=[];for(let a=0;a<t;a++){const t=n.fractionToRadians(a),c=s.fractionToRadians(a);o.push(l.Point3d.create(e+i*Math.cos(t),r+i*Math.sin(t),Math.sin(c)))}return L.BezierCurve3d.create(o)}}static createCurveChainWithDistanceIndex(){const t=[l.Point3d.create(0,0,0),l.Point3d.create(1,3,0),l.Point3d.create(2,4,0),l.Point3d.create(3,3,0),l.Point3d.create(4,0,0)],e=[];return e.push(Z.CurveChainWithDistanceIndex.createCapture(v.Path.create(k.LineSegment3d.create(l.Point3d.create(0,0,0),l.Point3d.create(5,0,0))))),e.push(Z.CurveChainWithDistanceIndex.createCapture(v.Path.create(X.Arc3d.createCircularStartMiddleEnd(l.Point3d.create(0,0,0),l.Point3d.create(3,3,0),l.Point3d.create(6,0,0))))),e.push(Z.CurveChainWithDistanceIndex.createCapture(v.Path.create(V.LineString3d.create(t)))),e.push(Z.CurveChainWithDistanceIndex.createCapture(v.Path.create(C.BSplineCurve3d.createUniformKnots(t,3)))),e.push(Z.CurveChainWithDistanceIndex.createCapture(v.Path.create(C.BSplineCurve3d.createUniformKnots(t,4)))),e.push(Z.CurveChainWithDistanceIndex.createCapture(v.Path.create(k.LineSegment3d.create(t[0],t[1]),X.Arc3d.createCircularStartMiddleEnd(t[1],t[2],t[3]),k.LineSegment3d.create(t[3],t[4])))),e}static createSquareWavePath(t,e,r,i,n,s){const o=e+r,a=v.Path.create(),c=new E.GrowableXYZArray(4*t);let d=0;for(let l=0;l<t;l++){const t=l*o,r=t+e;d=(l+1)*o,c.pushXYZ(t,i,0),c.pushXYZ(r,i,0),c.pushXYZ(r,n,0),c.pushXYZ(d,n,0)}c.pushXYZ(d,i,0);const h=c.length;if(1===s){const t=l.Point3d.create(),e=l.Point3d.create();c.getPoint3dAtUncheckedPointIndex(0,t);for(let r=0;r+1<h;r++)c.getPoint3dAtUncheckedPointIndex(r,e),a.tryAddChild(k.LineSegment3d.create(t,e)),t.setFromPoint3d(e)}else if(2===s)for(let l=0;l+4<h;l+=4){const t=V.LineString3d.create();t.addSteppedPoints(c,l,1,5),a.tryAddChild(t)}else{const t=V.LineString3d.create();t.addSteppedPoints(c,0,1,h),a.tryAddChild(t)}return a}static createArcs(t=1,e=n.AngleSweep.create360()){const r=[],i=l.Point3d.create(0,0,0),o=t,a=l.Vector3d.createPolar(1,s.Angle.createDegrees(35)),c=a.rotate90CCWXY();return c.scaleInPlace(t),r.push(X.Arc3d.create(i,l.Vector3d.create(1,0,0),l.Vector3d.create(0,o,0),e)),r.push(X.Arc3d.create(i,a,c,e)),r}static createManyArcs(t=[]){const e=[],r=n.AngleSweep.createStartEndDegrees(-10,75),i=n.AngleSweep.createStartEndDegrees(160,380);for(const n of[Sample.createArcs(1),Sample.createArcs(.5),Sample.createArcs(1,r),Sample.createArcs(.3,i)])for(const t of n)e.push(t);const s=e.length;for(const n of t)for(let t=0;t<s;t++){const r=e[t];e.push(X.Arc3d.create(r.center,r.vector0,r.vector90.plusScaled(r.vector0,n),r.sweep))}return e}static createRangeEdges(t){if(t.isNull)return;const e=t.corners();return P.BagOfCurves.create(V.LineString3d.create(e[0],e[1],e[3],e[2],e[0]),V.LineString3d.create(e[4],e[5],e[7],e[6],e[4]),k.LineSegment3d.create(e[0],e[4]),k.LineSegment3d.create(e[1],e[5]),k.LineSegment3d.create(e[2],e[6]),k.LineSegment3d.create(e[3],e[7]))}static createClosedSolidSampler(t){const e=[];e.push(I.Box.createRange(f.Range3d.createXYZXYZ(0,0,0,3,2,5),t)),e.push(b.Cone.createAxisPoints(l.Point3d.create(0,0,0),l.Point3d.create(0,0,5),1,1,t)),e.push(w.Sphere.createCenterRadius(l.Point3d.create(0,0,0),1)),e.push(T.TorusPipe.createInFrame(h.Transform.createIdentity(),3,1,s.Angle.create360(),t));const r=X.Arc3d.createXY(l.Point3d.create(6,1,0),1,n.AngleSweep.createStartEndDegrees(-90,0)),i=r.fractionAndDistanceToPointOnTangent(0,-4),o=r.fractionAndDistanceToPointOnTangent(1,2),c=r.fractionAndDistanceToPointOnTangent(1,.5),d=l.Point3d.create(i.x,o.y),u=l.Point3d.create(i.x,o.y),g=V.LineString3d.create(r.fractionToPoint(1),o,d,i),p=V.LineString3d.create(r.fractionToPoint(1),c,u,i),m=v.Path.create(g.clone()),y=_.Loop.create(k.LineSegment3d.create(i,r.fractionToPoint(0)),r.clone(),g.clone()),P=_.Loop.create(k.LineSegment3d.create(i,r.fractionToPoint(0)),r.clone(),p.clone());P.tryTransformInPlace(h.Transform.createTranslationXYZ(1,1,3)),e.push(M.LinearSweep.create(y,l.Vector3d.create(0,0,5),t));const x=a.Ray3d.createXYZUVW(0,8,0,1,0,0);e.push(R.RotationalSweep.create(y.clone(),x.clone(),s.Angle.createDegrees(90),t)),t||e.push(R.RotationalSweep.create(m.clone(),x.clone(),s.Angle.createDegrees(90),!1)),e.push(F.RuledSweep.create([y.clone(),P.clone()],t));const S=h.Transform.createScaleAboutPoint(l.Point3d.create(0,0,8),.5),C=P.cloneTransformed(S);return e.push(F.RuledSweep.create([y.clone(),P.clone(),C.clone()],t)),e}static createRotationalSweepLineSegment3dArc3dLineString3d(t){const e=[],r=X.Arc3d.createXY(l.Point3d.create(6,1,0),1,n.AngleSweep.createStartEndDegrees(-90,0)),i=r.fractionAndDistanceToPointOnTangent(0,-4),o=r.fractionAndDistanceToPointOnTangent(1,2),c=l.Point3d.create(i.x,o.y),d=V.LineString3d.create(r.fractionToPoint(1),o,c,i),h=v.Path.create(d.clone()),u=a.Ray3d.createXYZUVW(0,8,0,1,0,0);return e.push(R.RotationalSweep.create(h.clone(),u.clone(),s.Angle.createDegrees(90),t)),e}static createCutPie(t,e,r,i,n,s,o=!1){const a=[],c=l.Point3d.create(t,e);a.push(c);const d=l.Point3d.create(t+r*Math.cos(i.startRadians),e+r*Math.sin(i.startRadians)),h=l.Point3d.create(t+r*Math.cos(i.endRadians),e+r*Math.sin(i.endRadians));for(let l=1;l<n;l++)a.push(c.interpolate(l/n,d));a.push(d);for(let u=1;u<s;u++){const n=i.fractionToRadians(u/s);a.push(l.Point3d.create(t+r*Math.cos(n),e+r*Math.sin(n)))}a.push(h);for(let l=1;l<n;l++)a.push(h.interpolate(l/n,c));return o&&a.push(c.clone()),a}static creatVerticalStaggerPolygon(t,e,r,i,n,s,o,a){return[l.Point3d.create(0,0),l.Point3d.create(n+o,t),l.Point3d.create(2*n,e),l.Point3d.create(2*n,s+r),l.Point3d.create(n+a,s+i),l.Point3d.create(0,s),l.Point3d.create(0,0)]}static convertPointsToSegments(t,e=!1){const r=[],i=t.length;for(let n=0;n+1<i;n++)r.push(k.LineSegment3d.create(t[n],t[n+1]));return e&&i>1&&!t[0].isAlmostEqual(t[i-1])&&r.push(k.LineSegment3d.create(t[i-1],t[0])),r}static createRegularPolygon(t,e,r,i,n,s,o){const a=[],c=2*Math.PI/s;let d;for(let h=0;h<s;h++)d=i.radians+h*c,a.push(l.Point3d.create(t+n*Math.cos(d),e+n*Math.sin(d),r));return o&&a.push(a[0].clone()),a}static createStar(t,e,r,i,n,s,o,a){const c=[],d=Math.PI/s,h=void 0===a?0:a.radians;let u;for(let f=0;f<s;f++)u=h+2*f*d,c.push(l.Point3d.create(t+i*Math.cos(u),e+i*Math.sin(u),r)),void 0!==n&&(u=h+(2*f+1)*d,c.push(l.Point3d.create(t+n*Math.cos(u),e+n*Math.sin(u),r)));return o&&c.push(c[0].clone()),c}static createStarsInStars(t,e,r,i,n,s,o,a,c){const l=[];if(l.push(this.createStar(0,0,0,t,e,r,c)),a>0){const t=2*Math.PI/a;for(let e=0;e<a;e++){const r=e*t;l.push(this.createStar(o*Math.cos(r),o*Math.sin(r),0,i,n,s,c))}}return l}static appendGeometry(t,e){for(const r of t)e.push(r)}static createAllGeometryQueryTypes(){const t=[],e=l.Point3d.create(0,0,0),r=l.Point3d.create(1,0,0),i=l.Point3d.create(1,1,0),s=l.Point3d.create(0,1,0),o=[e,r,i],a=[e,r,i,s],c=[e,r,i,s,e];return t.push(k.LineSegment3d.create(e,r)),t.push(W.CoordinateXYZ.create(e)),t.push(X.Arc3d.createCircularStartMiddleEnd(e,r,i)),t.push(D.PointString3d.create(e,r)),t.push(Y.TransitionSpiral3d.createRadiusRadiusBearingBearing(d.Segment1d.create(0,100),n.AngleSweep.createStartEndDegrees(0,5),d.Segment1d.create(0,.5),h.Transform.createIdentity())),t.push(V.LineString3d.create(a)),t.push(L.BezierCurve3d.create(o)),t.push(N.BezierCurve3dH.create(o)),t.push(C.BSplineCurve3d.createUniformKnots(o,3)),t.push(j.BSplineCurve3dH.createUniformKnots(o,3)),t.push(_.Loop.create(V.LineString3d.create(c))),t.push(v.Path.create(V.LineString3d.create(a))),t.push(this.createConeBsplineSurface(e,i,1,2,4)),t.push(this.createXYGridBsplineSurface(8,4,4,3)),this.appendGeometry(this.createClosedSolidSampler(!0),t),t.push(this.createTriangularUnitGridPolyface(e,l.Vector3d.unitX(),l.Vector3d.unitY(),4,5)),this.appendGeometry(this.createSimpleParityRegions(),t),this.appendGeometry(this.createSimpleUnions(),t),this.appendGeometry(this.createBagOfCurves(),t),t}}e.Sample=Sample,Sample.point2d=[c.Point2d.create(0,0),c.Point2d.create(1,0),c.Point2d.create(0,1),c.Point2d.create(2,3)],Sample.point3d=[l.Point3d.create(0,0,0),l.Point3d.create(1,0,0),l.Point3d.create(0,1,0),l.Point3d.create(0,1,0),l.Point3d.create(0,0,1),l.Point3d.create(2,3,0),l.Point3d.create(0,2,5),l.Point3d.create(-3,0,5),l.Point3d.create(4,3,-2)],Sample.point4d=[m.Point4d.create(0,0,0,1),m.Point4d.create(1,0,0,1),m.Point4d.create(0,1,0,1),m.Point4d.create(0,1,0,1),m.Point4d.create(0,0,1,1),m.Point4d.create(2,3,0,1),m.Point4d.create(0,2,5,1),m.Point4d.create(-3,0,5,1),m.Point4d.create(-3,0,5,.3),m.Point4d.create(-3,0,5,-.2),m.Point4d.create(4,3,-2,1)],Sample.vector2d=[c.Vector2d.create(1,0),c.Vector2d.create(0,1),c.Vector2d.create(0,0),c.Vector2d.create(-1,0),c.Vector2d.create(0,-1),c.Vector2d.create(0,0),c.Vector2d.createPolar(1,s.Angle.createDegrees(20)),c.Vector2d.createPolar(2,s.Angle.createDegrees(20)),c.Vector2d.create(2,3)],Sample.plane3dByOriginAndUnitNormal=[o.Plane3dByOriginAndUnitNormal.createXYPlane(),o.Plane3dByOriginAndUnitNormal.createYZPlane(),o.Plane3dByOriginAndUnitNormal.createZXPlane(),Sample.createPlane(0,0,0,3,0,1),Sample.createPlane(1,2,3,2,4,-1)],Sample.ray3d=[Sample.createRay(0,0,0,1,0,0),Sample.createRay(0,0,0,0,1,0),Sample.createRay(0,0,0,0,0,1),Sample.createRay(0,0,0,1,2,0),Sample.createRay(1,2,3,4,2,-1)],Sample.angle=[s.Angle.createDegrees(0),s.Angle.createDegrees(90),s.Angle.createDegrees(180),s.Angle.createDegrees(-90),s.Angle.createDegrees(30),s.Angle.createDegrees(-105)],Sample.angleSweep=[n.AngleSweep.createStartEndDegrees(0,90),n.AngleSweep.createStartEndDegrees(0,180),n.AngleSweep.createStartEndDegrees(-90,0),n.AngleSweep.createStartEndDegrees(0,-90),n.AngleSweep.createStartEndDegrees(0,30),n.AngleSweep.createStartEndDegrees(45,110)],Sample.lineSegment3d=[k.LineSegment3d.create(l.Point3d.create(0,0,0),l.Point3d.create(1,0,0)),k.LineSegment3d.create(l.Point3d.create(0,0,0),l.Point3d.create(0,1,0)),k.LineSegment3d.create(l.Point3d.create(0,0,0),l.Point3d.create(0,0,1)),k.LineSegment3d.create(l.Point3d.create(1,2,3),l.Point3d.create(-2,-3,.5))],Sample.range1d=[f.Range1d.createX(1),f.Range1d.createNull(),f.Range1d.createXX(1,2),f.Range1d.createXX(2,1)],Sample.range2d=[f.Range2d.createXY(1,2),f.Range2d.createNull(),f.Range2d.createXYXY(1,2,0,3),f.Range2d.createXYXY(1,2,3,4)],Sample.range3d=[f.Range3d.createXYZ(1,2,3),f.Range3d.createNull(),f.Range3d.createXYZXYZ(1,2,0,3,4,7),f.Range3d.createXYZXYZ(1,2,3,-2,-4,-1)]},"./lib/serialization/IModelJsonSchema.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/AngleSweep.js"),s=r("./lib/geometry3d/Angle.js"),o=r("./lib/geometry3d/Point2dVector2d.js"),a=r("./lib/geometry3d/Point3dVector3d.js"),c=r("./lib/geometry3d/Segment1d.js"),l=r("./lib/geometry3d/YawPitchRollAngles.js"),d=r("./lib/geometry3d/Matrix3d.js"),h=r("./lib/curve/GeometryQuery.js"),u=r("./lib/curve/CoordinateXYZ.js"),f=r("./lib/curve/TransitionSpiral.js"),g=r("./lib/geometry3d/Transform.js"),p=r("./lib/curve/UnionRegion.js"),m=r("./lib/curve/CurveCollection.js"),y=r("./lib/curve/ParityRegion.js"),P=r("./lib/curve/Loop.js"),x=r("./lib/curve/Path.js"),_=r("./lib/polyface/Polyface.js"),v=r("./lib/polyface/AuxData.js"),S=r("./lib/bspline/BSplineCurve.js"),C=r("./lib/bspline/BSplineSurface.js"),A=r("./lib/solid/Sphere.js"),w=r("./lib/solid/Cone.js"),b=r("./lib/solid/Box.js"),I=r("./lib/solid/TorusPipe.js"),T=r("./lib/solid/LinearSweep.js"),M=r("./lib/solid/RotationalSweep.js"),R=r("./lib/solid/RuledSweep.js"),F=r("./lib/geometry3d/Ray3d.js"),k=r("./lib/geometry3d/GeometryHandler.js"),X=r("./lib/curve/LineString3d.js"),Y=r("./lib/curve/PointString3d.js"),V=r("./lib/curve/Arc3d.js"),D=r("./lib/curve/LineSegment3d.js"),z=r("./lib/bspline/BSplineCurve3dH.js"),B=r("./lib/geometry4d/Point4d.js"),O=r("./lib/bspline/KnotVector.js");!function(t){class Reader{constructor(){}static parseVector3dProperty(t,e,r){if(t.hasOwnProperty(e)){const r=t[e];if(i.Geometry.isNumberArray(r,3))return a.Vector3d.create(r[0],r[1],r[2]);if(a.XYZ.isXAndY(r))return a.Vector3d.fromJSON(r)}return r}static parsePoint3dProperty(t,e,r){if(t.hasOwnProperty(e)){const r=t[e];if(i.Geometry.isNumberArray(r,3))return a.Point3d.create(r[0],r[1],r[2]);if(a.XYZ.isXAndY(r))return a.Point3d.fromJSON(r)}return r}static parseSegment1dProperty(t,e,r){if(t.hasOwnProperty(e)){const r=t[e];if(i.Geometry.isNumberArray(r,2))return c.Segment1d.create(r[0],r[1])}return r}static parseNumberProperty(t,e,r){if(t.hasOwnProperty(e)){const r=t[e];if(Number.isFinite(r))return r}return r}static parseAngleProperty(t,e,r){if(t.hasOwnProperty(e)){const r=t[e];return s.Angle.fromJSON(r)}return r}static parseAngleSweepProps(t,e,r){if(t.hasOwnProperty(e)){const r=t[e];return n.AngleSweep.fromJSON(r)}if(void 0!==r)return r()}static parseBooleanProperty(t,e,r){if(t.hasOwnProperty(e)){const r=t[e];if(!0===r)return!0;if(!1===r)return!1}return r}static loadContourArray(t,e){if(t.hasOwnProperty(e)){const r=t[e];if(Array.isArray(r)){const t=[];for(const e of r){const r=Reader.parse(e);r instanceof m.CurveCollection&&t.push(r)}if(t.length>0)return t}}}static parseYawPitchRollAnglesToMatrix3d(t){return l.YawPitchRollAngles.fromJSON(t).toMatrix3d()}static parseStringProperty(t,e,r){if(t.hasOwnProperty(e)){const r=t[e];if("string"===r.type)return r}return r}static parseAxesFromVectors(t,e,r){if(Array.isArray(t)&&2===t.length){const r=a.Vector3d.fromJSON(t[0]),i=a.Vector3d.fromJSON(t[1]),n=d.Matrix3d.createRigidFromColumns(r,i,e);if(n)return n}if(r)return d.Matrix3d.createIdentity()}static parseOrientation(t,e){return t.yawPitchRollAngles?Reader.parseYawPitchRollAnglesToMatrix3d(t.yawPitchRollAngles):t.xyVectors?Reader.parseAxesFromVectors(t.xyVectors,i.AxisOrder.XYZ,e):t.zxVectors?Reader.parseAxesFromVectors(t.zxVectors,i.AxisOrder.ZXY,e):e?d.Matrix3d.createIdentity():void 0}static parseArcByVectorProps(t){if(t&&void 0!==t.center&&void 0!==t.vectorX&&void 0!==t.vectorY&&void 0!==t.sweepStartEnd)return V.Arc3d.create(a.Point3d.fromJSON(t.center),a.Vector3d.fromJSON(t.vectorX),a.Vector3d.fromJSON(t.vectorY),n.AngleSweep.fromJSON(t.sweepStartEnd))}static parseArcBy3Points(t){if(Array.isArray(t)&&t.length>2){const e=a.Point3d.fromJSON(t[0]),r=a.Point3d.fromJSON(t[1]),i=a.Point3d.fromJSON(t[2]);return V.Arc3d.createCircularStartMiddleEnd(e,r,i)}}static parseArcObject(t){let e=Reader.parseArcByVectorProps(t);return e||(e=Reader.parseArcBy3Points(t))}static parseCoordinate(t){const e=a.Point3d.fromJSON(t);if(e)return u.CoordinateXYZ.create(e)}static parseTransitionSpiral(t){const e=Reader.parseOrientation(t,!0),r=Reader.parsePoint3dProperty(t,"origin"),i=Reader.parseAngleProperty(t,"startBearing"),n=Reader.parseAngleProperty(t,"endBearing"),s=Reader.parseNumberProperty(t,"startRadius"),o=Reader.parseNumberProperty(t,"endRadius"),a=Reader.parseNumberProperty(t,"curveLength",void 0),c=Reader.parseSegment1dProperty(t,"fractionInterval",void 0),l=Reader.parseStringProperty(t,"spiralType","clothoid");if(r)return f.TransitionSpiral3d.create(l,s,o,i,n,a,c,g.Transform.createOriginAndMatrix(r,e))}static getCorrectedKnotsForClosedClamped(t,e,r,i){const n=e.length;if(t+2*r-1===n&&e[0]<e[1]&&e[n-2]<e[n-1]){const t=e[1],s=e[n-2];for(let i=2;i<=r;i++){if(e[i]!==t)return!1;if(e[n-1-i]!==s)return!1}for(let r=2;r+2<n;r++)i.push(e[r]);return!0}return!1}static parseBcurve(t){if(void 0!==t&&Array.isArray(t.points)&&Array.isArray(t.knots)&&Number.isFinite(t.order)&&void 0!==t.closed)if(4===t.points[0].length){const e=[];for(const s of t.points)e.push(B.Point4d.fromJSON(s));const r=[];let i=O.BSplineWrapMode.None;if(t.closed&&this.getCorrectedKnotsForClosedClamped(t.points.length,t.knots,t.order,r))i=O.BSplineWrapMode.OpenByRemovingKnots;else if(t.closed){for(const e of t.knots)r.push(e);for(let r=0;r+1<t.order;r++)e.push(e[r].clone());i=O.BSplineWrapMode.OpenByAddingControlPoints}else for(const s of t.knots)r.push(s);const n=z.BSplineCurve3dH.create(e,r,t.order);if(n)return!0===t.closed&&n.setWrappable(i),n}else if(3===t.points[0].length||2===t.points[0].length){const e=[];for(const s of t.points)e.push(a.Point3d.fromJSON(s));const r=[];let i=O.BSplineWrapMode.None;if(t.closed&&this.getCorrectedKnotsForClosedClamped(t.points.length,t.knots,t.order,r))i=O.BSplineWrapMode.OpenByRemovingKnots;else if(t.closed){for(const e of t.knots)r.push(e);for(let r=0;r+1<t.order;r++)e.push(e[r].clone());i=O.BSplineWrapMode.OpenByAddingControlPoints}else for(const s of t.knots)r.push(s);const n=S.BSplineCurve3d.create(e,r,t.order);if(n)return!0===t.closed&&n.setWrappable(i),n}}static parseArray(t){if(Array.isArray(t)){const e=[];let r;for(r of t){const t=Reader.parse(r);void 0!==t&&e.push(t)}return e}}static addZeroBasedIndicesFromSignedOneBased(t,e){if(t&&i.Geometry.isNumberArray(t))for(const r of t)0!==r&&e(Math.abs(r)-1)}static parsePolyfaceAuxData(t){if(!Array.isArray(t.channels)||!Array.isArray(t.indices))return;const e=[];for(const i of t.channels)if(Array.isArray(i.data)&&i.hasOwnProperty("dataType")){const t=[];for(const e of i.data)e.hasOwnProperty("input")&&Array.isArray(e.values)&&t.push(new v.AuxChannelData(e.input,e.values));e.push(new v.AuxChannel(t,i.dataType,i.name,i.inputName))}const r=new v.PolyfaceAuxData(e,[]);return Reader.addZeroBasedIndicesFromSignedOneBased(t.indices,t=>{r.indices.push(t)}),r}static parseIndexedMesh(t){if(t.hasOwnProperty("point")&&Array.isArray(t.point)&&t.hasOwnProperty("pointIndex")&&Array.isArray(t.pointIndex)){const e=_.IndexedPolyface.create();if(t.hasOwnProperty("normal")&&Array.isArray(t.normal))for(const r of t.normal)i.Geometry.isNumberArray(r,3)&&e.addNormal(a.Vector3d.create(r[0],r[1],r[2]));if(t.hasOwnProperty("param")&&Array.isArray(t.param))for(const r of t.param)i.Geometry.isNumberArray(r,2)&&e.addParam(o.Point2d.create(r[0],r[1]));if(t.hasOwnProperty("color")&&Array.isArray(t.color))for(const r of t.color)e.addColor(r);for(const r of t.point)e.addPoint(a.Point3d.fromJSON(r));for(const r of t.pointIndex)if(0===r)e.terminateFacet(!1);else{const t=Math.abs(r)-1;e.addPointIndex(t,r>0)}return t.hasOwnProperty("normalIndex")&&Reader.addZeroBasedIndicesFromSignedOneBased(t.normalIndex,t=>{e.addNormalIndex(t)}),t.hasOwnProperty("paramIndex")&&Reader.addZeroBasedIndicesFromSignedOneBased(t.paramIndex,t=>{e.addParamIndex(t)}),t.hasOwnProperty("colorIndex")&&Reader.addZeroBasedIndicesFromSignedOneBased(t.colorIndex,t=>{e.addColorIndex(t)}),t.hasOwnProperty("auxData")&&(e.data.auxData=Reader.parsePolyfaceAuxData(t.auxData)),e}}static parseCurveCollectionMembers(t,e){if(e&&Array.isArray(e)){for(const r of e){const e=Reader.parse(r);e instanceof h.GeometryQuery&&("curveCollection"===e.geometryCategory||"curvePrimitive"===e.geometryCategory)&&t.tryAddChild(e)}return t}}static parseBsurf(t){if(t.hasOwnProperty("uKnots")&&Array.isArray(t.uKnots)&&t.hasOwnProperty("vKnots")&&Array.isArray(t.vKnots)&&t.hasOwnProperty("orderU")&&Number.isFinite(t.orderU)&&t.hasOwnProperty("orderV")&&Number.isFinite(t.orderV)&&t.hasOwnProperty("points")&&Array.isArray(t.points)){const e=t.orderU,r=t.orderV;if(Array.isArray(t.points[0])&&Array.isArray(t.points[0][0])){const i=t.points[0][0].length;if(3===i)return C.BSplineSurface3d.createGrid(t.points,e,t.uKnots,r,t.vKnots);if(4===i)return C.BSplineSurface3dH.createGrid(t.points,C.WeightStyle.WeightsAlreadyAppliedToCoordinates,e,t.uKnots,r,t.vKnots)}}}static parseConeProps(t){const e=Reader.parseOrientation(t,!1),r=Reader.parsePoint3dProperty(t,"start"),n=Reader.parsePoint3dProperty(t,"end"),s=Reader.parseNumberProperty(t,"startRadius"),o=Reader.parseNumberProperty(t,"endRadius",s),c=Reader.parseBooleanProperty(t,"capped",!1);if(r&&n&&void 0!==s&&void 0!==o){if(void 0===e){const t=a.Vector3d.createStartEnd(r,n),e=d.Matrix3d.createRigidHeadsUp(t,i.AxisOrder.ZXY),l=e.columnX(),h=e.columnY();return w.Cone.createBaseAndTarget(r,n,l,h,s,o,c)}return w.Cone.createBaseAndTarget(r,n,e.columnX(),e.columnY(),s,o,c)}}static parseCylinderProps(t){const e=Reader.parsePoint3dProperty(t,"start"),r=Reader.parsePoint3dProperty(t,"end"),i=Reader.parseNumberProperty(t,"radius"),n=Reader.parseBooleanProperty(t,"capped",!1);if(e&&r&&void 0!==i)return w.Cone.createAxisPoints(e,r,i,i,n)}static parseLineSegmentProps(t){return Array.isArray(t)&&t.length>1?D.LineSegment3d.create(a.Point3d.fromJSON(t[0]),a.Point3d.fromJSON(t[1])):void 0}static parseLinearSweep(t){const e=Reader.parse(t.contour),r=Reader.parseBooleanProperty(t,"capped"),i=Reader.parseVector3dProperty(t,"vector");if(e instanceof h.GeometryQuery&&"curveCollection"===e.geometryCategory&&void 0!==r&&i)return T.LinearSweep.create(e,i,r)}static parseRotationalSweep(t){if(void 0===t)return;const e=Reader.parse(t.contour),r=Reader.parseBooleanProperty(t,"capped"),i=Reader.parseVector3dProperty(t,"axis"),n=Reader.parsePoint3dProperty(t,"center"),o=Reader.parseNumberProperty(t,"sweepAngle");return e instanceof h.GeometryQuery&&"curveCollection"===e.geometryCategory&&void 0!==o&&void 0!==r&&i&&n?M.RotationalSweep.create(e,F.Ray3d.createCapture(n,i),s.Angle.createDegrees(o),r):void 0}static parseBox(t){const e=Reader.parseBooleanProperty(t,"capped",!1),r=Reader.parsePoint3dProperty(t,"baseOrigin"),i=Reader.parseNumberProperty(t,"baseX"),n=Reader.parseNumberProperty(t,"baseY",i);let s=Reader.parsePoint3dProperty(t,"topOrigin");const o=Reader.parseNumberProperty(t,"topX",i),c=Reader.parseNumberProperty(t,"topY",n),l=Reader.parseNumberProperty(t,"height",i),h=Reader.parseOrientation(t,!0);if(r&&!s&&(s=d.Matrix3d.xyzMinusMatrixTimesXYZ(r,h,a.Vector3d.create(0,0,l))),void 0!==e&&void 0!==i&&void 0!==n&&void 0!==c&&void 0!==o&&h&&r&&s)return b.Box.createDgnBoxWithAxes(r,h,s,i,n,o,c,e)}static parseSphere(t){const e=Reader.parsePoint3dProperty(t,"center"),r=Reader.parseNumberProperty(t,"radius"),i=Reader.parseNumberProperty(t,"radiusX",r),n=Reader.parseNumberProperty(t,"radiusX",i),s=Reader.parseNumberProperty(t,"radiusX",i),o=Reader.parseAngleSweepProps(t,"latitudeStartEnd"),a=Reader.parseOrientation(t,!0),c=Reader.parseBooleanProperty(t,"capped",!1);if(void 0!==e&&void 0!==i&&void 0!==n&&void 0!==s&&void 0!==c)return A.Sphere.createFromAxesAndScales(e,a,i,n,s,o,c)}static parseRuledSweep(t){const e=Reader.parseBooleanProperty(t,"capped",!1),r=this.loadContourArray(t,"contour");if(void 0!==r&&void 0!==e)return R.RuledSweep.create(r,e)}static parseTorusPipe(t){const e=Reader.parseOrientation(t,!0),r=Reader.parsePoint3dProperty(t,"center"),i=Reader.parseNumberProperty(t,"majorRadius"),n=Reader.parseNumberProperty(t,"minorRadius"),o=Reader.parseAngleProperty(t,"sweepAngle",void 0),a=Reader.parseBooleanProperty(t,"capped",!1);if(r&&void 0!==i&&void 0!==n)return I.TorusPipe.createDgnTorusPipe(r,e.columnX(),e.columnY(),i,n,o||s.Angle.createDegrees(360),a)}static parsePointArray(t){const e=[];if(t&&Array.isArray(t))for(const r of t)a.XYZ.isXAndY(r)?e.push(a.Point3d.fromJSON(r)):i.Geometry.isNumberArray(r,2)&&e.push(a.Point3d.fromJSON(r));return e}static parse(t){if(void 0!==t&&t){if(void 0!==t.lineSegment)return Reader.parseLineSegmentProps(t.lineSegment);if(void 0!==t.lineString)return X.LineString3d.create(Reader.parsePointArray(t.lineString));if(void 0!==t.arc)return Reader.parseArcObject(t.arc);if(t.hasOwnProperty("point"))return Reader.parseCoordinate(t.point);if(t.hasOwnProperty("bcurve"))return Reader.parseBcurve(t.bcurve);if(t.hasOwnProperty("path"))return Reader.parseCurveCollectionMembers(new x.Path,t.path);if(t.hasOwnProperty("loop"))return Reader.parseCurveCollectionMembers(new P.Loop,t.loop);if(t.hasOwnProperty("parityRegion"))return Reader.parseCurveCollectionMembers(new y.ParityRegion,t.parityRegion);if(t.hasOwnProperty("unionRegion"))return Reader.parseCurveCollectionMembers(new p.UnionRegion,t.unionRegion);if(t.hasOwnProperty("bagOfCurves"))return Reader.parseCurveCollectionMembers(new m.BagOfCurves,t.bagOfCurves);if(t.hasOwnProperty("indexedMesh"))return Reader.parseIndexedMesh(t.indexedMesh);if(t.hasOwnProperty("bsurf"))return Reader.parseBsurf(t.bsurf);if(t.hasOwnProperty("cone"))return Reader.parseConeProps(t.cone);if(t.hasOwnProperty("cylinder"))return Reader.parseCylinderProps(t.cylinder);if(t.hasOwnProperty("sphere"))return Reader.parseSphere(t.sphere);if(t.hasOwnProperty("linearSweep"))return Reader.parseLinearSweep(t.linearSweep);if(t.hasOwnProperty("box"))return Reader.parseBox(t.box);if(t.hasOwnProperty("rotationalSweep"))return Reader.parseRotationalSweep(t.rotationalSweep);if(t.hasOwnProperty("ruledSweep"))return Reader.parseRuledSweep(t.ruledSweep);if(t.hasOwnProperty("torusPipe"))return Reader.parseTorusPipe(t.torusPipe);if(t.hasOwnProperty("pointString"))return Y.PointString3d.create(Reader.parsePointArray(t.pointString));if(t.hasOwnProperty("transitionSpiral"))return Reader.parseTransitionSpiral(t.transitionSpiral);if(Array.isArray(t))return Reader.parseArray(t)}}}t.Reader=Reader;class Writer extends k.GeometryHandler{handleLineSegment3d(t){return{lineSegment:[t.point0Ref.toJSON(),t.point1Ref.toJSON()]}}handleCoordinateXYZ(t){return{point:t.point.toJSON()}}handleArc3d(t){return{arc:{center:t.center.toJSON(),vectorX:t.vector0.toJSON(),vectorY:t.vector90.toJSON(),sweepStartEnd:[t.sweep.startDegrees,t.sweep.endDegrees]}}}static insertOrientationFromMatrix(t,e,r){if(r){if(void 0===e)return;if(e.isIdentity)return}t.xyVectors=e?[e.columnX().toJSON(),e.columnY().toJSON()]:[[1,0,0],[0,1,0]]}static isIdentityXY(t,e){return t.isAlmostEqualXYZ(1,0,0)&&e.isAlmostEqualXYZ(0,1,0)}static insertOrientationFromXYVectors(t,e,r,i){i&&Writer.isIdentityXY(e,r)||(t.xyVectors=[e.toJSON(),r.toJSON()])}static insertXYOrientation(t,e,r,i){i&&e.isAlmostEqualXYZ(1,0,0)&&r.isAlmostEqualXYZ(0,1,0)||(t.xyVectors=[e.toJSON(),r.toJSON()])}handleTransitionSpiral(t){const e=t.originalProperties,r={origin:t.localToWorld.origin.toJSON(),type:t.getSpiralType()};return Writer.insertOrientationFromMatrix(r,t.localToWorld.matrix,!0),t.activeFractionInterval.isExact01||(r.fractionInterval=[t.activeFractionInterval.x0,t.activeFractionInterval.x1]),void 0!==e&&4===e.numDefinedProperties()?(void 0!==e.radius0&&(r.startRadius=t.radius01.x0),void 0!==e.radius1&&(r.endRadius=t.radius01.x1),void 0!==e.bearing0&&(r.startBearing=t.bearing01.startAngle.toJSON()),void 0!==e.bearing1&&(r.endBearing=t.bearing01.endAngle.toJSON()),void 0!==e.curveLength&&(r.curveLength=t.curveLength())):(r.startRadius=t.radius01.x0,r.endRadius=t.radius01.x1,r.startBearing=t.bearing01.startAngle.toJSON(),r.endBearing=t.bearing01.endAngle.toJSON(),r.curveLength=t.curveLength()),{transitionSpiral:r}}handleCone(t){const e=t.getRadiusA(),r=t.getRadiusB(),n=t.getCenterA(),s=t.getCenterB(),o=t.getVectorX(),c=t.getVectorY(),l=a.Vector3d.createStartEnd(n,s);if(i.Geometry.isSameCoordinate(e,r)&&o.isPerpendicularTo(l)&&c.isPerpendicularTo(l)&&i.Geometry.isSameCoordinate(o.magnitude(),1)&&i.Geometry.isSameCoordinate(c.magnitude(),1))return{cylinder:{capped:t.capped,start:t.getCenterA().toJSON(),end:t.getCenterB().toJSON(),radius:e}};{const e={capped:t.capped,start:t.getCenterA().toJSON(),end:t.getCenterB().toJSON(),startRadius:t.getRadiusA(),endRadius:t.getRadiusB()};return Writer.insertOrientationFromXYVectors(e,o,c,!1),{cone:e}}}handleSphere(t){const e=t.cloneVectorX().normalizeWithLength(),r=t.cloneVectorY().normalizeWithLength(),n=t.cloneVectorZ().normalizeWithLength(),s=t.cloneLatitudeSweep(),o=e.mag,a=r.mag,c=n.mag;if(e.v&&n.v){const r={center:t.cloneCenter().toJSON()};t.getConstructiveFrame().matrix.isIdentity||(r.zxVectors=[n.v.toJSON(),e.v.toJSON()]);const l=s.isFullLatitudeSweep;return t.capped&&!l&&(r.capped=t.capped),i.Geometry.isSameCoordinate(o,a)&&i.Geometry.isSameCoordinate(o,c)?r.radius=o:(r.radiusX=o,r.radiusY=a,r.radiusZ=c),l||(r.latitudeStartEnd=s.toJSON()),{sphere:r}}}handleTorusPipe(t){const e=t.cloneVectorX(),r=t.cloneVectorY(),i=t.getMajorRadius(),n=t.getMinorRadius(),s=t.getSweepAngle();t.getIsReversed()&&(r.scaleInPlace(-1),s.setRadians(-s.radians));const o={center:t.cloneCenter().toJSON(),majorRadius:i,minorRadius:n,xyVectors:[e.toJSON(),r.toJSON()]};return s.isFullCircle||(o.sweepAngle=s.degrees,o.capped=t.capped),{torusPipe:o}}handleLineString3d(t){const e=t.points,r=[];if(e)for(const i of e)r.push(i.toJSON());return{lineString:r}}handlePointString3d(t){const e=t.points,r=[];if(e)for(const i of e)r.push(i.toJSON());return{pointString:r}}handlePath(t){return{path:this.collectChildren(t)}}handleLoop(t){return{loop:this.collectChildren(t)}}handleParityRegion(t){return{parityRegion:this.collectChildren(t)}}handleUnionRegion(t){return{unionRegion:this.collectChildren(t)}}handleBagOfCurves(t){return{bagOfCurves:this.collectChildren(t)}}collectChildren(t){const e=[];if(t.children&&Array.isArray(t.children))for(const r of t.children){const t=r.dispatchToGeometryHandler(this);t&&e.push(t)}return e}handleLinearSweep(t){const e=t.cloneSweepVector(),r=t.getCurvesRef(),i=t.capped;if(e&&r&&void 0!==i)return{linearSweep:{contour:r.dispatchToGeometryHandler(this),capped:i,vector:e.toJSON()}}}handleRuledSweep(t){const e=t.cloneContours(),r=t.capped;if(e&&e.length>1&&void 0!==r){const t=[];for(const r of e)t.push(this.emit(r));return{ruledSweep:{contour:t,capped:r}}}}handleRotationalSweep(t){const e=t.cloneAxisRay(),r=t.getCurves(),i=t.capped,n=t.getSweep();return{rotationalSweep:{axis:e.direction.toJSON(),contour:r.dispatchToGeometryHandler(this),capped:i,center:e.origin.toJSON(),sweepAngle:n.degrees}}}handleBox(t){const e={box:{baseOrigin:t.getBaseOrigin().toJSON(),baseX:t.getBaseX(),baseY:t.getBaseY(),capped:t.capped,topOrigin:t.getTopOrigin().toJSON()}};return Writer.insertXYOrientation(e.box,t.getVectorX(),t.getVectorY(),!0),i.Geometry.isSameCoordinate(t.getTopX(),t.getBaseX())||(e.box.topX=t.getTopX()),i.Geometry.isSameCoordinate(t.getTopY(),t.getBaseY())||(e.box.topY=t.getTopY()),e}handlePolyfaceAuxData(t,e){const r={indices:[]},i=e.createVisitor(0);if(i.auxData){for(;i.moveToNextFacet();){for(let t=0;t<i.indexCount;t++)r.indices.push(i.auxData.indices[t]+1);r.indices.push(0)}r.channels=[];for(const e of t.channels){const t={};t.dataType=e.dataType,t.name=e.name,t.inputName=e.inputName,t.data=[];for(const r of e.data){const e={};e.input=r.input,e.values=r.values.slice(0),t.data.push(e)}r.channels.push(t)}return r}}handleIndexedPolyface(t){const e=[],r=[],i=[],n=[],s=[];{const r=a.Point3d.create();for(let i=0;t.data.point.getPoint3dAtCheckedPointIndex(i,r);i++)e.push(r.toJSON())}if(t.data.normal){const e=t.data.normal.length,r=a.Vector3d.create();for(let n=0;n<e;n++)t.data.normal.getVector3dAtCheckedVectorIndex(n,r),i.push(r.toJSON())}if(t.data.param){const e=o.Point2d.create();for(let r=0;t.data.param.getPoint2dAtCheckedPointIndex(r,e);r++)n.push(e.toJSON())}if(t.data.color)for(const o of t.data.color)s.push(o);const c=t.createVisitor(0);let l=0;const d=[],h=[],u=[];let f;for(;c.moveToNextFacet();){f=c.indexCount;for(let e=0;e<f;e++){const i=t.data.edgeVisible[l+e]?c.pointIndex[e]+1:-(c.clientPointIndex(e)+1);r.push(i)}if(r.push(0),l+=c.indexCount,c.normalIndex){for(let t=0;t<f;t++)d.push(1+c.clientNormalIndex(t));d.push(0)}if(c.paramIndex){for(let t=0;t<f;t++)h.push(1+c.clientParamIndex(t));h.push(0)}if(c.colorIndex){for(let t=0;t<f;t++)u.push(1+c.clientColorIndex(t));u.push(0)}}const g={};return t.twoSided&&(g.twoSided=!0),t.data.auxData&&(g.auxData=this.handlePolyfaceAuxData(t.data.auxData,t)),t.data.color&&(g.color=s),t.data.colorIndex&&(g.colorIndex=u),t.data.normal&&(g.normal=i),t.data.normalIndex&&(g.normalIndex=d),t.data.param&&(g.param=n),t.data.paramIndex&&(g.paramIndex=h),g.point=e,g.pointIndex=r,{indexedMesh:g}}handleBSplineCurve3d(t){if(t.isClosable===O.BSplineWrapMode.OpenByAddingControlPoints){const e=t.copyKnots(!0),r=t.copyPoints(),i=t.degree;for(let t=0;t<i;t++)r.pop();const n=i,s=e.length-i-1,o=e[s]-e[n];return e[0]=e[s-i]-o,e[e.length-1]=e[n+i]+o,{bcurve:{points:r,knots:e,closed:!0,order:t.order}}}if(t.isClosable===O.BSplineWrapMode.OpenByRemovingKnots){const e=t.copyKnots(!1),r=t.copyPoints(),i=t.degree,n=i-1,s=e.length-i,o=e[n],a=e[s],c=a-o,l=[];l.push(e[s-1]-c),l.push(o);for(const t of e)l.push(t);return l.push(a),l.push(e[n+1]+c),{bcurve:{points:r,knots:l,closed:!0,order:t.order}}}return{bcurve:{points:t.copyPoints(),knots:t.copyKnots(!0),closed:!1,order:t.order}}}handleBezierCurve3d(t){const e=[],r=t.order;for(let i=0;i<r;i++)e.push(0);for(let i=0;i<r;i++)e.push(1);return{bcurve:{points:t.copyPolesAsJsonArray(),knots:e,closed:!1,order:t.order}}}handleBSplineCurve3dH(t){if(t.isClosable){const e=t.copyKnots(!0),r=t.copyPoints(),i=t.degree;for(let t=0;t<i;t++)r.pop();const n=i,s=e.length-i-1,o=e[s]-e[n];return e[0]=e[s-i]-o,e[e.length-1]=e[n+i]+o,{bcurve:{points:r,knots:e,closed:!0,order:t.order}}}return{bcurve:{points:t.copyPoints(),knots:t.copyKnots(!0),closed:!1,order:t.order}}}handleBSplineSurface3d(t){const e=t.isClosable(0),r=t.isClosable(1);if(e||r){let i=t.numPolesUV(0),n=t.numPolesUV(1);e&&(i-=t.degreeUV(0)),r&&(n-=t.degreeUV(1));const s=a.Point3d.create(),o=[];for(let e=0;e<n;e++){const r=[];for(let n=0;n<i;n++)t.getPoint3dPole(n,e,s),r.push([s.x,s.y,s.z]);o.push(r)}return{bsurf:{points:o,uKnots:t.copyKnots(0,!0),vKnots:t.copyKnots(1,!0),orderU:t.orderUV(0),orderV:t.orderUV(1),closedU:e,closedV:r}}}return{bsurf:{points:t.getPointArray(!1),uKnots:t.copyKnots(0,!0),vKnots:t.copyKnots(1,!0),orderU:t.orderUV(0),orderV:t.orderUV(1)}}}handleBezierCurve3dH(t){const e=[],r=t.order;for(let i=0;i<r;i++)e.push(0);for(let i=0;i<r;i++)e.push(1);return{bcurve:{points:t.copyPolesAsJsonArray(),knots:e,closed:!1,order:t.order}}}handleBSplineSurface3dH(t){return{bsurf:{points:t.getPointGridJSON().points,uKnots:t.copyKnots(0,!0),vKnots:t.copyKnots(1,!0),orderU:t.orderUV(0),orderV:t.orderUV(1)}}}emitArray(t){const e=[];for(const r of t){const t=this.emit(r);e.push(t)}return e}emit(t){return Array.isArray(t)?this.emitArray(t):t instanceof h.GeometryQuery?t.dispatchToGeometryHandler(this):void 0}static toIModelJson(t){return(new Writer).emit(t)}}t.Writer=Writer}(e.IModelJson||(e.IModelJson={}))},"./lib/solid/Box.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Transform.js"),s=r("./lib/solid/SolidPrimitive.js"),o=r("./lib/Geometry.js"),a=r("./lib/curve/Loop.js"),c=r("./lib/curve/LineString3d.js");class Box extends s.SolidPrimitive{constructor(t,e,r,i,n,s){super(s),this.solidPrimitiveType="box",this._localToWorld=t,this._baseX=e,this._baseY=r,this._topX=i,this._topY=n}clone(){return new Box(this._localToWorld.clone(),this._baseX,this._baseY,this._topX,this._topY,this.capped)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return t.multiplyTransformTransform(e._localToWorld,e._localToWorld),e}static createDgnBox(t,e,r,i,s,o,a,c,l){const d=t.vectorTo(i),h=n.Transform.createOriginAndMatrixColumns(t,e,r,d);return new Box(h,s,o,a,c,l)}static createDgnBoxWithAxes(t,e,r,i,n,s,o,a){return Box.createDgnBox(t,e.columnX(),e.columnY(),r,i,n,s,o,a)}static createRange(t,e){if(!t.isNull){const r=t.low,n=t.xLength(),s=t.yLength(),o=t.low.clone();return o.z=o.z+t.zLength(),Box.createDgnBox(r,i.Vector3d.unitX(),i.Vector3d.unitY(),o,n,s,n,s,e)}}getBaseX(){return this._baseX}getBaseY(){return this._baseY}getTopX(){return this._topX}getTopY(){return this._topY}getBaseOrigin(){return this._localToWorld.multiplyXYZ(0,0,0)}getTopOrigin(){return this._localToWorld.multiplyXYZ(0,0,1)}getVectorX(){return this._localToWorld.matrix.columnX()}getVectorY(){return this._localToWorld.matrix.columnY()}getVectorZ(){return this._localToWorld.matrix.columnZ()}isSameGeometryClass(t){return t instanceof Box}isAlmostEqual(t){return t instanceof Box&&(this.capped===t.capped&&(!!this._localToWorld.isAlmostEqual(t._localToWorld)&&(o.Geometry.isSameCoordinate(this._baseX,t._baseX)&&o.Geometry.isSameCoordinate(this._baseY,t._baseY)&&o.Geometry.isSameCoordinate(this._topX,t._topX)&&o.Geometry.isSameCoordinate(this._topY,t._topY))))}dispatchToGeometryHandler(t){return t.handleBox(this)}strokeConstantVSection(t){const e=o.Geometry.interpolate(this._baseX,t,this._topX),r=o.Geometry.interpolate(this._baseY,t,this._topY),n=c.LineString3d.create(),s=this._localToWorld,a=i.Point3d.create();return s.multiplyXYZ(0,0,t,a),n.addPoint(a),s.multiplyXYZ(e,0,t,a),n.addPoint(a),s.multiplyXYZ(e,r,t,a),n.addPoint(a),s.multiplyXYZ(0,r,t,a),n.addPoint(a),s.multiplyXYZ(0,0,t,a),n.addPoint(a),n}getCorners(){const t=this._localToWorld,e=this._baseX,r=this._baseY,i=this._topX,n=this._topY;return[t.multiplyXYZ(0,0,0),t.multiplyXYZ(e,0,0),t.multiplyXYZ(0,r,0),t.multiplyXYZ(e,r,0),t.multiplyXYZ(0,0,1),t.multiplyXYZ(i,0,1),t.multiplyXYZ(0,n,1),t.multiplyXYZ(i,n,1)]}constantVSection(t){const e=this.strokeConstantVSection(t);return a.Loop.create(e)}extendRange(t,e){const r=this._localToWorld,i=this._baseX,n=this._baseY,s=this._topX,o=this._topY;e?(t.extendTransformTransformedXYZ(e,r,0,0,0),t.extendTransformTransformedXYZ(e,r,i,0,0),t.extendTransformTransformedXYZ(e,r,0,n,0),t.extendTransformTransformedXYZ(e,r,i,n,0),t.extendTransformTransformedXYZ(e,r,0,0,1),t.extendTransformTransformedXYZ(e,r,s,0,1),t.extendTransformTransformedXYZ(e,r,0,o,1),t.extendTransformTransformedXYZ(e,r,s,o,1)):(t.extendTransformedXYZ(r,0,0,0),t.extendTransformedXYZ(r,i,0,0),t.extendTransformedXYZ(r,0,n,0),t.extendTransformedXYZ(r,i,n,0),t.extendTransformedXYZ(r,0,0,1),t.extendTransformedXYZ(r,s,0,1),t.extendTransformedXYZ(r,0,o,1),t.extendTransformedXYZ(r,s,o,1))}get isClosedVolume(){return this.capped}}e.Box=Box},"./lib/solid/Cone.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Transform.js"),s=r("./lib/geometry3d/Matrix3d.js"),o=r("./lib/Geometry.js"),a=r("./lib/solid/SolidPrimitive.js"),c=r("./lib/curve/Loop.js"),l=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),d=r("./lib/curve/Arc3d.js"),h=r("./lib/curve/LineString3d.js"),u=r("./lib/geometry3d/Point2dVector2d.js");class Cone extends a.SolidPrimitive{constructor(t,e,r,i){super(i),this.solidPrimitiveType="cone",this._localToWorld=t,this._radiusA=e,this._radiusB=r,this._maxRadius=Math.max(this._radiusA,this._radiusB)}clone(){return new Cone(this._localToWorld.clone(),this._radiusA,this._radiusB,this.capped)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return t.multiplyTransformTransform(e._localToWorld,e._localToWorld),e}static createAxisPoints(t,e,r,i,a){const c=t.vectorTo(e),l=c.magnitude();if(o.Geometry.isSmallMetricDistance(l))return;if((r=o.Geometry.correctSmallMetricDistance(r))*(i=o.Geometry.correctSmallMetricDistance(i))<0)return;if(r+i===0)return;const d=s.Matrix3d.createRigidHeadsUp(c);d.scaleColumns(1,1,l,d);const h=n.Transform.createOriginAndMatrix(t,d);return new Cone(h,r,i,a)}static createBaseAndTarget(t,e,r,i,s,a,c){s=Math.abs(o.Geometry.correctSmallMetricDistance(s)),a=Math.abs(o.Geometry.correctSmallMetricDistance(a));const l=t.vectorTo(e),d=n.Transform.createOriginAndMatrixColumns(t,r,i,l);return new Cone(d,s,a,c)}getCenterA(){return this._localToWorld.multiplyXYZ(0,0,0)}getCenterB(){return this._localToWorld.multiplyXYZ(0,0,1)}getVectorX(){return this._localToWorld.matrix.columnX()}getVectorY(){return this._localToWorld.matrix.columnY()}getRadiusA(){return this._radiusA}getRadiusB(){return this._radiusB}getMaxRadius(){return this._maxRadius}vFractionToRadius(t){return o.Geometry.interpolate(this._radiusA,t,this._radiusB)}isSameGeometryClass(t){return t instanceof Cone}isAlmostEqual(t){return t instanceof Cone&&(this.capped===t.capped&&(!!this._localToWorld.isAlmostEqual(t._localToWorld)&&(o.Geometry.isSameCoordinate(this._radiusA,t._radiusA)&&o.Geometry.isSameCoordinate(this._radiusB,t._radiusB))))}dispatchToGeometryHandler(t){return t.handleCone(this)}strokeConstantVSection(t,e,r){let n=16;void 0!==e?n=e:void 0!==r&&(n=r.defaultCircleStrokes),n=o.Geometry.clampToStartEnd(n,4,64);const s=this.vFractionToRadius(t),a=h.LineString3d.createForStrokes(e,r),c=2*Math.PI,l=c/n;let d=0;const u=a.fractions,f=a.packedDerivatives,g=a.packedUVParams,p=a.packedSurfaceNormals,m=i.Point3d.create(),y=i.Vector3d.create(),P=i.Vector3d.create(),x=i.Vector3d.create(),_=this._localToWorld;let v,S,C,A;for(let i=0;i<=n;i++)d=2*i<=n?i*l:(i-n)*l,v=s*(C=Math.cos(d)),S=s*(A=Math.sin(d)),_.multiplyXYZ(v,S,t,m),a.addPoint(m),u&&u.push(i/n),f&&(_.matrix.multiplyXYZ(-S*c,v*c,0,y),f.push(y)),p&&(_.matrix.multiplyXYZ(-A,C,0,y),_.matrix.multiplyXYZ(0,0,1,P),y.unitCrossProduct(P,x),p.push(x)),g&&g.pushXY(i/n,t);return a}constantVSection(t){const e=this.vFractionToRadius(t),r=this._localToWorld,i=r.multiplyXYZ(0,0,t),n=r.matrix.multiplyXYZ(e,0,0),s=r.matrix.multiplyXYZ(0,e,0);return c.Loop.create(d.Arc3d.create(i,n,s))}extendRange(t,e){const r=this.constantVSection(0),i=this.constantVSection(1);r.extendRange(t,e),i.extendRange(t,e)}uvFractionToPoint(t,e,r){const i=t*Math.PI*2,n=o.Geometry.interpolate(this._radiusA,e,this._radiusB),s=Math.cos(i),a=Math.sin(i);return this._localToWorld.multiplyXYZ(n*s,n*a,e,r)}uvFractionToPointAndTangents(t,e,r){const i=t*Math.PI*2,n=o.Geometry.interpolate(this._radiusA,e,this._radiusB),s=this._radiusB-this._radiusA,a=Math.cos(i),c=Math.sin(i),d=2*Math.PI;return l.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(n*a,n*c,e),this._localToWorld.multiplyVectorXYZ(-n*c*d,n*a*d,0),this._localToWorld.multiplyVectorXYZ(s*a,s*c,1),r)}get isClosedVolume(){return this.capped}maxIsoParametricDistance(){const t=this._localToWorld.matrix.columnX(),e=this._localToWorld.matrix.columnY(),r=this._localToWorld.matrix.columnZ(),i=t.unitCrossProduct(e),n=i.dotProduct(r),s=r.plusScaled(i,n).magnitudeXY();return u.Vector2d.create(2*Math.PI*Math.max(this._radiusA,this._radiusB),o.Geometry.hypotenuseXY(Math.abs(this._radiusB-this._radiusA)+s,n))}}e.Cone=Cone},"./lib/solid/LinearSweep.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Transform.js"),s=r("./lib/curve/Loop.js"),o=r("./lib/curve/Path.js"),a=r("./lib/curve/LineString3d.js"),c=r("./lib/geometry3d/PolygonOps.js"),l=r("./lib/solid/SweepContour.js"),d=r("./lib/solid/SolidPrimitive.js");class LinearSweep extends d.SolidPrimitive{constructor(t,e,r){super(r),this.solidPrimitiveType="linearSweep",this._contour=t,this._direction=e}static create(t,e,r){const i=l.SweepContour.createForLinearSweep(t,e);if(i)return new LinearSweep(i,e,r)}static createZSweep(t,e,r,n){const l=a.LineString3d.createXY(t,e,n);if(n){l.addClosurePoint(),c.PolygonOps.areaXY(l.points)*r<0&&l.points.reverse()}const d=n?s.Loop.create(l):o.Path.create(l);return LinearSweep.create(d,i.Vector3d.create(0,0,r),n)}getCurvesRef(){return this._contour.curves}getSweepContourRef(){return this._contour}cloneSweepVector(){return this._direction.clone()}isSameGeometryClass(t){return t instanceof LinearSweep}clone(){return new LinearSweep(this._contour.clone(),this._direction.clone(),this.capped)}tryTransformInPlace(t){return!t.matrix.isSingular()&&(!!this._contour.tryTransformInPlace(t)&&(t.multiplyVector(this._direction,this._direction),!0))}getConstructiveFrame(){return this._contour.localToWorld.cloneRigid()}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}isAlmostEqual(t){return t instanceof LinearSweep&&(this._contour.isAlmostEqual(t._contour)&&this._direction.isAlmostEqual(t._direction)&&this.capped===t.capped)}dispatchToGeometryHandler(t){return t.handleLinearSweep(this)}constantVSection(t){const e=this._contour.curves.clone();return e&&0!==t&&e.tryTransformInPlace(n.Transform.createTranslation(this._direction.scale(t))),e}extendRange(t,e){const r=this._contour.curves.range(e);if(t.extendRange(r),e){const t=e.multiplyVector(this._direction);r.low.addInPlace(t),r.high.addInPlace(t)}else r.low.addInPlace(this._direction),r.high.addInPlace(this._direction);t.extendRange(r)}get isClosedVolume(){return this.capped&&this._contour.curves.isAnyRegionType}}e.LinearSweep=LinearSweep},"./lib/solid/RotationalSweep.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Transform.js"),n=r("./lib/geometry3d/Matrix3d.js"),s=r("./lib/Geometry.js"),o=r("./lib/geometry3d/Angle.js"),a=r("./lib/solid/SweepContour.js"),c=r("./lib/solid/SolidPrimitive.js"),l=r("./lib/curve/StrokeOptions.js");class RotationalSweep extends c.SolidPrimitive{constructor(t,e,r,i){super(i),this.solidPrimitiveType="rotationalSweep",this._contour=t,this._normalizedAxis=e,this.capped=i,this._sweepAngle=r}static create(t,e,r,i){if(!e.direction.normalizeInPlace())return;const n=a.SweepContour.createForRotation(t,e);return n?new RotationalSweep(n,e,r.clone(),i):void 0}getConstructiveFrame(){const t=this._contour.localToWorld.matrix.columnZ(),e=n.Matrix3d.createRigidFromColumns(t,this._normalizedAxis.direction,s.AxisOrder.YZX);if(e)return i.Transform.createOriginAndMatrix(this._normalizedAxis.origin,e)}cloneAxisRay(){return this._normalizedAxis.clone()}getCurves(){return this._contour.curves}getSweepContourRef(){return this._contour}getSweep(){return this._sweepAngle.clone()}isSameGeometryClass(t){return t instanceof RotationalSweep}isAlmostEqual(t){return t instanceof RotationalSweep&&(this._contour.isAlmostEqual(t._contour)&&this._normalizedAxis.isAlmostEqual(t._normalizedAxis)&&this.capped===t.capped)}clone(){return new RotationalSweep(this._contour.clone(),this._normalizedAxis.clone(),this._sweepAngle.clone(),this.capped)}tryTransformInPlace(t){return!(t.matrix.isSingular()||!this._contour.tryTransformInPlace(t))&&(this._normalizedAxis.transformInPlace(t),this._normalizedAxis.direction.normalizeInPlace())}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}dispatchToGeometryHandler(t){return t.handleRotationalSweep(this)}getFractionalRotationTransform(t,e){const r=this._sweepAngle.radians*t;return i.Transform.createFixedPointAndMatrix(this._normalizedAxis.origin,n.Matrix3d.createRotationAroundVector(this._normalizedAxis.direction,o.Angle.createRadians(r),e?e.matrix:void 0))}constantVSection(t){const e=this._contour.curves.clone();return e&&e.tryTransformInPlace(this.getFractionalRotationTransform(t)),e}extendRange(t,e){const r=l.StrokeOptions.createForCurves();r.angleTol=o.Angle.createDegrees(11.25);const n=this._contour.curves.cloneStroked(r),a=s.Geometry.stepCount(11.25,this._sweepAngle.degrees,4,32),c=i.Transform.createIdentity();if(e){const r=i.Transform.createIdentity();for(let i=0;i<=a;i++)e.multiplyTransformTransform(this.getFractionalRotationTransform(i/a,c),r),n.extendRange(t,r)}else for(let i=0;i<=a;i++)n.extendRange(t,this.getFractionalRotationTransform(i/a,c))}get isClosedVolume(){return this.capped||this._sweepAngle.isFullCircle}}e.RotationalSweep=RotationalSweep},"./lib/solid/RuledSweep.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/CurveCollection.js"),n=r("./lib/curve/CurvePrimitive.js"),s=r("./lib/Geometry.js"),o=r("./lib/solid/SolidPrimitive.js"),a=r("./lib/solid/SweepContour.js"),c=r("./lib/curve/ConstructCurveBetweenCurves.js");class RuledSweep extends o.SolidPrimitive{constructor(t,e){super(e),this.solidPrimitiveType="ruledSweep",this._contours=t}static create(t,e){const r=[];for(const i of t){const t=a.SweepContour.createForLinearSweep(i);if(void 0===t)return;r.push(t)}return new RuledSweep(r,e)}sweepContoursRef(){return this._contours}cloneSweepContours(){const t=[];for(const e of this._contours)t.push(e.clone());return t}cloneContours(){const t=[];for(const e of this._contours)t.push(e.curves.clone());return t}clone(){return new RuledSweep(this.cloneSweepContours(),this.capped)}tryTransformInPlace(t){if(t.matrix.isSingular())return!1;for(const e of this._contours)e.tryTransformInPlace(t);return!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}getConstructiveFrame(){if(0!==this._contours.length)return this._contours[0].localToWorld.cloneRigid()}isSameGeometryClass(t){return t instanceof RuledSweep}isAlmostEqual(t){if(t instanceof RuledSweep){if(this.capped!==t.capped)return!1;if(this._contours.length!==t._contours.length)return!1;for(let e=0;e<this._contours.length;e++)if(!this._contours[e].isAlmostEqual(t._contours[e]))return!1;return!0}return!1}dispatchToGeometryHandler(t){return t.handleRuledSweep(this)}constantVSection(t){const e=this._contours.length;if(e<2)return;const r=t*e;let i=0;(i=t>=1?e-1:Math.floor(r))+1>=e&&(i=e-2);const o=i+1,a=s.Geometry.clampToStartEnd(r-i,0,1);return RuledSweep.mutatePartners(this._contours[i].curves,this._contours[o].curves,(t,e)=>{const r=c.ConstructCurveBetweenCurves.interpolateBetween(t,a,e);if(r instanceof n.CurvePrimitive)return r})}extendRange(t,e){for(const r of this._contours)r.curves.extendRange(t,e)}static mutatePartners(t,e,r){if(t.isSameGeometryClass(e)){if(t instanceof i.CurveChain&&e instanceof i.CurveChain){const i=t,n=e,s=i.cloneEmptyPeer(),o=i.children,a=n.children;if(o.length!==a.length)return;for(let t=0;t<o.length;t++){const e=r(o[t],a[t]);if(!e)return;s.children.push(e)}return s}if(t instanceof i.CurveCollection&&e instanceof i.CurveCollection){const s=t.cloneEmptyPeer(),o=t.children,a=e.children,c=s.children;if(void 0===o||void 0===a||void 0===c||o.length!==a.length)return;for(let t=0;t<o.length;t++){const e=o[t],s=a[t];if(e instanceof n.CurvePrimitive&&s instanceof n.CurvePrimitive){const t=r(e,s);if(!t)return;c.push(t)}else if(e instanceof i.CurveCollection&&s instanceof i.CurveCollection){const t=this.mutatePartners(e,s,r);if(!t)return;t instanceof i.CurveCollection&&c.push(t)}}return s}}}get isClosedVolume(){const t=this._contours.length;return t>1&&(this.capped||this._contours[0].isAlmostEqual(this._contours[t-1]))}}e.RuledSweep=RuledSweep},"./lib/solid/SolidPrimitive.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/curve/GeometryQuery.js");e.SolidPrimitive=class SolidPrimitive extends i.GeometryQuery{constructor(t){super(),this.geometryCategory="solid",this._capped=t}get capped(){return this._capped}set capped(t){this._capped=t}}},"./lib/solid/Sphere.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/geometry3d/Transform.js"),s=r("./lib/geometry3d/Matrix3d.js"),o=r("./lib/curve/StrokeOptions.js"),a=r("./lib/Geometry.js"),c=r("./lib/geometry3d/AngleSweep.js"),l=r("./lib/solid/SolidPrimitive.js"),d=r("./lib/curve/Loop.js"),h=r("./lib/curve/Arc3d.js"),u=r("./lib/curve/LineString3d.js"),f=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),g=r("./lib/geometry3d/Point2dVector2d.js");class Sphere extends l.SolidPrimitive{constructor(t,e,r){super(r),this.solidPrimitiveType="sphere",this._localToWorld=t,this._latitudeSweep=e||c.AngleSweep.createFullLatitude()}vFractionToRadians(t){return this._latitudeSweep.fractionToRadians(t)}uFractionToRadians(t){return t*Math.PI*2}clone(){return new Sphere(this._localToWorld.clone(),this._latitudeSweep.clone(),this.capped)}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return t.multiplyTransformTransform(e._localToWorld,e._localToWorld),t.matrix.determinant()<0&&void 0!==e._latitudeSweep&&e._latitudeSweep.reverseInPlace(),e}getConstructiveFrame(){return this._localToWorld.cloneRigid()}get latitudeSweepFraction(){return this._latitudeSweep.sweepRadians/Math.PI}static createCenterRadius(t,e,r){const i=n.Transform.createOriginAndMatrix(t,s.Matrix3d.createUniformScale(e));return new Sphere(i,r||c.AngleSweep.createFullLatitude(),!1)}static createEllipsoid(t,e,r){return new Sphere(t,e,r)}static createDgnSphere(t,e,r,i,o,a,c){const l=e.rotate90Around(r);if(l&&!e.isParallelTo(r)){const d=s.Matrix3d.createColumns(e,l,r);d.scaleColumns(i,i,o,d);const h=n.Transform.createOriginAndMatrix(t,d);return new Sphere(h,a.clone(),c)}}static createFromAxesAndScales(t,e,r,i,s,o,a){const l=n.Transform.createOriginAndMatrix(t,e);return l.matrix.scaleColumnsInPlace(r,i,s),new Sphere(l,o?o.clone():c.AngleSweep.createFullLatitude(),a)}cloneCenter(){return this._localToWorld.getOrigin()}cloneVectorX(){return this._localToWorld.matrix.columnX()}cloneVectorY(){return this._localToWorld.matrix.columnY()}cloneVectorZ(){return this._localToWorld.matrix.columnZ()}cloneLatitudeSweep(){return this._latitudeSweep.clone()}trueSphereRadius(){const t=this._localToWorld.matrix.factorRigidWithSignedScale();if(t)return t&&t.scale>0?t.scale:void 0}cloneLocalToWorld(){return this._localToWorld.clone()}isSameGeometryClass(t){return t instanceof Sphere}isAlmostEqual(t){return t instanceof Sphere&&(this.capped===t.capped&&!!this._localToWorld.isAlmostEqual(t._localToWorld))}strokeConstantVSection(t,e,r){let n=16;void 0!==e&&Number.isFinite(e)?n=e:r instanceof o.StrokeOptions&&(n=r.applyTolerancesToArc(a.Geometry.maxXY(this._localToWorld.matrix.columnXMagnitude(),this._localToWorld.matrix.columnYMagnitude()))),n=a.Geometry.clampToStartEnd(n,4,64);const s=this._localToWorld,c=this.vFractionToRadians(t),l=Math.cos(c),d=Math.sin(c);let h,f;const g=u.LineString3d.createForStrokes(e,r),p=2*Math.PI/n,m=g.fractions,y=g.packedDerivatives,P=g.packedUVParams,x=g.packedSurfaceNormals,_=i.Vector3d.create(),v=i.Vector3d.create(),S=i.Vector3d.create();let C=0;for(let i=0;i<=n;i++){C=2*i<=n?i*p:(i-n)*p,h=Math.cos(C),f=Math.sin(C);const e=s.multiplyXYZ(l*h,l*f,d);g.addPoint(e),m&&m.push(i/n),y&&(s.matrix.multiplyXYZ(-l*f,l*h,0,_),y.push(_)),P&&P.pushXY(i/n,t),x&&(s.matrix.multiplyXYZ(-f,h,0,_),s.matrix.multiplyXYZ(-d*h,-d*f,l,v),_.unitCrossProduct(v,S),x.push(S))}return g}dispatchToGeometryHandler(t){return t.handleSphere(this)}constantVSection(t){const e=this._latitudeSweep.fractionToRadians(t),r=Math.sin(e),i=Math.cos(e),n=this._localToWorld,s=n.multiplyXYZ(0,0,r),o=n.matrix.multiplyXYZ(i,0,0),a=n.matrix.multiplyXYZ(0,i,0);return d.Loop.create(h.Arc3d.create(s,o,a))}extendRange(t,e){let r=this._localToWorld;e&&(r=e.multiplyTransformTransform(r)),t.extendTransformedXYZ(r,-1,-1,-1),t.extendTransformedXYZ(r,1,-1,-1),t.extendTransformedXYZ(r,-1,1,-1),t.extendTransformedXYZ(r,1,1,-1),t.extendTransformedXYZ(r,-1,-1,1),t.extendTransformedXYZ(r,1,-1,1),t.extendTransformedXYZ(r,-1,1,1),t.extendTransformedXYZ(r,1,1,1)}uvFractionToPoint(t,e,r){const i=this.uFractionToRadians(t),n=this.vFractionToRadians(e),s=Math.cos(i),o=Math.sin(i),a=Math.sin(n),c=Math.cos(n);return this._localToWorld.multiplyXYZ(s*c,o*c,a,r)}uvFractionToPointAndTangents(t,e,r){const i=this.uFractionToRadians(t),n=this.vFractionToRadians(e),s=2*Math.PI,o=this._latitudeSweep.sweepRadians,a=Math.cos(i),c=Math.sin(i),l=Math.sin(n),d=Math.cos(n);return f.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(a*d,c*d,l),this._localToWorld.matrix.multiplyXYZ(-s*c,s*a,0),this._localToWorld.matrix.multiplyXYZ(-o*a*l,-o*c*l,o*d),r)}get isClosedVolume(){return this.capped||this._latitudeSweep.isFullLatitudeSweep}maxIsoParametricDistance(){const t=this._localToWorld.matrix.columnXMagnitude(),e=this._localToWorld.matrix.columnYMagnitude(),r=this._localToWorld.matrix.columnZMagnitude(),i=Math.max(t,e);let n=2*Math.PI*i;this._latitudeSweep.isRadiansInSweep(0)||(n*=Math.max(Math.cos(Math.abs(this._latitudeSweep.startRadians)),Math.cos(Math.abs(this._latitudeSweep.endRadians))));const s=Math.max(i,r)*Math.abs(this._latitudeSweep.sweepRadians);return g.Vector2d.create(n,s)}}e.Sphere=Sphere},"./lib/solid/SweepContour.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/FrameBuilder.js"),n=r("./lib/polyface/PolyfaceBuilder.js"),s=r("./lib/topology/Triangulation.js"),o=r("./lib/curve/LineString3d.js"),a=r("./lib/curve/ParityRegion.js"),c=r("./lib/curve/Loop.js"),l=r("./lib/geometry3d/PolygonOps.js");class SweepContour{constructor(t,e,r){this.curves=t,this.localToWorld=e,this.axis=r}static createForLinearSweep(t,e){const r=i.FrameBuilder.createRightHandedFrame(e,t);if(r)return new SweepContour(t,r,void 0)}static createForPolygon(t,e){const r=i.FrameBuilder.createRightHandedFrame(e,t);if(r){void 0!==e&&r.matrix.dotColumnZ(e)&&r.matrix.scaleColumnsInPlace(1,-1,-1);const i=o.LineString3d.createArrayOfLineString3dFromVariantData(t),n=[];for(const t of i)t.addClosurePoint(),n.push(c.Loop.create(t));if(1===n.length)return new SweepContour(n[0],r,void 0);if(n.length>1)return new SweepContour(a.ParityRegion.createLoops(n),r,void 0)}}static createForRotation(t,e){const r=i.FrameBuilder.createRightHandedFrame(void 0,t,e);if(r)return new SweepContour(t,r,e.clone())}getCurves(){return this.curves}tryTransformInPlace(t){if(this.curves.tryTransformInPlace(t)){this.axis&&this.axis.transformInPlace(t);const e=void 0!==this.axis?i.FrameBuilder.createRightHandedFrame(void 0,this.curves,this.axis):i.FrameBuilder.createRightHandedFrame(void 0,this.curves);if(e)return this.localToWorld.setFrom(e),!0}return!1}clone(){return new SweepContour(this.curves.clone(),this.localToWorld.clone(),this.axis)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}isAlmostEqual(t){return t instanceof SweepContour&&(this.curves.isAlmostEqual(t.curves)&&this.localToWorld.isAlmostEqual(t.localToWorld))}buildFacets(t,e){if(!this._facets)if(this.curves instanceof c.Loop){if(this._xyStrokes=this.curves.cloneStroked(e),this._xyStrokes instanceof c.Loop&&1===this._xyStrokes.children.length){const t=this._xyStrokes.children[0].points;this.localToWorld.multiplyInversePoint3dArrayInPlace(t),l.PolygonOps.sumTriangleAreasXY(t)<0&&t.reverse();const r=s.Triangulator.createTriangulatedGraphFromSingleLoop(t);if(r){s.Triangulator.flipTriangles(r);const t=n.PolyfaceBuilder.graphToPolyface(r,e);this._facets=t,this._facets.tryTransformInPlace(this.localToWorld)}}}else if(this.curves instanceof a.ParityRegion&&(this._xyStrokes=this.curves.cloneStroked(e),this._xyStrokes instanceof a.ParityRegion)){const t=this.localToWorld.inverse();this._xyStrokes.tryTransformInPlace(t);const r=[];for(const e of this._xyStrokes.children){const t=e.children;if(1===t.length){const e=t[0];e instanceof o.LineString3d&&r.push(e.packedPoints)}}const i=s.Triangulator.createTriangulatedGraphFromLoops(r);if(i){s.Triangulator.flipTriangles(i);const t=n.PolyfaceBuilder.graphToPolyface(i,e);this._facets=t,this._facets.tryTransformInPlace(this.localToWorld)}}}purgeFacets(){this._facets=void 0}emitFacets(t,e,r){this.buildFacets(t,t.options),this._facets&&t.addIndexedPolyface(this._facets,e,r)}}e.SweepContour=SweepContour},"./lib/solid/TorusPipe.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Transform.js"),n=r("./lib/Geometry.js"),s=r("./lib/geometry3d/AngleSweep.js"),o=r("./lib/solid/SolidPrimitive.js"),a=r("./lib/curve/Loop.js"),c=r("./lib/curve/Path.js"),l=r("./lib/curve/Arc3d.js"),d=r("./lib/geometry3d/Plane3dByOriginAndVectors.js"),h=r("./lib/geometry3d/Point2dVector2d.js");class TorusPipe extends o.SolidPrimitive{constructor(t,e,r,i,n){super(n),this.solidPrimitiveType="torusPipe",this._localToWorld=t,this._radiusA=e,this._radiusB=r,this._sweep=i,this._isReversed=!1}clone(){const t=new TorusPipe(this._localToWorld.clone(),this._radiusA,this._radiusB,this._sweep.clone(),this.capped);return t._isReversed=this._isReversed,t}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return t.multiplyTransformTransform(e._localToWorld,e._localToWorld),e}static createInFrame(t,e,r,i,s){if((e=Math.abs(n.Geometry.correctSmallMetricDistance(e)))<(r=Math.abs(n.Geometry.correctSmallMetricDistance(r))))return;if(0===e)return;if(0===r)return;if(i.isAlmostZero)return;let o=1,a=1;t.matrix.determinant()<0&&(a*=-1);let c=!1;const l=i.clone();i.radians<0&&(l.setRadians(-i.radians),a*=-1,o*=-1,c=!0);const d=t.clone();d.matrix.scaleColumns(1,o,a,d.matrix);const h=new TorusPipe(d,e,r,l,s);return h._isReversed=c,h}static createDgnTorusPipe(t,e,r,n,s,o,a){const c=e.crossProduct(r);c.scaleToLength(e.magnitude(),c);const l=i.Transform.createOriginAndMatrixColumns(t,e,r,c);return TorusPipe.createInFrame(l,n,s,o,a)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}cloneCenter(){return this._localToWorld.getOrigin()}cloneVectorX(){return this._localToWorld.matrix.columnX()}cloneVectorY(){return this._localToWorld.matrix.columnY()}getMinorRadius(){return this._radiusB}getMajorRadius(){return this._radiusA}getSweepAngle(){return this._sweep.clone()}getIsReversed(){return this._isReversed}getThetaFraction(){return this._sweep.radians/(2*Math.PI)}isSameGeometryClass(t){return t instanceof TorusPipe}isAlmostEqual(t){return t instanceof TorusPipe&&(this.capped===t.capped&&(!!this._localToWorld.isAlmostEqual(t._localToWorld)&&(n.Geometry.isSameCoordinate(this._radiusA,t._radiusA)&&n.Geometry.isSameCoordinate(this._radiusB,t._radiusB)&&this._sweep.isAlmostEqualNoPeriodShift(t._sweep))))}vFractionToRadians(t){return this._sweep.radians*t}dispatchToGeometryHandler(t){return t.handleTorusPipe(this)}constantVSection(t){const e=this.vFractionToRadians(t),r=Math.cos(e),i=Math.sin(e),n=this.getMajorRadius(),s=this.getMinorRadius(),o=this._localToWorld.multiplyXYZ(n*r,n*i,0),c=this._localToWorld.multiplyVectorXYZ(s*r,s*i,0),d=this._localToWorld.multiplyVectorXYZ(0,0,s);return a.Loop.create(l.Arc3d.create(o,c,d))}constantUSection(t){const e=this._sweep.radians,r=t*Math.PI,i=this.getMajorRadius(),n=this.getMinorRadius(),o=this._localToWorld.matrix,a=this._localToWorld.multiplyXYZ(0,0,n*Math.sin(r)),d=i+n*Math.cos(r),h=o.multiplyXYZ(d,0,0),u=o.multiplyXYZ(0,d,0);return c.Path.create(l.Arc3d.create(a,h,u,s.AngleSweep.createStartEndRadians(0,e)))}extendRange(t,e){const r=this._sweep.radians,i=this.getMajorRadius(),n=this.getMinorRadius(),s=this._localToWorld,o=Math.ceil(r/(Math.PI/16));let a=0,c=0,l=0,d=0,h=0,u=0,f=0,g=0,p=0;const m=r/o;for(let y=0;y<=o;y++)if(d=y*m,h=Math.cos(d),u=Math.sin(d),0===y||y===o?(a=-Math.PI,c=2*Math.PI/16,l=16):(a=-.5*Math.PI,c=Math.PI/16,l=31),e)for(p=0;p<=l;p++)g=a+p*c,f=i+n*Math.cos(g),t.extendTransformTransformedXYZ(e,s,h*f,u*f,Math.sin(g)*n);else for(p=0;p<=l;p++)g=a+p*c,f=i+n*Math.sin(g),t.extendTransformedXYZ(s,h*f,u*f,Math.sin(g)*n)}uvFractionToPoint(t,e,r){const i=e*this._sweep.radians,n=t*Math.PI*2,s=Math.cos(i),o=Math.sin(i),a=this.getMinorRadius(),c=this.getMajorRadius()+Math.cos(n)*a;return this._localToWorld.multiplyXYZ(c*s,c*o,a*Math.sin(n),r)}uvFractionToPointAndTangents(t,e,r){const i=e*this._sweep.radians,n=t*Math.PI*2,s=this._sweep.radians,o=2*Math.PI,a=Math.cos(i),c=Math.sin(i),l=Math.sin(n),h=Math.cos(n),u=this.getMinorRadius(),f=this.getMajorRadius()+Math.cos(n)*u,g=u*l,p=u*h;return d.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(a*f,c*f,g),this._localToWorld.multiplyVectorXYZ(-a*g*o,-c*g*o,p*o),this._localToWorld.multiplyVectorXYZ(-f*c*s,f*a*s,0),r)}maxIsoParametricDistance(){const t=Math.abs(this.getMajorRadius()),e=Math.abs(this.getMinorRadius());return h.Vector2d.create(e*Math.PI*2,(t+e)*this._sweep.radians)}get isClosedVolume(){return this.capped||this._sweep.isFullCircle}}e.TorusPipe=TorusPipe},"./lib/topology/ChainMerge.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/topology/Graph.js"),o=r("./lib/topology/Merging.js"),a=r("./lib/curve/LineString3d.js"),c=r("./lib/geometry3d/GrowableXYZArray.js");class ChainMergeContextValidatedOptions{constructor(t,e){this.tolerance=i.Geometry.smallMetricDistance,this.tolerance=t,this.primarySortDirection=e}static createPrimarySortVector(t){return void 0===t&&(t=this._defaultPrimarySortDirection.clone()),t.normalizeWithDefault(ChainMergeContextValidatedOptions._defaultPrimarySortDirection.x,ChainMergeContextValidatedOptions._defaultPrimarySortDirection.y,ChainMergeContextValidatedOptions._defaultPrimarySortDirection.z)}static createFromUnValidated(t){const e=new ChainMergeContextValidatedOptions(i.Geometry.smallMetricDistance,ChainMergeContextValidatedOptions.createPrimarySortVector());return void 0!==t&&(void 0!==t.tolerance&&(e.tolerance=t.tolerance),void 0!==t.primarySortDirection&&(e.primarySortDirection=ChainMergeContextValidatedOptions.createPrimarySortVector())),e}clone(){return new ChainMergeContextValidatedOptions(this.tolerance,this.primarySortDirection)}}ChainMergeContextValidatedOptions._defaultPrimarySortDirection=n.Vector3d.create(.294234298,.72391399,.45234328798);class ChainMergeContext{constructor(t){this._graph=new s.HalfEdgeGraph,this._options=t}static create(t){const e=ChainMergeContextValidatedOptions.createFromUnValidated(t);return new ChainMergeContext(e)}addSegment(t,e){this._graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0)}addLineSegment3dArray(t){for(const e of t)this.addSegment(e.point0Ref,e.point1Ref)}primarySortKey(t){return this._options.primarySortDirection.dotProductXYZ(t.x,t.y,t.z)}static nodeCompareSortData(t,e){return t.sortData-e.sortData}static isIsolatedEnd(t){return t.vertexSuccessor===t}static isChainInteriorVertex(t){const e=t.vertexSuccessor;return e!==t&&e.vertexSuccessor===t}clusterAndMergeVerticesXYZ(){o.HalfEdgeGraphOps.isolateAllEdges(this._graph);for(const i of this._graph.allHalfEdges)i.sortData=this.primarySortKey(i);const t=this._graph.allHalfEdges.slice();t.sort(ChainMergeContext.nodeCompareSortData);const e=this._options.tolerance,r=t.length;for(let i=0;i<r;i++){const n=t[i],o=n.sortData+e;if(ChainMergeContext.isIsolatedEnd(n))for(let a=i+1;a<r;a++){const r=t[a];if(ChainMergeContext.isIsolatedEnd(r)){if(r.sortData>o)break;n.distanceXYZ(r)<=e&&(s.HalfEdge.pinch(n,r),r.setXYZFrom(n))}}}}collectMaximalLineString3dFromStartNode(t,e,r){if(!e.isMaskSet(r)){const i=a.LineString3d.create();for(i.addPointXYZ(e.x,e.y,e.z);e.setMask(r),e.edgeMate.setMask(r),e=e.faceSuccessor,i.addPointXYZ(e.x,e.y,e.z),!e.isMaskSet(r)&&ChainMergeContext.isChainInteriorVertex(e););t.push(i)}}collectMaximalGrowableXYXArrayFromStartNode(t,e,r){if(!e.isMaskSet(r)){const i=new c.GrowableXYZArray;for(i.pushXYZ(e.x,e.y,e.z);e.setMask(r),e.edgeMate.setMask(r),e=e.faceSuccessor,i.pushXYZ(e.x,e.y,e.z),!e.isMaskSet(r)&&ChainMergeContext.isChainInteriorVertex(e););i.length>0&&t.push(i)}}exciseAndMarkSlingEdges(t){let e=0;for(const r of this._graph.allHalfEdges)if(r.distanceXYZ(r.edgeMate)<this._options.tolerance&&!r.isMaskSet(t)){const i=r.edgeMate;s.HalfEdge.pinch(r,r.vertexPredecessor),s.HalfEdge.pinch(i,i.vertexPredecessor),r.setMask(t),i.setMask(t),e++}return e}collectMaximalChains(){const t=[],e=s.HalfEdgeMask.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const r of this._graph.allHalfEdges)ChainMergeContext.isChainInteriorVertex(r)||this.collectMaximalLineString3dFromStartNode(t,r,e);for(const r of this._graph.allHalfEdges)this.collectMaximalLineString3dFromStartNode(t,r,e);return t}collectMaximalGrowableXYZArrays(){const t=[],e=s.HalfEdgeMask.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const r of this._graph.allHalfEdges)ChainMergeContext.isChainInteriorVertex(r)||this.collectMaximalGrowableXYXArrayFromStartNode(t,r,e);for(const r of this._graph.allHalfEdges)this.collectMaximalGrowableXYXArrayFromStartNode(t,r,e);return t}}e.ChainMergeContext=ChainMergeContext},"./lib/topology/Graph.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point2dVector2d.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/curve/LineSegment3d.js"),o=r("./lib/Geometry.js"),a=r("./lib/numerics/Polynomials.js"),c=r("./lib/topology/MaskManager.js");class HalfEdge{constructor(t=0,e=0,r=0,i=0){this._id=HalfEdge._totalNodesCreated++,this.i=i,this.maskBits=0,this.x=t,this.y=e,this.z=r,this.sortAngle=void 0,this.sortData=void 0,this.edgeTag=void 0,this._facePredecessor=this,this._faceSuccessor=this,this._edgeMate=this}get id(){return this._id}get facePredecessor(){return this._facePredecessor}get faceSuccessor(){return this._faceSuccessor}get edgeMate(){return this._edgeMate}faceStepY(t){let e=this;if(t>0)for(let r=0;r<t;r++)e=e.faceSuccessor;else if(t<0)for(let r=0;r>t;r--)e=e.facePredecessor;return e.y}static createHalfEdgePair(t){const e=new HalfEdge,r=new HalfEdge;return t&&(t.push(e),t.push(r)),HalfEdge.setFaceLinks(e,r),HalfEdge.setFaceLinks(r,e),HalfEdge.setEdgeMates(e,r),e}static createHalfEdgePairWithCoordinates(t=0,e=0,r=0,i=0,n=0,s=0,o=0,a=0,c){const l=HalfEdge.createHalfEdgePair(c),d=l._edgeMate;return l.x=t,l.y=e,l.z=r,l.i=i,d.x=n,d.y=s,d.z=o,d.i=a,l}static setFaceLinks(t,e){t._faceSuccessor=e,e._facePredecessor=t}static setEdgeMates(t,e){t._edgeMate=e,e._edgeMate=t}static splitEdge(t,e=0,r=0,i=0,n=0,s){const o=new HalfEdge(e,r,i,n),a=new HalfEdge(e,r,i,n);if(s&&(s.push(o),s.push(a)),void 0===t)o._faceSuccessor=o._facePredecessor=o,a._faceSuccessor=a._facePredecessor=a,HalfEdge.setEdgeMates(o,a);else{const e=t._faceSuccessor,r=t._edgeMate,i=r._faceSuccessor;HalfEdge.setFaceLinks(o,e),HalfEdge.setFaceLinks(t,o),HalfEdge.setFaceLinks(r,a),HalfEdge.setFaceLinks(a,i),HalfEdge.setEdgeMates(o,r),HalfEdge.setEdgeMates(a,t),o.edgeTag=t.edgeTag,a.edgeTag=r.edgeTag}return o}get vertexSuccessor(){return this.facePredecessor.edgeMate}get vertexPredecessor(){return this.edgeMate.faceSuccessor}setMask(t){this.maskBits|=t}getMask(t){return this.maskBits&t}clearMask(t){this.maskBits&=~t}setMaskAroundVertex(t){let e=this;do{e.setMask(t),e=e.vertexSuccessor}while(e!==this)}setXYZAroundVertex(t,e,r){let i=this;do{i.x=t,i.y=e,i.z=r,i=i.vertexSuccessor}while(i!==this)}setMaskAroundFace(t){let e=this;do{e.setMask(t),e=e.faceSuccessor}while(e!==this)}setMaskAroundEdge(t){this.setMask(t),this.edgeMate.setMask(t)}clearMaskAroundEdge(t){this.clearMask(t),this.edgeMate.clearMask(t)}countEdgesAroundFace(){let t=0,e=this;do{t++,e=e.faceSuccessor}while(e!==this);return t}setMaskAndEdgeTagAroundFace(t,e,r=!1){let i=this;do{if(i.setMask(t),i.edgeTag=e,r){const r=i.edgeMate;r.edgeTag=e,r.setMask(t)}i=i.faceSuccessor}while(i!==this)}countEdgesAroundVertex(){let t=0,e=this;do{t++,e=e.vertexSuccessor}while(e!==this);return t}countMaskAroundFace(t,e=!0){let r=0,i=this;if(e)do{i.isMaskSet(t)&&r++,i=i.faceSuccessor}while(i!==this);else do{i.isMaskSet(t)||r++,i=i.faceSuccessor}while(i!==this);return r}countMaskAroundVertex(t,e=!0){let r=0,i=this;if(e)do{i.isMaskSet(t)&&r++,i=i.vertexSuccessor}while(i!==this);else do{i.isMaskSet(t)||r++,i=i.vertexSuccessor}while(i!==this);return r}testAndSetMask(t){const e=this.maskBits&t;return this.maskBits|=t,e}setXYZFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}isMaskSet(t){return 0!==(this.maskBits&t)}static filterIsMaskOn(t,e){return t.isMaskSet(e)}static filterIsMaskOff(t,e){return!t.isMaskSet(e)}static createEdgeXYXY(t,e,r,i,n,s){const o=new HalfEdge(e,r),a=new HalfEdge(n,s);return o._faceSuccessor=o._facePredecessor=o._edgeMate=a,a._faceSuccessor=a._facePredecessor=a._edgeMate=o,o._id=t,a._id=i,o}static pinch(t,e){if(t!==e){const r=t._facePredecessor,i=e._facePredecessor;e._facePredecessor=r,t._facePredecessor=i,i._faceSuccessor=t,r._faceSuccessor=e}}decommission(){this._facePredecessor=void 0,this._faceSuccessor=void 0,this._edgeMate=void 0}static nodeToSelf(t){return t}static nodeToId(t){return t.id}static nodeToIdString(t){return t.id.toString()}static nodeToIdMaskXY(t){return{id:t.id,mask:HalfEdge.nodeToMaskString(t),xy:[t.x,t.y]}}static nodeToIdXYString(t){return t.id.toString()+" "+HalfEdge.nodeToMaskString(t)+" ["+t.x+","+t.y+"]"}static nodeToMaskString(t){let e="";return t.isMaskSet(l.BOUNDARY_EDGE)&&(e+="B"),t.isMaskSet(l.PRIMARY_EDGE)&&(e+="P"),t.isMaskSet(l.EXTERIOR)&&(e+="X"),t.isMaskSet(l.NULL_FACE)&&(e+="N"),e}static nodeToXY(t){return[t.x,t.y]}vectorToFaceSuccessorXY(t){return i.Vector2d.create(this.faceSuccessor.x-this.x,this.faceSuccessor.y-this.y,t)}vectorToFaceSuccessor(t){return n.Vector3d.create(this.faceSuccessor.x-this.x,this.faceSuccessor.y-this.y,this.faceSuccessor.z-this.z,t)}static crossProductXYToTargets(t,e,r){return o.Geometry.crossProductXYXY(e.x-t.x,e.y-t.y,r.x-t.x,r.y-t.y)}static crossProductXYAlongChain(t,e,r){return o.Geometry.crossProductXYXY(e.x-t.x,e.y-t.y,r.x-e.x,r.y-e.y)}belowYX(t){return this.y<t.y||!(this.y>t.y)&&this.x<t.x}static testNodeMaskNotExterior(t){return!t.isMaskSet(l.EXTERIOR)}static testFacePositiveAreaXY(t){return t.countEdgesAroundFace()>2&&t.signedFaceArea()>0}isEqualXY(t){return this.x===t.x&&this.y===t.y}distanceXY(t){return o.Geometry.distanceXYXY(this.x,this.y,t.x,t.y)}distanceXYZ(t){return o.Geometry.distanceXYZXYZ(this.x,this.y,this.z,t.x,t.y,t.z)}collectAroundFace(t){const e=[];let r=this;do{e.push(t?t(r):r),r=r.faceSuccessor}while(r!==this);return e}collectAroundVertex(t){const e=[];let r=this;do{e.push(t?t(r):r),r=r.vertexSuccessor}while(r!==this);return e}sumAroundFace(t){let e=this,r=0;do{r+=t(e),e=e.faceSuccessor}while(e!==this);return r}sumAroundVertex(t){let e=this,r=0;do{r+=t(e),e=e.vertexSuccessor}while(e!==this);return r}clearMaskAroundFace(t){let e=this;do{e.clearMask(t),e=e.faceSuccessor}while(e!==this)}clearMaskAroundVertex(t){let e=this;do{e.clearMask(t),e=e.vertexSuccessor}while(e!==this)}signedFaceArea(){let t=0;const e=this.y;let r=0,i=0,n=this.x,s=n,o=this,a=this;do{t+=(n-(s=(o=a.faceSuccessor).x))*(r+(i=o.y-e)),n=s,r=i,a=o,a=o}while(a!==this);return.5*t}fractionToPoint2d(t,e){const r=this.faceSuccessor;return i.Point2d.create(this.x+(r.x-this.x)*t,this.y+(r.y-this.y)*t,e)}fractionToPoint3d(t,e){const r=this.faceSuccessor;return n.Point3d.create(this.x+(r.x-this.x)*t,this.y+(r.y-this.y)*t,this.z+(r.z-this.z)*t,e)}fractionAlongAndPerpendicularToPoint2d(t,e,r){const n=this.faceSuccessor,s=n.x-this.x,o=n.y-this.y;return i.Point2d.create(this.x+s*t-o*e,this.y+o*t+s*e,r)}fractionToX(t){const e=this.faceSuccessor;return this.x+(e.x-this.x)*t}fractionToY(t){const e=this.faceSuccessor;return this.y+(e.y-this.y)*t}fractionToZ(t){const e=this.faceSuccessor;return this.z+(e.z-this.z)*t}static transverseIntersectionFractions(t,e,r){const n=t.faceSuccessor,s=e.faceSuccessor;if(r||(r=i.Vector2d.create()),a.SmallSystem.linearSystem2d(n.x-t.x,e.x-s.x,n.y-t.y,e.y-s.y,e.x-t.x,e.y-t.y,r))return r}static horizontalScanFraction(t,e){const r=t.faceSuccessor,i=r.y-t.y;return o.Geometry.isSameCoordinate(e,t.y)&&o.Geometry.isSameCoordinate(e,r.y)?t:o.Geometry.isSameCoordinate(i,0)?void 0:o.Geometry.conditionalDivideFraction(e-t.y,i)}static horizontalScanFraction01(t,e){const r=t.faceSuccessor,i=r.y-t.y;if(o.Geometry.isSameCoordinate(e,t.y)&&o.Geometry.isSameCoordinate(e,r.y))return;if(o.Geometry.isSameCoordinate(i,0))return;const n=o.Geometry.conditionalDivideFraction(e-t.y,i);return void 0!==n&&n>=0&&n<=1?n:void 0}}e.HalfEdge=HalfEdge,HalfEdge._totalNodesCreated=0;var l;e.HalfEdgeGraph=class HalfEdgeGraph{constructor(){this._numNodesCreated=0,this.allHalfEdges=[],this._maskManager=c.MaskManager.create(l.ALL_GRAB_DROP_MASKS)}grabMask(t=!0){const e=this._maskManager.grabMask();return t&&this.clearMask(e),e}dropMask(t){this._maskManager.dropMask(t)}createEdgeXYZXYZ(t=0,e=0,r=0,i=0,n=0,s=0,o=0,a=0){return HalfEdge.createHalfEdgePairWithCoordinates(t,e,r,i,n,s,o,a,this.allHalfEdges)}createEdgeXYZHalfEdge(t=0,e=0,r=0,i=0,n,s=0){const o=HalfEdge.createHalfEdgePairWithCoordinates(t,e,r,i,n.x,n.y,n.z,s,this.allHalfEdges),a=o.faceSuccessor;return HalfEdge.pinch(n,a),o}createEdgeHalfEdgeHalfEdge(t,e,r,i=0){const n=HalfEdge.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,r.x,r.y,r.z,i,this.allHalfEdges),s=n.faceSuccessor;return HalfEdge.pinch(t,n),HalfEdge.pinch(r,s),n}createEdgeXYAndZ(t,e,r,i){return HalfEdge.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,r.x,r.y,r.z,i,this.allHalfEdges)}splitEdge(t,e=0,r=0,i=0,n=0){return HalfEdge.splitEdge(t,e,r,i,n,this.allHalfEdges)}splitEdgeAtFraction(t,e){return HalfEdge.splitEdge(t,t.fractionToX(e),t.fractionToY(e),t.fractionToZ(e),0,this.allHalfEdges)}decommission(){for(const t of this.allHalfEdges)t.decommission();this.allHalfEdges.length=0,this.allHalfEdges=void 0}addEdgeXY(t,e,r,i){const n=HalfEdge.createEdgeXYXY(this._numNodesCreated,t,e,this._numNodesCreated+1,r,i);return this._numNodesCreated+=2,this.allHalfEdges.push(n),this.allHalfEdges.push(n.faceSuccessor),n}clearMask(t){for(const e of this.allHalfEdges)e.maskBits&=~t}setMask(t){for(const e of this.allHalfEdges)e.maskBits|=t}reverseMask(t){for(const e of this.allHalfEdges)e.maskBits^=t}countMask(t){let e=0;for(const r of this.allHalfEdges)r.isMaskSet(t)&&e++;return e}collectSegments(){const t=[];for(const e of this.allHalfEdges)e.id<e.edgeMate.id&&t.push(s.LineSegment3d.create(n.Point3d.create(e.x,e.y),n.Point3d.create(e.faceSuccessor.x,e.faceSuccessor.y)));return t}countVertexLoops(){this.clearMask(l.VISITED);let t=0;return this.announceVertexLoops((e,r)=>(t++,!0)),t}countFaceLoops(){this.clearMask(l.VISITED);let t=0;return this.announceFaceLoops((e,r)=>(t++,!0)),t}countFaceLoopsWithMaskFilter(t,e){this.clearMask(l.VISITED);let r=0;return this.announceFaceLoops((i,n)=>(t(n,e)&&r++,!0)),r}collectFaceLoops(){const t=[];return this.announceFaceLoops((e,r)=>(t.push(r),!0)),t}collectVertexLoops(){this.clearMask(l.VISITED);const t=[];for(const e of this.allHalfEdges)e.getMask(l.VISITED)||(t.push(e),e.setMaskAroundVertex(l.VISITED));return t}announceFaceLoops(t){this.clearMask(l.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(l.VISITED)&&(e.setMaskAroundFace(l.VISITED),!t(this,e)))break}announceVertexLoops(t){this.clearMask(l.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(l.VISITED)&&(e.setMaskAroundVertex(l.VISITED),!t(this,e)))break}countNodes(){return this.allHalfEdges.length}transformInPlace(t){for(const e of this.allHalfEdges)t.multiplyXYAndZInPlace(e)}},function(t){t[t.EXTERIOR=1]="EXTERIOR",t[t.BOUNDARY_EDGE=2]="BOUNDARY_EDGE",t[t.PRIMARY_EDGE=4]="PRIMARY_EDGE",t[t.VISITED=16]="VISITED",t[t.TRIANGULATED_FACE=256]="TRIANGULATED_FACE",t[t.NULL_FACE=512]="NULL_FACE",t[t.NULL_MASK=0]="NULL_MASK",t[t.ALL_GRAB_DROP_MASKS=4293918720]="ALL_GRAB_DROP_MASKS",t[t.ALL_MASK=4294967295]="ALL_MASK"}(l=e.HalfEdgeMask||(e.HalfEdgeMask={}))},"./lib/topology/HalfEdgeGraphSearch.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/topology/Graph.js"),n=r("./lib/topology/XYParitySearchContext.js"),s=r("./lib/topology/SignedDataSummary.js");e.HalfEdgeMaskTester=class HalfEdgeMaskTester{constructor(t,e=!0){this._targetMask=t,this._targetValue=e}testEdge(t){return t.isMaskSet(this._targetMask)===this._targetValue}};class HalfEdgeGraphSearch{static pushAndMaskAllNodesInFace(t,e,r,i){i.push(t),t.collectAroundFace(t=>{t.setMask(e),r.push(t)})}static findMinimumAreaFace(t){return HalfEdgeGraphSearch.collectFaceAreaSummary(t).largestNegativeItem}static collectFaceAreaSummary(t,e=!1){const r=new s.SignedDataSummary(e);let n;n=t instanceof i.HalfEdgeGraph?t.collectFaceLoops():t;for(const i of n){const t=i.signedFaceArea();r.announceItem(i,t)}return r}static parityFloodFromSeed(t,e,r,i){const n=[];if(t.isMaskSet(e))return n;const s=i|e,o=[];for(HalfEdgeGraphSearch.pushAndMaskAllNodesInFace(t,s,o,n);o.length>0;){const t=o.pop(),a=t.edgeMate;if(a&&!a.isMaskSet(e)){let c=t.isMaskSet(i);r&&!r.testEdge(t)||(c=!c),HalfEdgeGraphSearch.pushAndMaskAllNodesInFace(a,c?s:e,o,n)}}return n}static correctParityInSingleComponent(t,e,r){if(HalfEdgeGraphSearch.findMinimumAreaFace(r).isMaskSet(e));else for(const i of r)i.isMaskSet(e)?i.clearMaskAroundFace(e):i.setMaskAroundFace(e)}static correctParityInComponentArrays(t,e,r){if(e!==i.HalfEdgeMask.NULL_MASK)for(const i of r)HalfEdgeGraphSearch.correctParityInSingleComponent(t,e,i)}static collectConnectedComponentsWithExteriorParityMasks(t,e,r=i.HalfEdgeMask.NULL_MASK){const n=[],s=i.HalfEdgeMask.VISITED,o=r|s;t.clearMask(o);for(const a of t.allHalfEdges)if(!a.isMaskSet(i.HalfEdgeMask.VISITED)){const t=HalfEdgeGraphSearch.parityFloodFromSeed(a,s,e,r);n.push(t)}return HalfEdgeGraphSearch.correctParityInComponentArrays(t,r,n),n}static pointInOrOnFaceXY(t,e,r){const i=new n.XYParitySearchContext(e,r);let s=t,o=t.faceSuccessor;for(;!i.tryStartEdge(s.x,s.y,o.x,o.y);s=o){if(o===t)return i.classifyCounts();o=s.faceSuccessor}let a=o.faceSuccessor;for(;;){if(!i.advance(a.x,a.y))return i.classifyCounts();if(a===o)break;a=a.faceSuccessor}return i.classifyCounts()}}e.HalfEdgeGraphSearch=HalfEdgeGraphSearch},"./lib/topology/HalfEdgeMarkSet.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/topology/Graph.js");class AbstractHalfEdgeGraphMarkSet{constructor(t,e){this._graph=t,this._candidates=[],this._mask=e,this._graph.clearMask(e)}clear(){for(;void 0!==this.chooseAndRemoveAny(););}getLength(){let t=0;for(const e of this._candidates)e.isMaskSet(this._mask)&&t++;return t}getNumCandidates(){return this._candidates.length}get graph(){return this._graph}teardown(){this._graph.dropMask(this._mask),this._candidates.length=0}get mask(){return this._mask}popAndReturn(){const t=this._candidates.length;if(0===t)return;const e=this._candidates[t-1];return this._candidates.pop(),e}getAtIndex(t){if(t>=0&&t<this._candidates.length){const e=this._candidates[t];if(e.isMaskSet(this._mask))return e}}addToSet(t){return!t.isMaskSet(this._mask)&&(this._candidates.push(t),this.setMaskInScope(t),!0)}isCandidateInSet(t){return t.isMaskSet(this._mask)}removeFromSet(t){return!!t.isMaskSet(this._mask)&&(this.clearMaskInScope(t),!0)}chooseAndRemoveAny(){for(;;){const t=this.popAndReturn();if(!t)return;if(this.removeFromSet(t))return t}}[Symbol.iterator](){return new IterableHalfEdgeMarkSetIterator(this)}addAroundFace(t){let e=t;do{this.addToSet(e),e=e.faceSuccessor}while(e!==t)}addAroundVertex(t){let e=t;do{this.addToSet(e),e=e.vertexSuccessor}while(e!==t)}}e.AbstractHalfEdgeGraphMarkSet=AbstractHalfEdgeGraphMarkSet;class MarkedHalfEdgeSt extends AbstractHalfEdgeGraphMarkSet{constructor(t,e){super(t,e)}static create(t){const e=t.grabMask();if(e!==i.HalfEdgeMask.NULL_MASK)return new MarkedHalfEdgeSt(t,e)}setMaskInScope(t){t.setMask(this._mask)}clearMaskInScope(t){t.clearMask(this._mask)}countHalfEdgesAroundCandidate(t){return t?1:0}}e.MarkedHalfEdgeSt=MarkedHalfEdgeSt;class MarkedEdgeSet extends AbstractHalfEdgeGraphMarkSet{constructor(t,e){super(t,e)}static create(t){const e=t.grabMask();if(e!==i.HalfEdgeMask.NULL_MASK)return new MarkedEdgeSet(t,e)}setMaskInScope(t){t.setMaskAroundEdge(this._mask)}clearMaskInScope(t){t.clearMaskAroundEdge(this._mask)}countHalfEdgesAroundCandidate(t){return t?2:0}}e.MarkedEdgeSet=MarkedEdgeSet;class MarkedFaceSet extends AbstractHalfEdgeGraphMarkSet{constructor(t,e){super(t,e)}static create(t){const e=t.grabMask();if(e!==i.HalfEdgeMask.NULL_MASK)return new MarkedFaceSet(t,e)}setMaskInScope(t){t.setMaskAroundFace(this._mask)}clearMaskInScope(t){t.clearMaskAroundFace(this._mask)}countHalfEdgesAroundCandidate(t){return t?t.countEdgesAroundFace():0}}e.MarkedFaceSet=MarkedFaceSet;class MarkedVertexSet extends AbstractHalfEdgeGraphMarkSet{constructor(t,e){super(t,e)}static create(t){const e=t.grabMask();if(e!==i.HalfEdgeMask.NULL_MASK)return new MarkedVertexSet(t,e)}setMaskInScope(t){t.setMaskAroundVertex(this._mask)}clearMaskInScope(t){t.clearMaskAroundVertex(this._mask)}countHalfEdgesAroundCandidate(t){return t?t.countEdgesAroundVertex():0}}e.MarkedVertexSet=MarkedVertexSet;class IterableHalfEdgeMarkSetIterator{constructor(t){this._markSet=t,this._nextReadIndex=0}next(){const t=this._markSet.getNumCandidates();for(;this._nextReadIndex<t;){const t=this._markSet.getAtIndex(this._nextReadIndex++);if(void 0!==t)return{done:!1,value:t}}return{done:!0,value:void 0}}[Symbol.iterator](){return this}}},"./lib/topology/HalfEdgeNodeXYZUV.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/geometry3d/Point3dVector3d.js"),n=r("./lib/Geometry.js"),s=r("./lib/geometry3d/Point2dVector2d.js");class NodeXYZUV{constructor(t,e,r,i,n,s){this._x=e,this._y=r,this._z=i,this._u=n,this._v=s,this._node=t}set(t,e,r,i,n,s){return this._x=e,this._y=r,this._z=i,this._u=n,this._v=s,this._node=t,this}setFrom(t){this._x=t.x,this._y=t.y,this._z=t.z,this._u=t.u,this._v=t.v,this._node=t.node}static createNodeAndRayOrigin(t,e,r){const i=t.x,s=t.y,o=t.z,a=i-e.origin.x,c=s-e.origin.y,l=n.Geometry.dotProductXYXY(a,c,e.direction.x,e.direction.y),d=n.Geometry.crossProductXYXY(e.direction.x,e.direction.y,a,c);return r?r.set(t,i,s,o,l,d):new NodeXYZUV(t,i,s,o,l,d)}get node(){return this._node}get x(){return this._x}get y(){return this._y}get z(){return this._z}get u(){return this._u}get v(){return this._v}getXYZAsPoint3d(t){return i.Point3d.create(this._x,this._y,this._z,t)}getUVAsPoint2d(t){return s.Point2d.create(this._u,this._v,t)}classifyU(t,e){const r=this.u-t;return Math.abs(r)<=e?0:r>=0?1:-1}classifyV(t,e){const r=t-this._v;return Math.abs(r)<=e?0:r>=0?1:-1}}e.NodeXYZUV=NodeXYZUV},"./lib/topology/HalfEdgePointInGraphSearch.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/topology/HalfEdgePositionDetail.js"),s=r("./lib/topology/HalfEdgeNodeXYZUV.js"),o=r("./lib/geometry3d/Point3dVector3d.js");var a;!function(t){t[t.RC_NoHits=0]="RC_NoHits",t[t.RC_TargetOnVertex=1]="RC_TargetOnVertex",t[t.RC_TargetOnEdge=2]="RC_TargetOnEdge",t[t.RC_Bracket=3]="RC_Bracket",t[t.RC_TargetBefore=4]="RC_TargetBefore",t[t.RC_TargetAfter=5]="RC_TargetAfter"}(a=e.RayClassification||(e.RayClassification={}));class PointSearchContext{constructor(t){this._tol=t}static create(t=i.Geometry.smallMetricDistance){return new PointSearchContext(t)}panic(){return n.HalfEdgePositionDetail.create()}reAimFromEdge(t,e,r){const i=t.node,n=s.NodeXYZUV.createNodeAndRayOrigin(i,e),o=s.NodeXYZUV.createNodeAndRayOrigin(i.edgeMate,e),a=-n.classifyV(0,this._tol),c=-o.classifyV(0,this._tol);let l;if(a*c<0)l=a>0?t.resetAsFace(n.node):t.resetAsFace(o.node);else if(0===a||0===c){const e=n.classifyU(r,this._tol),i=o.classifyU(r,this._tol);if(0===e&&0===a)(l=t.resetAsVertex(n.node)).setITag(1);else if(0===i&&0===c)(l=t.resetAsVertex(o.node)).setITag(1);else if(e*i<0){const e=(r-n.u)/(o.u-n.u);(l=t.resetAtEdgeAndFraction(n.node,e)).setITag(1)}else e<0&&i<0?l=n.u>o.u?t.resetAsVertex(n.node):t.resetAsVertex(o.node):Math.abs(n.u)<this._tol&&Math.abs(n.v)<this._tol?l=t.resetAsVertex(n.node):Math.abs(o.u)<this._tol&&Math.abs(o.v)<this._tol?l=t.resetAsVertex(o.node):(t.resetAsUnknown(),l=this.panic())}else t.resetAsUnknown(),l=this.panic();return l}reAimFromVertex(t,e,r){const i=t.node;let n,o=i;do{const i=s.NodeXYZUV.createNodeAndRayOrigin(o.faceSuccessor,e),a=s.NodeXYZUV.createNodeAndRayOrigin(o.facePredecessor,e),c=i.u,l=i.v,d=a.v;if(Math.abs(l)<this._tol){if(Math.abs(c-r)<this._tol)return(n=t.resetAsVertex(i.node)).setITag(1),n;if(c>r){const e=r/c;return n=t.resetAtEdgeAndFraction(o,e)}if(Math.abs(c)<=this._tol)return(n=t.resetAsVertex(o)).setITag(1),n;if(c>this._tol)return n=t.resetAsVertex(i.node);if(d>this._tol)return n=t.resetAsFace(o,o)}else if(l<-this._tol&&d>this._tol)return n=t.resetAsFace(o,o);o=o.vertexSuccessor}while(o!==i);return this.panic()}reAimAroundFace(t,e,r,o,c){o.resetAsUndefinedWithTag(-Number.MAX_VALUE),c.resetAsUndefinedWithTag(Number.MAX_VALUE);const l=s.NodeXYZUV.createNodeAndRayOrigin(t,e);let d,h=t;do{const t=h.faceSuccessor;d=s.NodeXYZUV.createNodeAndRayOrigin(t,e,d);const u=l.u,f=d.u,g=l.v,p=d.v;if(Math.abs(p)<this._tol){const e=n.HalfEdgePositionDetail.createVertex(t);if(e.setDTag(f),Math.abs(f-r)<this._tol)return c.setFrom(e),o.setFrom(e),a.RC_TargetOnVertex;f>r&&f<c.getDTag()&&c.setFrom(e),f<r&&f>o.getDTag()&&o.setFrom(e)}else if(g*p<0){const t=-g/(p-g),e=i.Geometry.interpolate(u,t,f),s=n.HalfEdgePositionDetail.createEdgeAtFraction(l.node,t);if(s.setDTag(e),Math.abs(e-r)<=this._tol)return c.setFrom(s),o.setFrom(s),a.RC_TargetOnEdge;e>r&&e<c.getDTag()&&(c.setFrom(s),c.setITag(g>0?-1:1)),e<r&&e>o.getDTag()&&(o.setFrom(s),o.setDTag(e))}l.setFrom(d),h=h.faceSuccessor}while(h!==t);const u=c.getITag();return c.setITag(0),o.setITag(0),o.isUnclassified?c.isUnclassified?a.RC_NoHits:a.RC_TargetBefore:c.isUnclassified||c.isEdge&&u&&u<0?a.RC_TargetAfter:a.RC_Bracket}setSearchRay(t,e,r){r.origin.setFromPoint3d(t),o.Vector3d.createStartEnd(r.origin,e,r.direction),r.direction.z=0;const i=r.direction.magnitudeXY();return r.a=r.direction.magnitude(),r.direction.scaleInPlace(1/r.a),i>=this._tol}}e.PointSearchContext=PointSearchContext},"./lib/topology/HalfEdgePositionDetail.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/geometry3d/Point3dVector3d.js");var s;!function(t){t[t.None=0]="None",t[t.Vertex=1]="Vertex",t[t.Edge=2]="Edge",t[t.Face=3]="Face"}(s=e.HalfEdgeTopo||(e.HalfEdgeTopo={}));class HalfEdgePositionDetail{constructor(t,e,r,i,n,s,o,a){this._node=t,this.x=e,this.y=r,this.z=i,this._topo=n,this._edgeFraction=s,this._iTag=o,this._dTag=a}setFrom(t){this._node=t._node,this.x=t.x,this.y=t.y,this.z=t.z,this._topo=t._topo,this._edgeFraction=t._edgeFraction,this._iTag=t._iTag,this._dTag=t._dTag}resetAsUnknown(){this._node=void 0,this._topo=s.None}static create(){return new HalfEdgePositionDetail(void 0,0,0,0,s.None)}getITag(){return this._iTag}setITag(t){this._iTag=t}getDTag(){return this._dTag}setDTag(t){this._dTag=t}getTopo(){return this._topo}static createEdgeAtFraction(t,e){const r=t.faceSuccessor,n=i.Geometry.interpolate(t.x,e,r.x),o=i.Geometry.interpolate(t.y,e,r.y),a=i.Geometry.interpolate(t.z,e,r.z);return new HalfEdgePositionDetail(t,n,o,a,s.Edge,e)}resetAsFace(t,e){return this._topo=s.Face,t&&(this._node=t),e&&(this.x=e.x,this.y=e.y,this.z=e.z),this}resetAsUndefinedWithTag(t){return this._topo=s.None,this._dTag=0,this._iTag=0,this._dTag=t,this._node=void 0,this}resetAtEdgeAndFraction(t,e){this._topo=s.Edge,this._node=t;const r=t.faceSuccessor;return this._edgeFraction=e,this.x=i.Geometry.interpolate(t.x,e,r.x),this.y=i.Geometry.interpolate(t.y,e,r.y),this.z=i.Geometry.interpolate(t.z,e,r.z),this}static createVertex(t){return new HalfEdgePositionDetail(t,t.x,t.y,t.z,s.Vertex)}resetAsVertex(t){return this._topo=s.Vertex,this._node=t,this.setXYZFromNode(t),this}setXYZFromNode(t){this.x=t.x,this.y=t.y,this.z=t.z}get edgeFraction(){return this._edgeFraction}get isFace(){return this._topo===s.Face}get isEdge(){return this._topo===s.Edge}get isVertex(){return this._topo===s.Vertex}get isUnclassified(){return this._topo===s.None}get node(){return this._node}clonePoint(t){return n.Point3d.create(this.x,this.y,this.z,t)}isAtXY(t,e){return this._topo!==s.None&&i.Geometry.isSameCoordinate(this.x,t)&&i.Geometry.isSameCoordinate(this.y,e)}}e.HalfEdgePositionDetail=HalfEdgePositionDetail},"./lib/topology/HalfEdgePriorityQueue.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("@bentley/bentleyjs-core"),n=r("./lib/topology/Merging.js");e.HalfEdgePriorityQueueWithPartnerArray=class HalfEdgePriorityQueueWithPartnerArray{constructor(t=n.HalfEdgeGraphOps.compareNodesYXUp){this.priorityQueue=new i.PriorityQueue(t),this.activeEdges=[]}popQueueToArray(){if(this.priorityQueue.isEmpty)return;const t=this.priorityQueue.pop();return this.activeEdges.push(t),t}popArrayToArrayIndex(t){if(t<this.activeEdges.length){const e=this.activeEdges.pop();this.activeEdges[t]=e}}removeArrayMembersWithY1Below(t){let e=0;const r=this.activeEdges.length;for(let i=0;i<r;i++){const r=this.activeEdges[i];r.faceSuccessor.y>=t&&(e<i&&(this.activeEdges[e]=r),e++)}this.activeEdges.length=e}}},"./lib/topology/InsertAndRetriangulateContext.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/topology/Graph.js"),n=r("./lib/topology/HalfEdgePositionDetail.js"),s=r("./lib/geometry3d/Point3dVector3d.js"),o=r("./lib/numerics/Polynomials.js"),a=r("./lib/topology/HalfEdgePointInGraphSearch.js"),c=r("./lib/geometry3d/Ray3d.js"),l=r("./lib/topology/HalfEdgeMarkSet.js"),d=r("./lib/topology/Triangulation.js");class InsertAndRetriangulateContext{constructor(t){this._graph=t,this._edgeSet=l.MarkedEdgeSet.create(t),this._searcher=n.HalfEdgePositionDetail.create()}static create(t){return new InsertAndRetriangulateContext(t)}get graph(){return this._graph}retriangulateFromBaseVertex(t){const e=t.countEdgesAroundFace();if(this._edgeSet.addAroundFace(t),e<4||t.signedFaceArea()<=0)return;const r=e-3;let i=t.faceSuccessor,n=t;for(let s=0;s<r;s++)i=i.faceSuccessor,i=(n=this._graph.createEdgeHalfEdgeHalfEdge(n,0,i,0)).faceSuccessor,this._edgeSet.addToSet(n)}reset(){this._searcher=n.HalfEdgePositionDetail.create()}get currentPosition(){return this._searcher}searchForNearestEdgeOrVertex(t){const e=n.HalfEdgePositionDetail.create();e.setDTag(Number.MAX_VALUE);const r=s.Point3d.create();let i,a;for(const n of this._graph.allHalfEdges){const s=n.faceSuccessor;void 0!==(i=o.SmallSystem.lineSegment3dXYClosestPointUnbounded(n,s,t))&&(i>1?(a=t.distanceXY(s))<e.getDTag()&&(e.resetAsVertex(s),e.setDTag(a)):i<0?(a=t.distanceXY(n))<e.getDTag()&&(e.resetAsVertex(n),e.setDTag(a)):(n.fractionToPoint3d(i,r),(a=t.distanceXY(r))<e.getDTag()&&e.resetAtEdgeAndFraction(n,i)))}return e}searchForNearestVertex(t){const e=n.HalfEdgePositionDetail.create();let r;e.setDTag(Number.MAX_VALUE);for(const i of this._graph.allHalfEdges)(r=t.distanceXY(i))<e.getDTag()&&(e.resetAsVertex(i),e.setDTag(r));return e}resetSearch(t,e){this._searcher=e>0?this.searchForNearestEdgeOrVertex(t):this.searchForNearestVertex(t)}insertAndRetriangulate(t,e){this.moveToPoint(this._searcher,t);const r=this._searcher.node;let n=!1;if(void 0===r);else if(this._searcher.isFace){if(!r.isMaskSet(i.HalfEdgeMask.EXTERIOR)){const e=this._graph.createEdgeXYZHalfEdge(t.x,t.y,t.z,0,r,0);this.retriangulateFromBaseVertex(e),d.Triangulator.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(e)}n=!0}else if(this._searcher.isEdge){const t=this._graph.splitEdgeAtFraction(r,this._searcher.edgeFraction),e=t.vertexPredecessor;this.retriangulateFromBaseVertex(t),this.retriangulateFromBaseVertex(e),d.Triangulator.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(t),n=!0}else this._searcher.isVertex?(e&&r.setXYZAroundVertex(t.x,t.y,t.z),n=!0):n=!1;return n}moveToPoint(t,e,r){const i=a.PointSearchContext.create();if(t.setITag(0),t.isUnclassified&&(function(t,e,r,i){for(const n of t.allHalfEdges)if(!n.isMaskSet(i))return e.resetAtEdgeAndFraction(n,r),!0}(this.graph,t,.5,0),t.isUnclassified))return!1;const s=c.Ray3d.createXAxis();for(;0===t.getITag();){if(void 0!==r){if(!r(t))break}if(!i.setSearchRay(t,e,s))return!1;if(t.isFace){const r=n.HalfEdgePositionDetail.create(),o=n.HalfEdgePositionDetail.create();switch(i.reAimAroundFace(t.node,s,s.a,r,o)){case a.RayClassification.RC_NoHits:t.resetAsUnknown();break;case a.RayClassification.RC_TargetOnVertex:case a.RayClassification.RC_TargetOnEdge:t.setFrom(r),t.setITag(1);break;case a.RayClassification.RC_Bracket:t.resetAsFace(r.node,e),t.setITag(1);break;case a.RayClassification.RC_TargetBefore:t.resetAsFace(t.node,e),t.setITag(1);break;case a.RayClassification.RC_TargetAfter:t.setFrom(r)}}else if(t.isEdge){if(i.reAimFromEdge(t,s,s.a),t.isUnclassified)break}else if(t.isVertex&&(i.reAimFromVertex(t,s,s.a),t.isUnclassified))break}return t.isAtXY(e.x,e.y)}}e.InsertAndRetriangulateContext=InsertAndRetriangulateContext},"./lib/topology/MaskManager.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class MaskManager{constructor(t,e){this._originalFreeMasks=t,this._freeMasks=t,this._firstFreeMask=e}static create(t){let e=0,r=1;for(let i=0;i<32;i++){if(0!==(r&t)){e=r;break}r<<=1}if(0!==e)return new MaskManager(t,e)}grabMask(){let t=this._firstFreeMask;if(0===this._freeMasks)return 0;for(;!(t&this._freeMasks);)t<<=1;return this._freeMasks&=~t,t}dropMask(t){t&=this._originalFreeMasks,this._freeMasks|=t}}e.MaskManager=MaskManager},"./lib/topology/Merging.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/Geometry.js"),n=r("./lib/topology/Graph.js"),s=r("./lib/numerics/ClusterableArray.js"),o=r("./lib/geometry3d/Range.js"),a=r("./lib/topology/HalfEdgePriorityQueue.js"),c=r("./lib/numerics/Polynomials.js"),l=r("./lib/geometry3d/Point2dVector2d.js"),d=r("./lib/geometry3d/Angle.js"),h=r("./lib/topology/Triangulation.js"),u=r("./lib/topology/RegularizeFace.js");class GraphSplitData{constructor(){this.numUpEdge=0,this.numIntersectionTest=0,this.numSplit=0,this.numPopOut=0,this.numA0B0=0,this.numA0B1=0}}e.GraphSplitData=GraphSplitData;class HalfEdgeGraphOps{static compareNodesYXUp(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static isDownPeak(t){const e=t.facePredecessor,r=t.faceSuccessor;return this.compareNodesYXUp(t,e)<0&&this.compareNodesYXUp(t,r)<0&&this.crossProductToTargets(t,e,r)>0}static crossProductToTargets(t,e,r){return i.Geometry.crossProductXYXY(e.x-t.x,e.y-t.y,r.x-t.x,r.y-t.y)}static graphRange(t){const e=o.Range3d.create();for(const r of t.allHalfEdges)e.extendXYZ(r.x,r.y,r.z);return e}static segmentArrayToGraphEdges(t,e,r){const i=[];let n=0;for(const s of t){const t=e.createEdgeXYZXYZ(s.point0Ref.x,s.point0Ref.y,s.point0Ref.z,n,s.point1Ref.x,s.point1Ref.y,s.point1Ref.z,n+1),o=t.edgeMate;n+=2,t.setMaskAroundFace(r),i.push(t),i.push(o)}return i}static formMonotoneFaces(t){const e=t.collectFaceLoops();t.clearMask(n.HalfEdgeMask.VISITED);for(const r of e){if(r.isMaskSet(n.HalfEdgeMask.VISITED))continue;r.signedFaceArea()<=0&&r.setMaskAroundFace(n.HalfEdgeMask.VISITED)}}static isolateAllEdges(t){for(const e of t.allHalfEdges){const t=e.vertexPredecessor;n.HalfEdge.pinch(e,t)}}}e.HalfEdgeGraphOps=HalfEdgeGraphOps;e.HalfEdgeGraphMerge=class HalfEdgeGraphMerge{static clusterAndMergeXYTheta(t){const e=t.allHalfEdges,r=e.length;t.clearMask(n.HalfEdgeMask.NULL_FACE);const i=new s.ClusterableArray(2,2,r);for(let s=0;s<r;s++){const t=e[s],r=t.x,o=t.y;n.HalfEdge.pinch(t,t.vertexSuccessor),i.addDirect(r,o,0,s)}const o=i.clusterIndicesLexical();let a=0;const c=o.length;for(let n=0;n<c;n++)if(o[n]===s.ClusterableArray.clusterTerminator){if(n>a){const t=e[i.getExtraData(o[a],1)];for(let r=a+1;r<n;r++){const n=e[i.getExtraData(o[r],1)];n.x=t.x,n.y=t.y}}a=n+1}for(const n of o)if(n!==s.ClusterableArray.clusterTerminator){const t=e[n],r=t.faceSuccessor;let s=Math.atan2(r.y-t.y,r.x-t.x);d.Angle.isAlmostEqualRadiansAllowPeriodShift(s,-Math.PI)&&(s=Math.PI),i.setExtraData(n,0,s)}i.sortSubsetsBySingleKey(o,2);const l=[];let h,u;a=0;for(let f=0;f<c;f++)if(o[f]===s.ClusterableArray.clusterTerminator){if(f>a){const t=i.getExtraData(o[a],1);h=i.getExtraData(o[a],0);let r=e[t];for(let s=a+1;s<f;s++){const t=i.getExtraData(o[s],1);u=i.getExtraData(o[s],0);const a=e[t];if(r.isMaskSet(n.HalfEdgeMask.NULL_FACE)){const t=l.findIndex(t=>r===t);t>=0&&(l[t]=l[l.length-1],l.pop()),r=a,h=u}else if(a.isMaskSet(n.HalfEdgeMask.NULL_FACE)){const t=l.findIndex(t=>r===t);t>=0&&(l[t]=l[l.length-1],l.pop())}else{if(n.HalfEdge.pinch(r,a),d.Angle.isAlmostEqualRadiansAllowPeriodShift(h,u)){const t=r.faceSuccessor,e=a.edgeMate;n.HalfEdge.pinch(t,e),r.setMask(n.HalfEdgeMask.NULL_FACE),e.setMask(n.HalfEdgeMask.NULL_FACE),l.push(e)}r=a,h=u}}}a=f+1}}static buildVerticalSweepPriorityQueue(t){const e=new a.HalfEdgePriorityQueueWithPartnerArray;for(const r of t.allHalfEdges)HalfEdgeGraphOps.compareNodesYXUp(r,r.faceSuccessor)<0&&e.priorityQueue.push(r);return e}static computeIntersectionFractionsOnEdges(t,e,r,n,s){const o=t.faceSuccessor,a=t.x,l=t.y,d=o.x-a,h=o.y-l,u=e.faceSuccessor,f=e.x,g=e.y,p=u.x-f,m=u.y-g;return!!c.SmallSystem.lineSegmentXYUVTransverseIntersectionUnbounded(a,l,d,h,f,g,p,m,r)&&(n.x=a+r.x*d,n.y=l+r.x*h,s.x=f+r.y*p,s.y=g+r.y*m,i.Geometry.isIn01(r.x)&&i.Geometry.isIn01(r.y))}static splitIntersectingEdges(t){const e=new GraphSplitData,r=this.buildVerticalSweepPriorityQueue(t);let n,s,o;const a=l.Vector2d.create(),c=l.Point2d.create(),d=l.Point2d.create();let h;for(;void 0!==(n=r.priorityQueue.pop());){e.numUpEdge++;const l=r.activeEdges.length;for(r.removeArrayMembersWithY1Below(n.y),e.numPopOut+=l-r.activeEdges.length,o=0;o<r.activeEdges.length;o++)if(s=(h=r.activeEdges[o]).faceSuccessor,i.Geometry.isSameCoordinateXY(n.x,n.y,h.x,h.y))e.numA0B0++;else if(i.Geometry.isSameCoordinateXY(s.x,s.y,n.x,n.y))e.numA0B1++;else if(e.numIntersectionTest++,this.computeIntersectionFractionsOnEdges(n,h,a,c,d)){if(a.x>1e-8&&a.x<1-1e-8){const i=t.splitEdgeAtFraction(n,a.x);r.priorityQueue.push(i),e.numSplit++}if(a.y>1e-8&&a.y<1-1e-8){const i=t.splitEdgeAtFraction(h,a.y);r.priorityQueue.push(i),e.numSplit++}}r.activeEdges.push(n)}return e}static formGraphFromSegments(t){const e=new n.HalfEdgeGraph;return HalfEdgeGraphOps.segmentArrayToGraphEdges(t,e,n.HalfEdgeMask.BOUNDARY_EDGE),this.splitIntersectingEdges(e),this.clusterAndMergeXYTheta(e),e}static formGraphFromChains(t,e=!0,r=n.HalfEdgeMask.PRIMARY_EDGE){if(t.length<1)return;const i=new n.HalfEdgeGraph,s=h.Triangulator.directCreateChainsFromCoordinates(i,t);for(const n of s)n.setMaskAroundFace(r);return this.splitIntersectingEdges(i),this.clusterAndMergeXYTheta(i),e&&new u.RegularizationContext(i).regularizeGraph(!0,!0),i}}},"./lib/topology/RegularizeFace.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/topology/Graph.js"),n=r("./lib/topology/Merging.js");e.RegularizationContext=class RegularizationContext{constructor(t){this.graph=t,this.upEdges=[],this.downEdges=[],this.bottomPeaks=[],this.topPeaks=[],this.localMin=[],this.localMax=[]}collectVerticalEventsAroundFace(t){let e,r,i,s,o=t;this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0;do{r=(e=o.faceSuccessor).faceSuccessor,i=n.HalfEdgeGraphOps.compareNodesYXUp(o,e)<0,s=n.HalfEdgeGraphOps.compareNodesYXUp(e,r)<0,i?(this.upEdges.push(o),s||(n.HalfEdgeGraphOps.crossProductToTargets(e,o,r)<0?this.localMax.push(e):this.topPeaks.push(e))):(this.downEdges.push(o),s&&(n.HalfEdgeGraphOps.crossProductToTargets(e,o,r)>0?this.bottomPeaks.push(e):this.localMin.push(e))),o=e}while(o!==t)}collectVerticalEventFromEdgesInAndArray(t){let e,r,i,s,o;for(e of(this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0,t))i=(r=e.faceSuccessor).faceSuccessor,s=n.HalfEdgeGraphOps.compareNodesYXUp(e,r)<0,o=n.HalfEdgeGraphOps.compareNodesYXUp(r,i)<0,s?(this.upEdges.push(e),o||(n.HalfEdgeGraphOps.crossProductToTargets(r,e,i)<0?this.localMax.push(r):this.topPeaks.push(r))):(this.downEdges.push(e),o&&(n.HalfEdgeGraphOps.crossProductToTargets(r,e,i)>0?this.bottomPeaks.push(r):this.localMin.push(r)))}swapArrays(){let t=this.downEdges;this.downEdges=this.upEdges,this.upEdges=t,t=this.localMax,this.localMax=this.localMin,this.localMin=t,t=this.topPeaks,this.topPeaks=this.bottomPeaks,this.bottomPeaks=t}findTopVisibleEdge(t,e,r){const s=t.y,o=t.x;let a,c,l=Number.MAX_SAFE_INTEGER;for(const d of e){const e=d.faceSuccessor;if(d===t||e===t)continue;if(n.HalfEdgeGraphOps.compareNodesYXUp(t,d)*n.HalfEdgeGraphOps.compareNodesYXUp(t,e)>=0)continue;const h=i.HalfEdge.horizontalScanFraction01(d,s);void 0!==h&&(a=r*(d.fractionToX(h)-o))>0&&a<l&&(c=d,l=a)}return c}highestUpPeakConnection(t,e,r){let s;for(const o of this.topPeaks){const a=o.y,c=o.x;if(!(void 0!==s&&n.HalfEdgeGraphOps.compareNodesYXUp(o,s)<0)&&n.HalfEdgeGraphOps.compareNodesYXUp(o,t)<0){if(e){const t=i.HalfEdge.horizontalScanFraction01(e,a);if(void 0===t)continue;if(c<=e.fractionToX(t))continue}if(r){const t=i.HalfEdge.horizontalScanFraction01(r,a);if(void 0===t)continue;if(r.fractionToX(t)<=c)continue}s=o}}return s}updateMaxNode(t,e,r){return t?e&&r(t,e)<0?e:t:e}negateXY(){for(const t of this.graph.allHalfEdges)t.x*=-1,t.y*=-1}downwardConnectionFromBottomPeak(t){let e;const r=n.HalfEdgeGraphOps.compareNodesYXUp,i=this.findTopVisibleEdge(t,this.upEdges,1),s=this.findTopVisibleEdge(t,this.downEdges,-1);e=this.updateMaxNode(e,i,r),s&&(e=this.updateMaxNode(e,s.faceSuccessor,r));const o=this.highestUpPeakConnection(t,s,i);return void 0!==o&&(e=this.updateMaxNode(e,o,r)),e}joinNodes(t,e){const r=this.graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0);return i.HalfEdge.pinch(t,r),i.HalfEdge.pinch(e,r.edgeMate),r}runRegularization(t=!0,e=!0){if(t){this.bottomPeaks.sort(n.HalfEdgeGraphOps.compareNodesYXUp);for(const t of this.bottomPeaks){if(!n.HalfEdgeGraphOps.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e)}}if(e){this.negateXY(),this.swapArrays(),this.bottomPeaks.sort(n.HalfEdgeGraphOps.compareNodesYXUp);for(const t of this.bottomPeaks){if(!n.HalfEdgeGraphOps.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e)}this.negateXY(),this.swapArrays()}}regularizeFace(t,e=!0,r=!0){this.collectVerticalEventsAroundFace(t),this.runRegularization(e,r)}regularizeGraph(t=!0,e=!0){this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges),this.runRegularization(t,e)}static isMonotoneFace(t){let e,r=0,i=0,s=t;do{const t=s.faceSuccessor,o=t.faceSuccessor,a=n.HalfEdgeGraphOps.compareNodesYXUp(s,t),c=n.HalfEdgeGraphOps.compareNodesYXUp(t,o);a*c<=0&&(a>0&&(r++,e=t),c>0&&i++)}while((s=s.faceSuccessor)!==t);return 1===r&&1===i?e:void 0}static collectMappedFaceRepresentatives(t,e,r,n,s){n&&(n.length=0),s&&(s.length=0);const o=i.HalfEdgeMask.VISITED;t.clearMask(o);for(const i of t.allHalfEdges)if(!i.getMask(o)&&(i.setMaskAroundFace(o),!e||i.signedFaceArea()>0)){const t=r(i);t?n&&n.push(t):s&&s.push(i)}}}},"./lib/topology/SignedDataSummary.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.SignedDataSummary=class SignedDataSummary{constructor(t){this.positiveSum=this.negativeSum=0,this.numPositive=this.numNegative=this.numZero=0,this.largestPositiveValue=this.largestNegativeValue=0,t&&(this.negativeItemArray=[],this.positiveItemArray=[],this.zeroItemArray=[])}announceItem(t,e){e<0?(this.numNegative++,this.negativeSum+=e,this.negativeItemArray&&this.negativeItemArray.push(t),e<this.largestNegativeValue&&(this.largestNegativeValue=e,this.largestNegativeItem=t)):e>0?(this.numPositive++,this.positiveSum+=e,this.positiveItemArray&&this.positiveItemArray.push(t),e>this.largestPositiveValue&&(this.largestPositiveValue=e,this.largestPositiveItem=t)):(this.numZero++,this.zeroItemArray&&this.zeroItemArray.push(t))}}},"./lib/topology/Triangulation.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=r("./lib/topology/Graph.js"),n=r("./lib/geometry3d/Point3dVector3d.js"),s=r("./lib/Geometry.js"),o=r("./lib/geometry3d/IndexedXYZCollection.js"),a=r("./lib/geometry3d/PointStreaming.js"),c=r("./lib/geometry3d/PointHelpers.js"),l=r("./lib/topology/InsertAndRetriangulateContext.js"),d=r("./lib/topology/HalfEdgeMarkSet.js");class Triangulator{static flipEdgeBetweenTriangles(t,e,r,n,s,o){i.HalfEdge.pinch(t,s),i.HalfEdge.pinch(r,n),i.HalfEdge.pinch(o,r),i.HalfEdge.pinch(s,e),s.x=e.x,s.y=e.y,s.z=e.z,s.i=e.i,r.i=o.i,r.x=o.x,r.y=o.y,r.z=o.z}static computeInCircleDeterminantIsStrongPositive(t){const e=t.faceSuccessor,r=e.faceSuccessor;if(r.faceSuccessor!==t)return!1;const i=t.edgeMate,n=i.faceSuccessor.faceSuccessor;if(n.faceSuccessor!==i)return!1;const o=e.x-t.x,a=e.y-t.y,c=r.x-t.x,l=r.y-t.y;if(s.Geometry.crossProductXYXY(o,a,c,l)<0)return!1;const d=n.x-t.x,h=n.y-t.y,u=d*d+h*h,f=c*c+l*l,g=o*o+a*a,p=s.Geometry.tripleProduct(d,h,u,c,l,f,o,a,g);return!(p<0)&&p>1e-12*(Math.abs(d*l*g)+Math.abs(d*f*o)+Math.abs(u*c*a)+Math.abs(d*f*a)+Math.abs(h*c*g)+Math.abs(u*l*o))}static flipTriangles(t){const e=d.MarkedEdgeSet.create(t);for(const i of t.allHalfEdges)e.addToSet(i);const r=this.flipTrianglesInEdgeSet(t,e);return e.teardown(),r}static flipTrianglesInEdgeSet(t,e){const r=i.HalfEdgeMask.EXTERIOR|i.HalfEdgeMask.PRIMARY_EDGE|i.HalfEdgeMask.BOUNDARY_EDGE,n=10*t.allHalfEdges.length;let s,o=0,a=0;for(;void 0!==(s=e.chooseAndRemoveAny())&&(s.isMaskSet(r)||(Triangulator.computeInCircleDeterminantIsStrongPositive(s)?(Triangulator.flipEdgeBetweenTriangles(s.edgeMate.faceSuccessor,s.edgeMate.facePredecessor,s.edgeMate,s.faceSuccessor,s,s.facePredecessor),e.addAroundFace(s),e.addAroundFace(s.edgeMate),o++):a++,!(o+a>n))););return o}static createTriangulatedGraphFromPoints(t){if(t.length<3)return;const e=[],r=[];c.Point3dArray.computeConvexHullXY(t,e,r,!0);const n=new i.HalfEdgeGraph,s=l.InsertAndRetriangulateContext.create(n);Triangulator.createFaceLoopFromCoordinates(n,e,!0,!0);let o=0;for(const i of r)s.insertAndRetriangulate(i,!0),++o>16&&(o=0);return n}static createTriangulatedGraphFromLoops(t){if(t.length<1)return;const e=i.HalfEdgeMask.BOUNDARY_EDGE|i.HalfEdgeMask.PRIMARY_EDGE,r=new i.HalfEdgeGraph,n=[];let s=-1e4,o=-1;for(let i=0;i<t.length;i++){let a=Triangulator.directCreateFaceLoopFromCoordinates(r,t[i]);if(a){const t=(a=a.faceSuccessor).vertexSuccessor;a.setMaskAroundFace(e),t.setMaskAroundFace(e);const r=a.signedFaceArea(),c=Math.abs(r);n.push(r>=0?a:t),(0===i||c>s)&&(s=c,o=i)}}if(0===n.length)return;const a=n[o];n[o]=n[n.length-1],n.pop(),a.vertexSuccessor.setMaskAroundFace(i.HalfEdgeMask.EXTERIOR);for(let l=0;l<n.length;l++){const t=n[l];t.setMaskAroundFace(i.HalfEdgeMask.EXTERIOR),n[l]=this.getLeftmost(t.vertexSuccessor)}const c=Triangulator.spliceLeftMostNodesOfHoles(r,a,n);return Triangulator.triangulateSingleFace(r,c),r}static triangulateAllPositiveAreaFaces(t){const e=t.collectFaceLoops();for(const r of e)if(r.countEdgesAroundFace()>3){r.signedFaceArea()>0&&Triangulator.triangulateSingleFace(t,r)}}static createTriangulatedGraphFromSingleLoop(t){const e=new i.HalfEdgeGraph,r=Triangulator.createFaceLoopFromCoordinates(e,t,!0,!0);return!r||e.countNodes()<6?e:(Triangulator.triangulateSingleFace(e,r),Triangulator.flipTriangles(e),e)}static interiorEdgeSplit(t,e,r){let i=0,n=0,s=0;if(Array.isArray(r))i=r[0],n=r[1],s=r.length>2?r[3]:0;else{const t=r;t.hasOwnProperty("x")&&(i=t.x),t.hasOwnProperty("y")&&(n=t.y),t.hasOwnProperty("y")&&(s=t.z)}return e?Triangulator.equalXAndYXY(e,i,n)?e:Triangulator.equalXAndYXY(e.faceSuccessor,i,n)?e:t.splitEdge(e,i,n,s):t.splitEdge(e,i,n,s)}static directCreateFaceLoopFromCoordinates(t,e){let r;if(e instanceof o.IndexedXYZCollection){const i=n.Point3d.create();for(let n=0;n<e.length;n++)e.getPoint3dAtCheckedPointIndex(n,i),r=Triangulator.interiorEdgeSplit(t,r,i)}else for(const i of e)r=Triangulator.interiorEdgeSplit(t,r,i);return r}static directCreateChainsFromCoordinates(t,e,r=0){const i=new AssembleXYZXYZChains(t,r);return a.VariantPointDataStream.streamXYZ(e,i),i.claimSeeds()}static maskAndOrientNewFaceLoop(t,e,r,n,s){if(e){const t=(e=e.faceSuccessor).signedFaceArea(),o=e.edgeMate;n!==i.HalfEdgeMask.NULL_MASK&&(e.setMaskAroundFace(n),o.setMaskAroundFace(n));let a=e;r&&t<0&&(a=o);const c=a.vertexSuccessor;return s!==i.HalfEdgeMask.NULL_MASK&&c.setMaskAroundFace(s),a}}static createFaceLoopFromCoordinates(t,e,r,n){const s=Triangulator.directCreateFaceLoopFromCoordinates(t,e);return Triangulator.maskAndOrientNewFaceLoop(t,s,r,i.HalfEdgeMask.BOUNDARY_EDGE|i.HalfEdgeMask.PRIMARY_EDGE,n?i.HalfEdgeMask.EXTERIOR:i.HalfEdgeMask.NULL_MASK)}static createFaceLoopFromCoordinatesAndMasks(t,e,r,i,n){const s=Triangulator.directCreateFaceLoopFromCoordinates(t,e);return Triangulator.maskAndOrientNewFaceLoop(t,s,r,i,n)}static joinNeighborsOfEar(t,e){const r=t.createEdgeXYZXYZ(e.facePredecessor.x,e.facePredecessor.y,e.facePredecessor.z,e.facePredecessor.i,e.faceSuccessor.x,e.faceSuccessor.y,e.faceSuccessor.z,e.faceSuccessor.i),n=r.edgeMate;i.HalfEdge.pinch(e.faceSuccessor,n),i.HalfEdge.pinch(e.facePredecessor,r),e.setMaskAroundFace(i.HalfEdgeMask.TRIANGULATED_FACE)}static isInteriorTriangle(t){if(!t.isMaskSet(i.HalfEdgeMask.TRIANGULATED_FACE))return!1;const e=t.faceSuccessor;if(!e.isMaskSet(i.HalfEdgeMask.TRIANGULATED_FACE))return!1;const r=e.faceSuccessor;return!!r.isMaskSet(i.HalfEdgeMask.TRIANGULATED_FACE)&&r.faceSuccessor===t}static doPostCutFlips(t){let e=t,r=e.facePredecessor,i=r.edgeMate;for(;Triangulator.isInteriorTriangle(r)&&Triangulator.isInteriorTriangle(i);){if(!Triangulator.computeInCircleDeterminantIsStrongPositive(r))break;const t=i.faceSuccessor;Triangulator.flipEdgeBetweenTriangles(t,t.faceSuccessor,t.facePredecessor,e,e.facePredecessor,e.faceSuccessor),i=(r=(e=r).facePredecessor).edgeMate}return e}static triangulateSingleFace(t,e){if(!e)return;let r,n,s=e.countEdgesAroundFace(),o=0;for(e.clearMaskAroundFace(i.HalfEdgeMask.TRIANGULATED_FACE);!e.isMaskSet(i.HalfEdgeMask.TRIANGULATED_FACE)&&(n=(r=e.faceSuccessor).faceSuccessor,r!==e&&n!==e&&n.faceSuccessor!==e)&&!(++o>s);)Triangulator.isEar(e)?(s--,o=0,e.faceSuccessor.faceSuccessor!==e.facePredecessor?(Triangulator.joinNeighborsOfEar(t,e),e=(e=Triangulator.doPostCutFlips(e)).faceSuccessor.edgeMate.faceSuccessor):(e.setMaskAroundFace(i.HalfEdgeMask.TRIANGULATED_FACE),e=r.faceSuccessor)):e=r}static isEar(t){const e=t.facePredecessor,r=t,i=t.faceSuccessor;if(Triangulator.signedTriangleArea(e,r,i)>=0)return!1;let n=t.faceSuccessor.faceSuccessor;for(;n!==t.facePredecessor;){if(Triangulator.pointInTriangle(e.x,e.y,r.x,r.y,i.x,i.y,n.x,n.y)&&Triangulator.signedTriangleArea(n.facePredecessor,n,n.faceSuccessor)>=0)return!1;n=n.faceSuccessor}return!0}static spliceLeftMostNodesOfHoles(t,e,r){r.sort(Triangulator.compareX);for(const i of r)Triangulator.eliminateHole(t,i,e);return e}static compareX(t,e){return t.x-e.x}static eliminateHole(t,e,r){const i=Triangulator.findHoleBridge(e,r);i&&Triangulator.splitFace(t,i,e)}static findHoleBridge(t,e){let r=e;if(!r)return;const i=t.x,n=t.y;let s,o=-1/0;do{if(n<=r.y&&n>=r.faceSuccessor.y&&r.faceSuccessor.y!==r.y){const t=r.x+(n-r.y)*(r.faceSuccessor.x-r.x)/(r.faceSuccessor.y-r.y);if(t<=i&&t>o){if(o=t,t===i){if(n===r.y)return r;if(n===r.faceSuccessor.y)return r.faceSuccessor}s=r.x<r.faceSuccessor.x?r:r.faceSuccessor}}r=r.faceSuccessor}while(r!==e);if(!s)return;if(i===o)return s.facePredecessor;const a=s,c=s.x,l=s.y;let d,h=1/0;for(r=s.faceSuccessor;r!==a;)i>=r.x&&r.x>=c&&i!==r.x&&Triangulator.pointInTriangle(n<l?i:o,n,c,l,n<l?o:i,n,r.x,r.y)&&((d=Math.abs(n-r.y)/(i-r.x))<h||d===h&&r.x>s.x)&&Triangulator.locallyInside(r,t)&&(s=r,h=d),r=r.faceSuccessor;return s}static getLeftmost(t){let e=t,r=t;do{e.x<r.x&&(r=e),e=e.faceSuccessor}while(e!==t);return r}static pointInTriangle(t,e,r,i,n,s,o,a){return(n-o)*(e-a)-(t-o)*(s-a)>=0&&(t-o)*(i-a)-(r-o)*(e-a)>=0&&(r-o)*(s-a)-(n-o)*(i-a)>=0}static signedTriangleArea(t,e,r){return.5*((e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y))}static equalXAndYXY(t,e,r){return s.Geometry.isSameCoordinate(t.x,e)&&s.Geometry.isSameCoordinate(t.y,r)}static locallyInside(t,e){return Triangulator.signedTriangleArea(t.facePredecessor,t,t.faceSuccessor)<0?Triangulator.signedTriangleArea(t,e,t.faceSuccessor)>=0&&Triangulator.signedTriangleArea(t,t.facePredecessor,e)>=0:Triangulator.signedTriangleArea(t,e,t.facePredecessor)<0||Triangulator.signedTriangleArea(t,t.faceSuccessor,e)<0}static splitFace(t,e,r){const n=t.createEdgeXYZXYZ(e.x,e.y,e.z,e.i,r.x,r.y,r.z,r.i),s=n.faceSuccessor;return i.HalfEdge.pinch(e,n),i.HalfEdge.pinch(r,s),n}static triangulateSingleMonotoneFace(t,e){let r,n=e.facePredecessor,s=e.faceSuccessor,o=e,a=e,c=e;for(;n!==s&&s!==e&&s.faceSuccessor!==n;){if(i.HalfEdge.crossProductXYAlongChain(n,e,s)<=0)return!1;if(!e.belowYX(n))return!1;if(!e.belowYX(s))return!1;if(n.belowYX(s)){for(o=n,a=e,c=s;o!==c&&o.belowYX(s);){for(;c!==s&&c!==o&&c!==a&&i.HalfEdge.crossProductXYAlongChain(o,a,c)>0;)c=(a=(o=r=Triangulator.splitFace(t,o,c)).faceSuccessor).faceSuccessor;c=a,a=o,o=o.facePredecessor}for(n=a,o=(a=(c=s).facePredecessor).facePredecessor;c.faceSuccessor!==o&&o!==n;)o=(a=r=Triangulator.splitFace(t,o,c)).facePredecessor;c.faceSuccessor!==o&&(o=r=Triangulator.splitFace(t,o,c)),s=(e=o).faceSuccessor,n=e.facePredecessor}else{for(o=n,a=e,c=s;o!==c&&c.belowYX(n);){for(;o!==n&&c!==o&&c!==a&&i.HalfEdge.crossProductXYAlongChain(o,a,c)>0;)o=(r=Triangulator.splitFace(t,o,c)).facePredecessor,a=r;o=a,a=c,c=c.faceSuccessor}for(s=a,c=(a=(o=n).faceSuccessor).faceSuccessor;c.faceSuccessor!==o&&c!==s;)o=r=Triangulator.splitFace(t,o,c),a=c,c=c.faceSuccessor;c.faceSuccessor!==o&&Triangulator.splitFace(t,o,c),s=(e=s).faceSuccessor,n=e.facePredecessor}}return!0}}e.Triangulator=Triangulator;class AssembleXYZXYZChains extends a.PointStreamXYZXYZHandlerBase{constructor(t,e){super(),this._graph=t,this._id=e}startChain(t,e){super.startChain(t,e),this._baseNode=void 0,this._nodeB=void 0}handleXYZXYZ(t,e,r,n,s,o){this._nodeC=this._graph.createEdgeXYZXYZ(t,e,r,this._id,n,s,o,this._id),void 0===this._baseNode?(this._baseNode=this._nodeC,this._nodeB=this._baseNode.faceSuccessor):(i.HalfEdge.pinch(this._nodeB,this._nodeC),this._nodeB=this._nodeC.faceSuccessor)}endChain(t,e){super.endChain(t,e),void 0!==this._baseNode&&(void 0===this._seeds&&(this._seeds=[]),this._seeds.push(this._baseNode)),this._baseNode=void 0,this._nodeB=void 0,this._nodeC=void 0}claimSeeds(){return void 0===this._seeds?[]:this._seeds}}},"./lib/topology/XYParitySearchContext.js":function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.XYParitySearchContext=class XYParitySearchContext{constructor(t,e){this.xTest=t,this.yTest=e,this.u0=this.v0=this.u1=this.v1=0,this.numLeftCrossing=this.numRightCrossing=0,this.numHit=0}tryStartEdge(t,e,r,i){return e!==this.yTest&&(this.u0=t-this.xTest,this.v0=e-this.yTest,this.u1=r-this.xTest,this.v1=i-this.yTest,!0)}advance(t,e){const r=t-this.xTest,i=e-this.yTest,n=i*this.v1;if(n>0)return this.u0=this.u1,this.v0=this.v1,this.u1=r,this.v1=i,!0;if(n<0){const t=-this.v1/(i-this.v1),e=this.u1+t*(r-this.u1);return 0===e?(this.numHit++,!1):(e>0?this.numRightCrossing++:this.numLeftCrossing++,this.u0=this.u1,this.v0=this.v1,this.u1=r,this.v1=i,!0)}if(0===i)return 0===this.v1?r*this.u1<=0?(this.numHit++,!1):(this.u1=r,this.v1=i,!0):(this.u0=this.u1,this.v0=this.v1,this.u1=r,this.v1=i,!0);const s=this.v0*i;return this.u1>0?s<0&&this.numRightCrossing++:s<0&&this.numLeftCrossing++,this.u0=this.u1,this.v0=this.v1,this.u1=r,this.v1=i,!0}classifyCounts(){return this.numHit>0?0:1===(1&this.numLeftCrossing)?1:-1}}},"@bentley/bentleyjs-core":function(e,r){e.exports=t}},[["./lib/geometry-core.js",1]]])});
//# sourceMappingURL=geometry-core.js.map